<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.7.2"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="UCB CS61B Lecture Notes" /><meta name="author" content="Xiao Fan" /><meta property="og:locale" content="en_US" /><meta name="description" content="1 Introduction" /><meta property="og:description" content="1 Introduction" /><link rel="canonical" href="https://tommyfan34.github.io/posts/CS61B-notes/" /><meta property="og:url" content="https://tommyfan34.github.io/posts/CS61B-notes/" /><meta property="og:site_name" content="Xiao Fan (樊潇)" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-04-16T17:09:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="UCB CS61B Lecture Notes" /><meta name="twitter:site" content="@tommyfan34" /><meta name="twitter:creator" content="@Xiao Fan" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Xiao Fan"},"description":"1 Introduction","headline":"UCB CS61B Lecture Notes","url":"https://tommyfan34.github.io/posts/CS61B-notes/","@type":"BlogPosting","dateModified":"2021-08-26T16:42:32+08:00","datePublished":"2021-04-16T17:09:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://tommyfan34.github.io/posts/CS61B-notes/"},"@context":"https://schema.org"}</script><title>UCB CS61B Lecture Notes | Xiao Fan (樊潇)</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" href="/assets/css/post.css" as="style"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-FTKB0LQYH6"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-FTKB0LQYH6'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/sample/me.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Xiao Fan (樊潇)</a></div><div class="site-subtitle font-italic">Lots of hair | 低质量人类男性，新一线城市做题家，屎山代码制造机</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tabs/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tabs/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/tabs/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tabs/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/tommyfan34" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/tommyfan34" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['tommyfanzju','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="https://www.linkedin.com/in/xiao-fan-6a21b7171" aria-label="linkedin" class="order-6" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://www.facebook.com/tommyfanzju" aria-label="facebook" class="order-7" target="_blank" rel="noopener"> <i class="fab fa-facebook"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>UCB CS61B Lecture Notes</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>UCB CS61B Lecture Notes</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Apr 16, 2021, 5:09 PM +0800" > Apr 16, 2021 <i class="unloaded">2021-04-16T17:09:00+08:00</i> </span> by <span class="author"> Xiao Fan </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Aug 26, 2021, 4:42 PM +0800" > Aug 26, 2021 <i class="unloaded">2021-08-26T16:42:32+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="14003 words">77 min</span></div></div><div class="post-content"><h1 id="1-introduction">1 Introduction</h1><p>CS61B Spring 2018课程网址: <a href="https://sp18.datastructur.es/">https://sp18.datastructur.es/</a></p><p>推荐的Java参考书：<em>Head First Java</em></p><h2 id="11-java-intro">1.1 Java Intro</h2><p>Java是一门静态类型编译型的语言，源文件类型为.java，经过<code class="language-plaintext highlighter-rouge">javac</code>编译器将其编译为.class文件，此时.class文件是已经经过类型检查的，再用<code class="language-plaintext highlighter-rouge">java</code>解释器去执行这个.class文件</p><p>Java是纯面向对象语言，所有的函数都在一个class中。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="cm">/* Dog.java */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">weightInPounds</span><span class="o">;</span>
    
    <span class="cm">/* one integer constructor for dogs */</span>
    <span class="kd">public</span> <span class="nf">Dog</span><span class="o">(</span><span class="kt">int</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">weightInPounds</span> <span class="o">=</span> <span class="n">w</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeNoise</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">weightInPounds</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"yip!"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">weightInPounds</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"bark"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"wooof!"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/* DogLauncher.java */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DogLauncher</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Dog</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">d</span><span class="o">.</span><span class="na">weightInPounds</span> <span class="o">=</span> <span class="mi">51</span><span class="o">;</span>
        <span class="n">d</span><span class="o">.</span><span class="na">makeNoise</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="o">&gt;</span> <span class="n">javac</span> <span class="nc">Dog</span><span class="o">.</span><span class="na">java</span>
<span class="o">&gt;</span> <span class="n">javac</span> <span class="nc">DogLauncher</span><span class="o">.</span><span class="na">java</span>
<span class="o">&gt;</span> <span class="n">java</span> <span class="nc">DogLauncher</span>
<span class="n">wooof</span><span class="o">!</span>
</pre></table></code></div></div><p>注意：这里的<code class="language-plaintext highlighter-rouge">makeNoise</code>方法是一个<em>non-static</em>方法，也就是一个实例方法。如果一个方法是被一个实例调用的，那么这个方法必须是non-static</p><p>如果想创建一个元素为对象的数组：</p><ul><li>声明一个该类型的数组变量<li>对该数组的每个元素用<code class="language-plaintext highlighter-rouge">new</code>创建一个新的对象并赋值</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nc">Dog</span><span class="o">[]</span> <span class="n">dogs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
<span class="n">dogs</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="mi">8</span><span class="o">);</span>
<span class="n">dogs</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>
<span class="n">dogs</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">makeNoise</span><span class="o">();</span>
</pre></table></code></div></div><p><strong>enhanced for loop</strong></p><p>如果在for循环中对Index不感兴趣，可以采用<code class="language-plaintext highlighter-rouge">:</code>实现循环，比如</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nc">String</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="o">{</span><span class="s">"cat"</span><span class="o">,</span> <span class="s">"dog"</span><span class="o">,</span> <span class="s">"laser horse"</span><span class="o">};</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"horse"</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">continue</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="12-junit">1.2 JUnit</h2><p>JUnit是一个单元测试包，在进行单元测试时调用</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">junit</span><span class="o">.</span><span class="na">Assert</span><span class="o">.*;</span>

<span class="nd">@Test</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestSort</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSort</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">input</span> <span class="o">=</span> <span class="o">{</span><span class="s">"i"</span><span class="o">,</span> <span class="s">"have"</span><span class="o">,</span> <span class="s">"an"</span><span class="o">,</span> <span class="s">"egg"</span><span class="o">};</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">expected</span> <span class="o">=</span> <span class="o">{</span><span class="s">"an"</span><span class="o">,</span> <span class="s">"egg"</span><span class="o">,</span> <span class="s">"have"</span><span class="o">,</span> <span class="s">"i"</span><span class="o">};</span>
        
        <span class="nc">Sort</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
        <span class="n">assertArrayEquals</span><span class="o">(</span><span class="n">expected</span><span class="o">,</span> <span class="n">input</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>注意</strong>：所有的test方法都必须是non-static</p><h1 id="2-list">2 List</h1><h2 id="21-sllist-singly-linked-list">2.1 SLList (Singly Linked List)</h2><p>Java中实现List的方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntNode</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">item</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">IntList</span> <span class="n">next</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">IntNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="nc">IntNode</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SLList</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">IntNode</span> <span class="n">first</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">SLList</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IntNode</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="cm">/** Adds an item to the front of the list */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addFirst</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IntNode</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">first</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">SLList</span> <span class="no">L</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SLList</span><span class="o">(</span><span class="mi">15</span><span class="o">);</span>
        <span class="no">L</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="no">L</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
        <span class="c1">// outputs 10</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>private关键字</strong></p><p>如果将<code class="language-plaintext highlighter-rouge">SLList</code>类中的<code class="language-plaintext highlighter-rouge">first</code>修改为</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="nc">IntNode</span> <span class="n">first</span><span class="o">;</span>
</pre></table></code></div></div><p>则在<strong>另一个</strong>class中不能够直接访问这个first变量，但是可以通过<code class="language-plaintext highlighter-rouge">public void addFirst</code>等public方法去修改和访问first</p><p><strong>Nested Class</strong></p><p>可以在一个class中嵌套另一个class，比如</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SLList</span> <span class="o">{</span> 
    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">IntNode</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="n">item</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">IntNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="nc">IntNode</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">IntNode</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">SLList</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IntNode</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="cm">/** Adds an item to the front of the list */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addFirst</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IntNode</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">first</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">SLList</span> <span class="no">L</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SLList</span><span class="o">(</span><span class="mi">15</span><span class="o">);</span>
        <span class="no">L</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="no">L</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>因为IntNode class是依附于SLList class的，因此可以将其放在SLList中</p><p><strong>helper function</strong></p><p>class中可以用<code class="language-plaintext highlighter-rouge">private static</code>来修饰helper function，表明这个函数不能被外界访问，比如想要获取一个SLList的大小</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">(</span><span class="nc">IntNode</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">size</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="22-dllistdoubly-linked-list">2.2 DLList(Doubly-Linked List)</h2><p>双向链表：一个Node除了拥有指向下一个Node的指针之外，还拥有指向前一个node的指针</p><p><em>sentinel node</em>：哨兵节点，是<strong>实际上</strong>的第一个节点，但是并不包含在概念中的链表中，这是为了方便实现<code class="language-plaintext highlighter-rouge">addLast</code>方法而添加的。这个哨兵节点的item值可以为任意值，因为不会使用它。</p><p>在DLList中，可以有一种Circular Sentinel或者Double Sentinel的模式</p><p>在Double Sentinel中，在最开始和最结尾处都有一个Sentinel Node，SentFront的next指向第一个真正的节点，prev指向null，而SentBack的next指向Null，prev指向最后一个真正的节点</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210319103559042.png" alt="image-20210319103559042" /></p><p>Circular Sentinel则只需要一个sentinel node，这个sentinel node的next指向第一个真正的节点，prev指向最后一个真正的节点，如果没有节点，则prev和next都指向自己</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210319104345993.png" alt="image-20210319104345993" /></p><h2 id="23-generic-list--template">2.3 Generic List / Template</h2><p>Java提供泛型(Generic)支持，这样就可以让我们的List不仅支持int，也可以支持其他比如String等类型</p><p>在class名称后添加&lt;PLACEHOLDER&gt;，PLACEHOLDER代表类型</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SLList</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span> 
    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="no">T</span> <span class="n">item</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="no">T</span> <span class="n">i</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">SLList</span><span class="o">(</span><span class="no">T</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IntNode</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="cm">/** Adds an item to the front of the list */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">first</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">SLList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="no">L</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SLList</span><span class="o">&lt;&gt;(</span><span class="mi">15</span><span class="o">);</span>
        <span class="c1">// or SLList&lt;String&gt; L = new SLList&lt;String&gt;(15);</span>
        <span class="no">L</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="s">"thugs"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">x</span> <span class="o">=</span> <span class="no">L</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>在泛型中primitive type需要声明为reference type(Java封装类)，比如</p><ul><li><p>int -&gt; Integer</p><li><p>double -&gt;Double</p><li><p>char -&gt; Character</p><li><p>boolean -&gt; Boolean</p><li><p>long -&gt; Long</p></ul><h2 id="24-alist-array-list">2.4 AList (Array List)</h2><p>Array是一种特殊类型的对象，包含了一连串内存空间，可以通过A[i]来获取A中第i个item。而一个类的实例是需要用一个名称，比如A.item来获取数据的。</p><p>Array有一个固定的长度</p><p>三种声明array的方法：</p><ul><li><code class="language-plaintext highlighter-rouge">y = new int[3];</code><li><code class="language-plaintext highlighter-rouge">x = new int[]{1, 2, 3, 4, 5};</code><li><code class="language-plaintext highlighter-rouge">int[] w = {9, 10, 11, 12, 13};</code></ul><p><strong>2D Array</strong></p><p>2D Array的声明</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span><span class="o">[][]</span> <span class="n">pascalsTriangle</span><span class="o">;</span>
</pre></table></code></div></div><p>实例化一个包含了4个1D Array的2D Array并赋值给变量</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">pasacalsTriangle</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">4</span><span class="o">][];</span>
</pre></table></code></div></div><p>实例化一个包含了一个int的1D Array并赋值给变量</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">pascalsTriangle</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">};</span>
</pre></table></code></div></div><p>也可以直接声明一个包含了4个[包含5个int的1D Array]的2D Array并赋值给变量</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">;</span>
<span class="n">matrix</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">4</span><span class="o">][</span><span class="mi">4</span><span class="o">];</span>
</pre></table></code></div></div><p>或者声明、实例化、赋值放在一起</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span><span class="o">[][]</span> <span class="n">pascalAgain</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[][]{</span> <span class="o">{</span><span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">}};</span>
</pre></table></code></div></div><p><strong>AList</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AList</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span><span class="o">[]</span> <span class="n">items</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
    
    <span class="cm">/** creates an empty list */</span>
    <span class="kd">public</span> <span class="nf">AList</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">items</span> <span class="o">=</span> <span class="o">(</span><span class="no">T</span><span class="o">[])</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="mi">100</span><span class="o">];</span>  <span class="c1">// 注意：这里用了casting，这是因为Java中不能有泛型对象array，所以先new一个Object array然后进行类型转换</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">resize</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">T</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="o">(</span><span class="no">T</span><span class="o">[])</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="n">capacity</span><span class="o">];</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">items</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>
        <span class="n">items</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/** Inserts X into the back of the list */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addLast</span><span class="o">(</span><span class="no">T</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// resize items since its full</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">items</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">resize</span><span class="o">(</span><span class="n">size</span> <span class="o">*</span> <span class="mi">2</span><span class="o">);</span> 
        <span class="o">}</span>
        <span class="n">items</span><span class="o">[</span><span class="n">size</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">items</span><span class="o">[</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="n">getLast</span><span class="o">();</span>
        <span class="n">items</span><span class="o">[</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>  <span class="c1">// 这一步可以不写，但是为了防止loitering，即保留对不需要的对象的引用（会导致gc无法将其回收），最好将删除的item给null out</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>当item的空间大小不足时，可以用<code class="language-plaintext highlighter-rouge">resize(size * 2)</code>来扩展空间，每次扩展2倍大小的空间可以防止addLast频繁调用resize造成程序运行时间的指数级增长。</p><h1 id="3-inheritance">3 Inheritance</h1><h2 id="31-intro-and-interfaces">3.1 Intro and Interfaces</h2><p>Java中一个类中可以有多个同名方法，但是函数签名可以不同</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">longest</span><span class="o">(</span><span class="nc">SLList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">longest</span><span class="o">(</span><span class="nc">AList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span>
</pre></table></code></div></div><p>这叫做method overloading，当调用了<code class="language-plaintext highlighter-rouge">WordUtils.longest</code>时，Java会根据传入的参数的种类自动调用正确的方法</p><p>但是我们不想为每个相似的类都重写一个方法</p><p>Java中有一种特殊的抽象类叫做接口（interface），这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">List61B</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">voif</span> <span class="nf">addLast</span><span class="o">(</span><span class="no">T</span> <span class="n">x</span><span class="o">);</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">();</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">();</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">removeLast</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="no">T</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">position</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">x</span><span class="o">);</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>然后我们使用<code class="language-plaintext highlighter-rouge">implements</code>这个关键字来告诉Java编译器SLList和AList是List61B的下位</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AList</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">List61B</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addLast</span><span class="o">(</span><span class="no">T</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>这样我们就可以重新实现<code class="language-plaintext highlighter-rouge">public static String longest(List61B&lt;String&gt; list)</code>来实现这样一个上位方法。</p><h2 id="32-overriding--overloading">3.2 Overriding &amp; Overloading</h2><p>如果一个子类有一个和父类的签名完全一样的方法，那么我们说这个子类重写(override)了这个方法</p><p>如果子类的方法名和父类方法名相同或者同一个类中有相同的方法名，但是签名不同，那么我们说这个子类overload了这个方法</p><p>最好对每个被重写的方法都加上<code class="language-plaintext highlighter-rouge">@Override</code>的annotation，即使不加也能编译通过，但是加上可以在编译时检查重写时函数签名有没有写错。</p><h2 id="33-inheritance">3.3 Inheritance</h2><p><strong>interface inheritance</strong></p><p>使用implements来实现interface，就是一种Interface inheritance</p><p>子类必须实现所有interface中的方法，否则无法编译通过</p><p><strong>Implementation inheritance</strong></p><p>interface中其实还可以有函数实现，但是必须要在函数签名前面加上<code class="language-plaintext highlighter-rouge">default</code>关键字</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">List61B</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">default</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>这样即使在被继承的类（比如SLList）中没有声明<code class="language-plaintext highlighter-rouge">print</code>方法也没有问题。该特性从Java8才开始支持。</p><p>由于<code class="language-plaintext highlighter-rouge">SLList</code>中的<code class="language-plaintext highlighter-rouge">get</code>是从头或尾开始一个一个查找的，因此<code class="language-plaintext highlighter-rouge">List61B</code>中的<code class="language-plaintext highlighter-rouge">default print</code>方法效率很低，可以选择在<code class="language-plaintext highlighter-rouge">SLList</code>这个类中重写<code class="language-plaintext highlighter-rouge">print</code>方法（尽管并不是必须重写的），这样对SLList类型的instance调用print方法将调用该方法</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">sentinel</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">item</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>extends</strong></p><p>如果想从一个class而不是interface继承，使用<code class="language-plaintext highlighter-rouge">extends</code>关键字</p><p>e.g. 从SLList继承一个RotatingSLList类</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RotatingSLList</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">SLList</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="cm">/** Rotates list to the right */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rotateRight</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Item</span> <span class="n">x</span> <span class="o">=</span> <span class="n">removeLast</span><span class="o">();</span>
        <span class="n">addFirst</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">extends</code>可以让RotatingSLList继承SLList所有的实例和静态变量，继承所有的方法和嵌套的类，但是构造器不能继承，private修饰的也不能继承</p><p>当子类的重写方法需要引用父类的方法时，可以使用<code class="language-plaintext highlighter-rouge">super</code>关键字来指代父类</p><p>子类的构造器中如果没有显式地声明父类构造器，那么Java将会自动调用<code class="language-plaintext highlighter-rouge">super()</code>来调用一个父类构造器，但是调用的可能不是你想要的父类构造器，因此最好显式声明想要调用的父类构造器</p><h2 id="34-static-type-vs-dynamic-type">3.4 Static Type v.s. Dynamic Type</h2><p>Java中所有的变量都有一个静态种类（编译时种类，在变量声明时决定）和一个动态种类（运行时种类，在变量实例化和赋值时决定）</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">LivingThing</span> <span class="n">lt1</span><span class="o">;</span>
    <span class="n">lt1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Fox</span><span class="o">();</span>
    <span class="nc">Animal</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">lt1</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>变量<th>静态种类<th>动态种类<tbody><tr><td>lt1<td>LivingThing<td>Fox<tr><td>a1<td>Animal<td>Fox</table></div><p>当我们调用了一个变量的方法，这个变量的静态种类为A而动态种类为B时，如果B<strong>重写</strong>（而不是overload，必须要保证函数签名一致)了这个方法，那么会调用B类的方法，这叫做<em>动态方法选择</em></p><p>但是在编译时，会根据<strong>静态种类</strong>进行编译，比如动态种类<code class="language-plaintext highlighter-rouge">Fox</code>有一个方法<code class="language-plaintext highlighter-rouge">foxsound()</code>，静态种类<code class="language-plaintext highlighter-rouge">LivingThing</code>并没有这个方法，那么<code class="language-plaintext highlighter-rouge">lt1.foxsound()</code>将造成编译错误</p><p>再比如：如果<code class="language-plaintext highlighter-rouge">Poodle</code>是<code class="language-plaintext highlighter-rouge">Dog</code>的子类，<code class="language-plaintext highlighter-rouge">Dog</code>有一个方法<code class="language-plaintext highlighter-rouge">public static Dog maxDog(Dog d1, Dog d2) {...}</code></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nc">Poodle</span> <span class="n">frank</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Poodle</span><span class="o">(</span><span class="s">"Frank"</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="nc">Poodle</span> <span class="n">frankjr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Poodle</span><span class="o">(</span><span class="s">"Frank Jr."</span><span class="o">,</span> <span class="mi">15</span><span class="o">);</span>

<span class="nc">Dog</span> <span class="n">largerDog</span> <span class="o">=</span> <span class="n">maxDog</span><span class="o">(</span><span class="n">frank</span><span class="o">,</span> <span class="n">frankjr</span><span class="o">);</span>  <span class="c1">// compiles, bc Right Hand Side (RHS) expression is type Dog, and LHS expression is Dog, so can be assigned</span>
<span class="nc">Poodle</span> <span class="n">largerPoodle</span> <span class="o">=</span> <span class="n">maxDog</span><span class="o">(</span><span class="n">frank</span><span class="o">,</span> <span class="n">frankjr</span><span class="o">);</span>  <span class="c1">// cannot compile, bc RHS expression is static type Dog, and LHS type is Poodle, and Dog "is not" Poodle (but Poodle "is" Dog)</span>
</pre></table></code></div></div><p>但是可以使用casting强制类型转换来转换任意表达式的静态类型，比如</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">Poodle</span> <span class="n">largerPoodle</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Poodle</span><span class="o">)</span> <span class="n">maxDog</span><span class="o">(</span><span class="n">frank</span><span class="o">,</span> <span class="n">frankjr</span><span class="o">);</span>  <span class="c1">// compiles</span>
</pre></table></code></div></div><h2 id="35-higher-order-functions">3.5 Higher Order Functions</h2><p><strong>Java7及以前的高阶函数</strong></p><p>变量的memory box中不能有指向函数的指针</p><p>采用Interface Implementation的方式去解决</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="cm">/** reprensent a function that takes in an integer and returns an integer */</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IntUnaryFunction</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TenX</span> <span class="kd">implements</span> <span class="nc">IntUnaryFunction</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cm">/** Demonstrates higher orfer functions in java */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HofDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">do_twice</span><span class="o">(</span><span class="nc">IntUnaryFunction</span> <span class="n">f</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">x</span><span class="o">));</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">IntUnaryFunction</span> <span class="n">tenX</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TenX</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">do_twice</span><span class="o">(</span><span class="n">tenX</span><span class="o">,</span> <span class="mi">2</span><span class="o">))</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="36-polymorphism">3.6 Polymorphism</h2><p>多态：一个interface可以被多种子类继承，注意和多继承不一样，多继承是一个子类继承多个父类，而不是一个父类被多个子类继承。Java允许一个子类implements多个接口</p><p>比如要实现一个比较函数，使得该函数可以应用于任意class上。先定义一个interface，里面需要有一个比较方法，然后让子类去实现这个interface</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">OurComparable</span> <span class="o">{</span>
    <span class="cm">/** returns -1 if this &lt; o
     *  0 if this equals o
     *  1 if this &gt; o */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">OurComparable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">Dog</span><span class="o">(</span><span class="nc">String</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">bark</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">" says: bark"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Dog</span> <span class="n">uddaDog</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Dog</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">&lt;</span> <span class="n">udda</span><span class="o">.</span><span class="na">size</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">==</span> <span class="n">uddaDog</span><span class="o">.</span><span class="na">size</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>但是<code class="language-plaintext highlighter-rouge">OurComparable</code>的问题在于其他的class并没有实现这个接口，因此要让其他class也能进行比较，需要对他们全部进行重写，这是很麻烦的。解决方案是：让Max基于Java内建的<code class="language-plaintext highlighter-rouge">Comparable&lt;T&gt;</code>接口来实现</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="no">T</span> <span class="n">obj</span><span class="o">);</span>  
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">Dog</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// 因为使用了泛型，就不再需要使用强制类型转换</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="nc">Dog</span> <span class="n">uddaDog</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">-</span> <span class="n">uddaDog</span><span class="o">.</span><span class="na">size</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>comparator</strong></p><p>在<code class="language-plaintext highlighter-rouge">java.util.Comparator</code>中，比较器可以用来指定这个类如何实现比较，从而可以不用继承Comparable接口</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.Comparator</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="o">{</span>
    <span class="o">...;</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">NameComparator</span> <span class="kd">implements</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Dog</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Dog</span> <span class="n">a</span><span class="o">,</span> <span class="nc">Dog</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DogLauncher</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Dog</span> <span class="n">d1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">"Elyse"</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
        <span class="nc">Dog</span> <span class="n">d2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">"Benjamin"</span><span class="o">,</span> <span class="mi">15</span><span class="o">);</span>
        
        <span class="nc">Dog</span><span class="o">.</span><span class="na">NameComparator</span> <span class="n">nc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">.</span><span class="na">NameComparator</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nc</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">d1</span><span class="o">,</span> <span class="n">d3</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">d1</span><span class="o">.</span><span class="na">bark</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">d3</span><span class="o">.</span><span class="na">bark</span><span class="o">();</span>  <span class="c1">// compare alphabetically</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// Elyse says: bark</span>
</pre></table></code></div></div><p>回调函数：作为参数被传入的一个函数。在Python中，函数可以直接作为参数被传入，Java中，这个回调函数被打包在一个接口中。</p><h2 id="37-abstract-class">3.7 Abstract class</h2><p>抽象类用<code class="language-plaintext highlighter-rouge">abstract</code>修饰，抽象类的子类继承了父类的全部特性，子类用<code class="language-plaintext highlighter-rouge">extends</code>继承抽象类。抽象类本身不能被实例化，因此所有抽象类必须被继承才能使用。</p><ul><li>抽象类中默认的是普通方法，可以加上<code class="language-plaintext highlighter-rouge">abstract</code>声明抽象方法。抽象方法是指当父类的某些方法还不确定的时候在后面让子类进行重用。<li>同时抽象类中可以有普通变量，而接口中只能存在被<code class="language-plaintext highlighter-rouge">public static final</code>修饰的静态最终常量。<li>抽象类中的方法修饰符可以是<code class="language-plaintext highlighter-rouge">public</code>、<code class="language-plaintext highlighter-rouge">private</code>和<code class="language-plaintext highlighter-rouge">protected</code>，而接口中的方法一定是<code class="language-plaintext highlighter-rouge">public</code><li>Java中只能存在单继承，即所有抽象类只能单继承，但是接口可以做到多实现，即一个类可以<code class="language-plaintext highlighter-rouge">implements</code>多个接口</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">GraphicObject</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">moveTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">newX</span><span class="o">,</span> <span class="kt">int</span> <span class="n">newY</span><span class="o">)</span> <span class="o">{...}</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>所有实现某个接口的类必须实现这个接口中声明的所有方法，否则必须声明为抽象类。同时抽象类中也可以声明除了从接口中继承来的其他方法</p><h2 id="38-prebuilt-adt">3.8 Prebuilt ADT</h2><p>Java.util库中有几种prebuilt ADT，包括：</p><ul><li>List：有序集合，子类包括LinkedList、ArrayList<li>Set：无序集合，子类包括HashSet、TreeSet<li>Map：键值对集合，与Python中的字典一样，子类包括HashMap、TreeMap</ul><h1 id="4-java-syntax">4 Java Syntax</h1><h2 id="41-reference">4.1 Reference</h2><p>Java中有8个primitive types，包括int、double、float、char等，这些类型的值是直接存储在变量中的，但是object是一种引用类型，变量存储的是这个object的地址（指针）而不是它的数据。</p><p>array也是一种对象，比如</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">95</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
</pre></table></code></div></div><p>第一步是<code class="language-plaintext highlighter-rouge">int[] a</code>，这是变量声明（declaration），在栈中创建了一个变量并分配给它64位大小的空间用来存储地址。然后用<code class="language-plaintext highlighter-rouge">new</code>在堆中分配了一个int[]对象，里面存储了0、1、2、95、4等数据，这叫做对象的实例化（instantiation）。最后将这个对象的地址放到变量中，这叫做分配（assignment）</p><h2 id="42-static">4.2 Static</h2><p>1） static方法是类方法，不需要依附于对象即可使用，不能访问实例成员变量，也不能使用非静态成员方法，通过<code class="language-plaintext highlighter-rouge">&lt;classname&gt;.method</code>调用。non-static方法是实例方法，通过<code class="language-plaintext highlighter-rouge">&lt;objectname&gt;.method</code>调用。</p><p>有些类是永远不会被实例化的，因此只能使用static方法，比如</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">x</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">round</span><span class="o">(</span><span class="mf">5.6</span><span class="o">);</span>
</pre></table></code></div></div><p>2） 用<code class="language-plaintext highlighter-rouge">static</code>修饰的变量名是静态变量，也叫做类变量，这个变量是被该类中的所有实例共享的，既可以用<code class="language-plaintext highlighter-rouge">&lt;classname&gt;.varaiblename</code>访问，也可以用<code class="language-plaintext highlighter-rouge">&lt;objectname&gt;.varaiblename</code>访问</p><p><strong>this</strong>：相当于python中的<strong>self</strong></p><p>3） static代码块：只会在类加载的时候执行一次，以优化程序性能</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Date</span> <span class="n">birthDate</span><span class="o">;</span>
     
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">Date</span> <span class="n">birthDate</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">birthDate</span> <span class="o">=</span> <span class="n">birthDate</span><span class="o">;</span>
    <span class="o">}</span>
     
    <span class="kt">boolean</span> <span class="nf">isBornBoomer</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Date</span> <span class="n">startDate</span> <span class="o">=</span> <span class="nc">Date</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="s">"1946"</span><span class="o">);</span>
        <span class="nc">Date</span> <span class="n">endDate</span> <span class="o">=</span> <span class="nc">Date</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="s">"1964"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">birthDate</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">startDate</span><span class="o">)&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">birthDate</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">endDate</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>上述例子中，每次调用<code class="language-plaintext highlighter-rouge">isBornBoomer()</code>都会创建<code class="language-plaintext highlighter-rouge">startDate</code>和<code class="language-plaintext highlighter-rouge">endDate</code>，而采用static代码块后，只会创建一次</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Date</span> <span class="n">birthDate</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Date</span> <span class="n">startDate</span><span class="o">,</span><span class="n">endDate</span><span class="o">;</span>
    <span class="kd">static</span><span class="o">{</span>
        <span class="n">startDate</span> <span class="o">=</span> <span class="nc">Date</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="s">"1946"</span><span class="o">);</span>
        <span class="n">endDate</span> <span class="o">=</span> <span class="nc">Date</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="s">"1964"</span><span class="o">);</span>
    <span class="o">}</span>
     
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">Date</span> <span class="n">birthDate</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">birthDate</span> <span class="o">=</span> <span class="n">birthDate</span><span class="o">;</span>
    <span class="o">}</span>
     
    <span class="kt">boolean</span> <span class="nf">isBornBoomer</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">birthDate</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">startDate</span><span class="o">)&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">birthDate</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">endDate</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>因此static代码块中可以执行只需要进行依次的初始化操作</p><p>判断以下代码的输出结果</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="n">ublic</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="kd">extends</span> <span class="nc">Base</span> <span class="o">{</span>
 
    <span class="kd">static</span><span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"test static"</span><span class="o">);</span>
    <span class="o">}</span>
     
    <span class="kd">public</span> <span class="nf">Test</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"test constructor"</span><span class="o">);</span>
    <span class="o">}</span>
     
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">Test</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
 
<span class="kd">class</span> <span class="nc">Base</span> <span class="o">{</span>
     
    <span class="kd">static</span><span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"base static"</span><span class="o">);</span>
    <span class="o">}</span>
     
    <span class="kd">public</span> <span class="nf">Base</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"base constructor"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>base static
test static
base constructor
test constructor
</pre></table></code></div></div><p>在执行开始先寻找<code class="language-plaintext highlighter-rouge">main()</code>方法，因为这是程序的入口。在执行<code class="language-plaintext highlighter-rouge">main()</code>方法之前必须先加载<code class="language-plaintext highlighter-rouge">Test</code>类，而在加载<code class="language-plaintext highlighter-rouge">Test</code>类的时候发现该类继承自<code class="language-plaintext highlighter-rouge">Base</code>类，因此先去加载<code class="language-plaintext highlighter-rouge">Base</code>类，然后发现有static块，便执行该块，<code class="language-plaintext highlighter-rouge">Base</code>类加载完成之后继续加载<code class="language-plaintext highlighter-rouge">Test</code>类，然后发现<code class="language-plaintext highlighter-rouge">Test</code>类中也有static块，便执行static块，在加载完所需的类之后，便开始执行<code class="language-plaintext highlighter-rouge">main()</code>方法。在<code class="language-plaintext highlighter-rouge">main()</code>方法中执行<code class="language-plaintext highlighter-rouge">new Test()</code>的时候会先调用父类的构造器，然后再调用自身的构造器。因此，便出现了上面的输出结果</p><h2 id="43-autoboxing--auto-unboxing">4.3 Autoboxing &amp; Auto-unboxing</h2><p>可以在包装类和原始类之间进行隐式转化</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BasicArrayList</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="no">L</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="no">L</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>   <span class="c1">// 正常情况下应该是L.add(new Integer(5))</span>
        <span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="no">L</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>  <span class="c1">// 正常情况下应该是L.get(0).valueOf();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="44-immutability">4.4 Immutability</h2><p>加上<code class="language-plaintext highlighter-rouge">final</code>关键字使一个变量变为不可变的变量，即在实例化之后不能再进行赋值</p><p>String也是一个不可变的对象</p><p>注意：将一个reference声明为<code class="language-plaintext highlighter-rouge">final</code>并不能让这个对象不可变，比如</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">final</span> <span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
</pre></table></code></div></div><h2 id="45-generic-method">4.5 Generic Method</h2><p>当只希望让类中的方法变为generic，而不是整个类变成generic时，可以直接在方法名前面加上&lt;&gt;</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="no">K</span> <span class="nf">get</span><span class="o">(</span><span class="nc">Map61B</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">sim</span><span class="o">,</span> <span class="no">K</span> <span class="n">key</span><span class="o">);</span> 
</pre></table></code></div></div><p>在generic method中使用<code class="language-plaintext highlighter-rouge">compareTo</code>，因为编译器不知道这个generic type是否能够进行比较，因此会报错，为了解决这个问题，需要显式地声明generic type <code class="language-plaintext highlighter-rouge">extends Comparable</code>，这叫做<strong><em>type upper bound</em></strong>，表示这个generic type是Comparable的子类</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="no">K</span> <span class="nf">maxKey</span><span class="o">(</span><span class="nc">Map61B</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="n">keylist</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">keys</span><span class="o">();</span>
    <span class="no">K</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">keylist</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="no">K</span> <span class="n">k</span> <span class="o">:</span> <span class="n">keylist</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">largest</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">largest</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="46-exception">4.6 Exception</h2><p>可以显式地<code class="language-plaintext highlighter-rouge">throw</code>一个exception</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="no">V</span> <span class="nf">get</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">keyIndex</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"The key provided "</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s">" was not in ArrayMap"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Java本身也可以隐式地抛出一个异常</p><p>被抛出的异常可以被<code class="language-plaintext highlighter-rouge">catch</code>，从而避免程序崩溃</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">try</span> <span class="o">{</span>
    <span class="n">d</span><span class="o">.</span><span class="na">receivePat</span><span class="o">();</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Tried to pat: "</span> <span class="o">+</span> <span class="n">e</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>checked</strong> exceptions：</p><ul><li>编译器要求这些异常必须被catch，从而避免那些能够被避免的程序崩溃</ul><p>e.g.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Eagle</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">gulgate</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">today</span> <span class="o">==</span> <span class="s">"Thursday"</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span><span class="s">"hi"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>提示：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>ERROR: unreported exception IOException; must be caught or declared to be thrown
</pre></table></code></div></div><p>所有的<code class="language-plaintext highlighter-rouge">RuntimeException</code>的子类或者<code class="language-plaintext highlighter-rouge">Error</code>的子类都是<em>unchecked</em>，其他所有的<code class="language-plaintext highlighter-rouge">Throwable</code>都是<em>checked</em></p><p>对于<em>checked</em>异常，除了用<code class="language-plaintext highlighter-rouge">catch</code>来确保这些异常都被接住之外，也可以用<code class="language-plaintext highlighter-rouge">throws</code>关键字来修饰这个方法，从而让其他程序来处理这个异常</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">gulgate</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">throw</span> <span class="k">new</span> <span class="nc">IOException</span><span class="o">(</span><span class="s">"hi"</span><span class="o">);...</span>
<span class="o">}</span>
</pre></table></code></div></div><p>当另一个方法使用了这个可能抛出checked异常的危险方法之后，这个方法本身也变得危险，因此需要<code class="language-plaintext highlighter-rouge">catch</code>或者本身写为<code class="language-plaintext highlighter-rouge">throws</code></p><h2 id="47-iterators">4.7 Iterators</h2><p>Java中有<em>enhanced for loop</em>，类似于Python的<code class="language-plaintext highlighter-rouge">for ... in</code></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">friends</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
<span class="n">friends</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
<span class="n">friends</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">23</span><span class="o">);</span>
<span class="n">friends</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">42</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">friends</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Iterator使用方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">seer</span> <span class="o">=</span> <span class="n">friends</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
<span class="k">while</span> <span class="o">(</span><span class="n">seer</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">seer</span><span class="o">.</span><span class="na">next</span><span class="o">());</span>
<span class="o">}</span>
</pre></table></code></div></div><p>如果要正常使用上述iterator，必须要保证<code class="language-plaintext highlighter-rouge">List&lt;T&gt;</code>有<code class="language-plaintext highlighter-rouge">iterator()</code>方法可以让<code class="language-plaintext highlighter-rouge">List</code>继承<code class="language-plaintext highlighter-rouge">iterable</code>接口，从而继承<code class="language-plaintext highlighter-rouge">iterator()</code>这个抽象方法</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">java.util</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">();</span>
    <span class="no">T</span> <span class="nf">next</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>e.g.</p><p>比如想让我们自定义的ArrayMap能够使用enhanced for loop，需要提供一个KeyIterator class(nested in ArrayMap class)从而实现<code class="language-plaintext highlighter-rouge">hasNext()</code>、<code class="language-plaintext highlighter-rouge">next()</code>等方法</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KeyIterator</span> <span class="kd">implements</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">ptr</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">KeyIterator</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
       <span class="k">return</span> <span class="o">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="n">size</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">K</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
        <span class="no">K</span> <span class="n">returnItem</span> <span class="o">=</span> <span class="n">keys</span><span class="o">[</span><span class="n">ptr</span><span class="o">];</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">returnItem</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>如果要实例化一个<code class="language-plaintext highlighter-rouge">KeyIterator</code>对象(nested class)，需要<em>dot notation</em>后面再接一个<code class="language-plaintext highlighter-rouge">new</code></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nc">ArrayMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">am</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;();</span>
<span class="n">am</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"hello"</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="n">am</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"syrups"</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
<span class="nc">ArrayMap</span><span class="o">.</span><span class="na">KeyIterator</span> <span class="n">ami</span> <span class="o">=</span> <span class="n">am</span><span class="o">.</span><span class="na">new</span> <span class="nf">KeyIterator</span><span class="o">();</span>
<span class="k">while</span> <span class="o">(</span><span class="n">ami</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ami</span><span class="o">.</span><span class="na">next</span><span class="o">());</span>
<span class="o">}</span>
</pre></table></code></div></div><p>但是尽管我们当前有一个自定义的<code class="language-plaintext highlighter-rouge">KeyIterator</code>类，但是我们需要一个<code class="language-plaintext highlighter-rouge">iterator()</code>方法（因为我们要继承Iterable接口）</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">KeyIterator</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>最后要让ArrayMap也继承Iterable接口</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Map61B</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;,</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="48-access-control">4.8 Access Control</h2><div class="table-wrapper"><table><thead><tr><th>Modifier<th>Class<th>Package<th>Subclass<th>World<tbody><tr><td>public<td>Y<td>Y<td>Y<td>Y<tr><td>protected<td>Y<td>Y<td>Y<td>N<tr><td> <td>Y<td>Y<td>N<td>N<tr><td>private<td>Y<td>N<td>N<td>N</table></div><p>当没有任何access modifier时，相同包的其他class(但不包括子类)可以访问，这也叫做’package private’</p><p>side note: 为什么没有modifier的时候package中的变量可以被访问而subclass中的不能被访问？</p><p>因为很多情况下人们会继承一个自己并不熟悉的class，因此如果subclass中的变量能够被访问就很危险，但是同一个Package往往是很多熟悉的人一起工作编写的，因此最好能够访问同一个package中的变量</p><p>类只能用public或package private（即没有修饰符）修饰。</p><p><strong>注意</strong>：编译器对访问权限的判断只基于静态类型</p><p>e.g.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">universe</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Blackhole</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Object</span> <span class="n">x</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">universe</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CreationUtils</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">BlackHole</span> <span class="nf">hirsute</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">HasHair</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">universe</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">HasHair</span> <span class="kd">implements</span> <span class="nc">BlackHole</span> <span class="o">{</span>
    <span class="nc">Object</span><span class="o">[]</span> <span class="n">items</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{...}</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{...}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>判断下面的代码能否编译</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">static</span> <span class="nc">CreationUtils</span><span class="o">.</span><span class="na">hirsute</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Client</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">demoAccess</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">BlackHole</span> <span class="n">b</span> <span class="o">=</span> <span class="n">hirsute</span><span class="o">();</span>  <span class="c1">// Sentence 1</span>
        <span class="n">b</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"horse"</span><span class="o">);</span>  <span class="c1">// Sentence 2</span>
        <span class="n">b</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>  <span class="c1">// Sentence 3</span>
        <span class="nc">HasHair</span> <span class="n">hb</span> <span class="o">=</span> <span class="o">(</span><span class="nc">HasHair</span><span class="o">)</span> <span class="n">b</span><span class="o">;</span>  <span class="c1">// Sentence 4</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>首先，<code class="language-plaintext highlighter-rouge">HasHair</code>这个class前面没有任何access modifier，因此是package private的，而目标代码并不处于<code class="language-plaintext highlighter-rouge">universe</code>包中，因此理论上目标代码无法访问<code class="language-plaintext highlighter-rouge">HasHair</code>这个类。但是Sentence 1中b的静态类型是<code class="language-plaintext highlighter-rouge">BlackHole</code>，而<code class="language-plaintext highlighter-rouge">BlackHole</code>这个类是public的，因此Sentence 1可以被编译（是否能被编译基于的是静态类型）。我们可以发现，尽管我们不能直接拥有一个对HasHair类型的引用，但是我们仍然可以通过一个能够引用该类并将其返回的方法获得一个动态类型为HasHair的引用。</p><p>而<code class="language-plaintext highlighter-rouge">BlackHole</code>这个接口中有<code class="language-plaintext highlighter-rouge">add()</code>方法。<strong>注意</strong>：由于Java接口中的方法默认用<code class="language-plaintext highlighter-rouge">public abstract</code>修饰，变量用<code class="language-plaintext highlighter-rouge">public static final</code>修饰，因此<code class="language-plaintext highlighter-rouge">void add()</code>这个方法看起来没有修饰符，但其实并不是package private而是public，因此Sentence 2是可以访问<code class="language-plaintext highlighter-rouge">add</code>方法的</p><p>对于Sentence 3来说，由于<code class="language-plaintext highlighter-rouge">get()</code>方法是在<code class="language-plaintext highlighter-rouge">HasHair</code>这个类中的，而这个类是package private，对<code class="language-plaintext highlighter-rouge">Client</code>是不可见的，因此这句话会导致编译错误</p><p>Sentence 4这句话中由于<code class="language-plaintext highlighter-rouge">HasHair</code>对<code class="language-plaintext highlighter-rouge">Client</code>不可见，因此编译错误</p><h1 id="5-java-miscellaneous">5 Java Miscellaneous</h1><h2 id="51-packages">5.1 Packages</h2><p><strong>package</strong>: 包用于组织类和接口的namespace，一般的命名规则是网站名的倒序，比如com.microsoft.xxx</p><p>不同包中的类的名称可以相同，如果同时调用两个不同包中的相同类名的类时应该加上包名加以区别，从而避免名字冲突。同时限定了访问权限。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">ug.joshh.animal</span><span class="o">;</span>  <span class="c1">// 创建包</span>
</pre></table></code></div></div><p>上述声明表明当前的class是在<code class="language-plaintext highlighter-rouge">ug/joshh/animal</code>这个目录下的</p><p>如果一个class没有<code class="language-plaintext highlighter-rouge">package</code>声明，那么它被放在了default package中，而default package是无法被导入的，因此绝大多数情况下都需要对class进行包声明（除非是很小的程序）</p><h2 id="52-jar">5.2 JAR</h2><p>.jar文件实际上是将一堆.class文件进行打包后的结果</p><p><strong>build systems</strong></p><p>为了避免导入很多Java库，可以用build system来构建项目</p><ul><li>Ant<li>Maven<li>Gradle</ul><h2 id="53-object-methods">5.3 Object Methods</h2><p>Object类的方法</p><ul><li><code class="language-plaintext highlighter-rouge">String toString()</code>：将一个Object转换为String的形式<li><code class="language-plaintext highlighter-rouge">boolean equals(Object obj)</code>：判断两个Object的值是否相同，而==判断两个Object是否是同一个Object。注意：默认的<code class="language-plaintext highlighter-rouge">equals</code>实现是<code class="language-plaintext highlighter-rouge">==</code>，因此需要自己重写一个<code class="language-plaintext highlighter-rouge">equals</code><li><code class="language-plaintext highlighter-rouge">Class&lt;?&gt; getClass</code><li><code class="language-plaintext highlighter-rouge">int hashCode()</code></ul><h1 id="6-tree">6 Tree</h1><h2 id="61-asymoptotic">6.1 Asymoptotic</h2><p>算法复杂度分析</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printParty</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>$1 + 2 + 4 + … + N \in \Theta(N)$</p><p>因为上述式子是大于N小于2N的</p><p>Merge sort复杂度Θ(NlogN)</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210401215356250.png" alt="image-20210401215356250" /></p><p>将两个sorted list合并为一个sorted list所需要的复杂度为Θ(N)，因此可以进行$log_2N$次merge实现merge sort</p><ul><li><p>big Θ notation: 复杂度等于</p><li>big O notation: 复杂度小于等于<li>big Ω notation: 复杂度大于等于</ul><h2 id="62-disjoint-sets">6.2 Disjoint Sets</h2><p>Disjoint Sets ADT: 并查集用来判断两个元素是否相连</p><ul><li>connect(p, q): 将p和q相连<li>isConnected(p, q): 判断p和q是否相连</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210402091518263.png" alt="image-20210402091518263" /></p><p>可以采用树状结构来存储数据，即数据结构中有一个parent数组，数组的index是element（p/q)，而数组的值是这个element的父节点，判断p和q是否connected只要判断这两个数的最终父节点是否相同即可</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">QuickUnionDS</span> <span class="kd">implements</span> <span class="nc">DisjointSets</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
	<span class="kd">public</span> <span class="nf">QuickUnionDS</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
    	    <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
    	    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        	    <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
   	    <span class="o">}</span>
 
  	<span class="kd">private</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    	    <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">parent</span><span class="o">[</span><span class="n">p</span><span class="o">])</span>
        	    <span class="n">p</span> <span class="o">=</span> <span class="n">parent</span><span class="o">[</span><span class="n">p</span><span class="o">];</span>
       	<span class="k">return</span> <span class="n">p</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isConnected</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="nf">find</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">==</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
<span class="o">}</span>
 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">connect</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
        <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>但是在最坏情况下，<code class="language-plaintext highlighter-rouge">find</code>的复杂度为O(N)（当树的branch只有一条时）</p><p><strong>weighted quick union</strong></p><p>记录每个tree的size（即一个tree中的元素个数，而不是树的高度），每次合并将更小size的树的根节点连接到更大size的树的根节点，这样就能避免最坏情况的形成只有一个branch的情况(实际上最高的树的高度为logN)</p><p>e.g.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210402101659230.png" alt="image-20210402101659230" /></p><p>这两棵树合并时，因为前一棵树有6个元素，后一棵树只有4个元素，因此将6的父节点变为0</p><p>![image-20210402101750488]/assets/img/posts/CS61B/image-20210402101750488.png)</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">connect</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">size</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span> <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span> <span class="n">size</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">size</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="o">}</span>
	<span class="k">else</span> <span class="o">{</span> <span class="n">parent</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">size</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">size</span><span class="o">[</span><span class="n">j</span><span class="o">];</span> <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>weighted quick union的<code class="language-plaintext highlighter-rouge">connect</code>和<code class="language-plaintext highlighter-rouge">isconnected</code>复杂度都为O(logN)</p><h2 id="63-binary-search-tree-bst">6.3 Binary Search Tree (BST)</h2><p>对于一个linked list，<code class="language-plaintext highlighter-rouge">get()</code>操作的最差复杂度为Θ(N)</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210402145418380.png" alt="image-20210402145418380" /></p><p>但是可以将pointer放到中间，这样就可以将搜索时间减半，然后再将剩下一层的pointer也放到中间，再将搜索时间减半</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210402145537267.png" alt="image-20210402145537267" /></p><p>这就形成了一个二叉查找树（BST），BST中每个节点的左边的子树中的所有元素都要小于节点本身，每个节点的右边的子树中的所有元素都要大于节点本身</p><p>BST中不允许有重复的节点</p><p><strong>BST中的节点删除</strong></p><p>当删除的节点只有没有子节点时，直接删除，当删除的节点有一个子节点时，让这个被删除的节点的父节点指向被删除节点的子节点。当删除的节点有两个子节点时，选取这个被删除节点左侧树中最大的节点或者右侧树中最小的节点继承被删除的节点，比如上述BST中删除D，则可以将C替代D或者E替代D</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="cm">/** Removes KEY from the tree if present
     *  returns VALUE removed,
     *  null on failed removal.
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">remove</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">V</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ret</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">remove</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
        <span class="n">size</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">remove</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">n</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">remove</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">n</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">n</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">remove</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">n</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nc">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">max</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="n">n</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">deleteMax</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="n">n</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">max</span><span class="o">(</span><span class="nc">Node</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">max</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">deleteMax</span><span class="o">(</span><span class="nc">Node</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">n</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">deleteMax</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
</pre></table></code></div></div><h2 id="64-balanced-bst">6.4 Balanced BST</h2><p>如果使用传统的BST，当Insertion是按照从小到大进行的话，就会使一个树变成一个链表</p><p><strong>Tree Rotation</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210402160126414.png" alt="image-20210402160126414" /></p><p><code class="language-plaintext highlighter-rouge">RotateLeft(G)</code>: 将G变为P的左节点，P原先的左节点变为G的右节点，假如G有父节点，则P指向G的父节点</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210402160241553.png" alt="image-20210402160241553" /></p><p><strong>B-Tree / 2-3 Tree</strong></p><p>一个节点中可以有超过1个的key，比如2-3树可以一个节点有2个key，而一个节点可以有超过2个的子节点，比如2-3树中可以有3个子节点</p><p>在进行节点插入时，先根据Key的值插入到相应的叶节点上。比如向下面的2-3-4树中插入y和z，因为y和z大于m，大于oqs，因此插入到t和u这个节点上。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210402165454930.png" alt="image-20210402165454930" /></p><p>但是2-3-4树一个节点最多3个key，因此将tuyz这个节点的中间那个key也就是u移到父节点，而t小于u，因此需要将t分出来变为一个新的节点</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210402165812465.png" alt="image-20210402165812465" /></p><p>oqsu中的q移到父节点形成mq节点，而o小于q因此独立出来称为一个新的节点</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210402165911089.png" alt="image-20210402165911089" /></p><p>最终形成一个平衡树 <strong>B树是自平衡的</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210402170153113.png" alt="image-20210402170153113" /></p><p><strong>红黑树</strong></p><p>红黑树是2-3B树的变体，为了能像2-3B树一样达到自平衡的效果而又保证每个节点只有一个Key，需要用到”glue link”，glue link两边的节点结合起来就成为了2-3B树中一个拥有2个key的节点</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210402173202820.png" alt="image-20210402173202820" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210402173233300.png" alt="image-20210402173233300" /></p><p>所有的红黑树都有以下性质：</p><ul><li>没有一个节点有2个红色link，否则就称为2-3-4B树<li>从根节点到所有的叶节点都拥有同样数量的黑色link（假设红色link不算，那么所有黑色link形成了跟2-3-4B树相同的结构，这是一个严格平衡的树）<li>红黑树的最大深度小于等于其对应的2-3B树的2倍，因为每个2-3B树的节点最多只有2个key</ul><h2 id="65-advanced-trees">6.5 Advanced Trees</h2><p><strong>tree traversal</strong></p><ul><li><p>breadth-first-traversal：先将一个层级的node全部遍历一遍</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">levelOrder</span><span class="o">(</span><span class="nc">Tree</span> <span class="no">T</span><span class="o">,</span> <span class="nc">Action</span> <span class="n">toDo</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">T</span><span class="o">.</span><span class="na">height</span><span class="o">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">visitLevel</span><span class="o">(</span><span class="no">T</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">toDo</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
  
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">visitLevel</span><span class="o">(</span><span class="nc">Tree</span> <span class="no">T</span><span class="o">,</span> <span class="kt">int</span> <span class="n">level</span><span class="o">,</span> <span class="nc">Action</span> <span class="n">toDo</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="no">T</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span><span class="o">;</span> <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">lev</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">toDo</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="no">T</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="n">visitLevel</span><span class="o">(</span><span class="no">T</span><span class="o">.</span><span class="na">left</span><span class="o">(),</span> <span class="n">lev</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">toDo</span><span class="o">);</span>
        <span class="n">visitLevel</span><span class="o">(</span><span class="no">T</span><span class="o">.</span><span class="na">right</span><span class="o">(),</span> <span class="n">lev</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">toDo</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403170101691.png" alt="image-20210403170101691" /></p><ul><li><p>在”bushy tree”的情况下采用level-order进行遍历的复杂度为Θ(N)，其中N为树的总节点数</p><p>因为先考虑最上面一层，<code class="language-plaintext highlighter-rouge">visitLevel</code>1次</p><p>考虑第二层，<code class="language-plaintext highlighter-rouge">visitLevel</code>1+2=3次</p><p>考虑第三层，<code class="language-plaintext highlighter-rouge">visitLevel</code>1+2+4=7次</p><p>因此考虑第logN层，<code class="language-plaintext highlighter-rouge">visitLevel</code>\(2^{1} + 2^{2} + 2^{3} + ... + 2^{log_2N} - log_2N=\Theta(N)\)</p><li><p>在”Spindly tree”的情况下采用level-order进行遍历的复杂度为Θ($N^2$)，因为</p><p>考虑第一层 <code class="language-plaintext highlighter-rouge">visitLevel</code>1次</p><p>考虑第二层<code class="language-plaintext highlighter-rouge">visitLevel</code>1+1=2次</p><p>考虑第三层<code class="language-plaintext highlighter-rouge">visitLevel</code>1+1+1=3次</p><p>考虑第N层<code class="language-plaintext highlighter-rouge">visitLevel</code>\(1+2+3+...+N=O(N^2)\)</p></ul><li><p>depth first traversal：先遍历到叶节点</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">preOrder</span><span class="o">(</span><span class="nc">BSTNode</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
    <span class="n">print</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
    <span class="n">preOrder</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="n">preOrder</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>采用depth first traversal遍历的复杂度为Θ(N)</p></ul><p><strong>QuadTree</strong></p><p>两个对象的比较可以不单单是一维的，也可以是二维的，比如a=(1.5,1.6)和b=(1.0,2.8)这两个坐标，从x轴看a&gt;b，但是从y轴看a&lt;b，因此根据不同的参照系可以形成两个tree</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403171646790.png" alt="image-20210403171646790" /></p><p>当将这两个tree合并为一个tree是，一个节点实际上根据方向坐标拥有NW、NE、SE、SW四个方向的子节点</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403172018362.png" alt="image-20210403172018362" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403172033420.png" alt="image-20210403172033420" /></p><h1 id="7-hashing--heap">7 Hashing &amp; Heap</h1><h2 id="71-hashtable">7.1 HashTable</h2><p>Java要求每个Object提供一个<code class="language-plaintext highlighter-rouge">hashCode()</code>方法，来将任意的数据转换为index，再通过index查找哈希表实现常数级访问</p><p>由于哈希表的大小是有限制的，当需要存储的item的数量大于这个哈希表时，必然会造成多个item存储在一个哈希表的bucket中，我们可以用链表的形式将每个需要存储的对象存储在对应的哈希表位置</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403093253665.png" alt="image-20210403093253665" /></p><p>load Factor: 假设M个bucket中需要存储N个item，那么load factor (L) = N / M, 平均的哈希表运算（insert、find）复杂度为Θ(L)</p><p><strong>哈希运算的步骤：</strong></p><ol><li>计算hashCode: $-2^{31}$到$2^{31}-1$之间<li>计算index = hashCode floormod M，其中floormod可以进行负数的mod，比如-1 floormod 4 = 3。M为哈希表的bucket数量<li>如果L = N / M太大，增加M</ol><p><strong>计算hashCode的方法：</strong></p><p>对于String来说，可以用</p>\[h(s) = s_0 * 32^{n-1} + s_1 * 32^{n-2} + ... + s_{n-1}\]<p>其中$s_n$表示第n个character转化为int的值，比如第n个char为a，则$s_n$为1</p><p>但是这种办法会造成一个问题就是当String很大时高位的char都被忽略，因为hashcode是在不断向左移5位的，解决方案是可以将底数从32变成31，这样就会造成位的”混乱“，而这种混乱可以避免上述情况</p><p>Java中String对<code class="language-plaintext highlighter-rouge">hashCode()</code>方法的实现</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">hash</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">val</span><span class="o">[]</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">value</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">h</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">h</span> <span class="o">+</span> <span class="n">val</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">hash</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>对于递归的数据结构，hashcode也要用递归的方式计算。BST对<code class="language-plaintext highlighter-rouge">hashCode()</code>方法的实现</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">+</span> <span class="mi">31</span> <span class="o">*</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">+</span> <span class="mi">31</span> <span class="o">*</span> <span class="mi">31</span> <span class="o">*</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">hashCode</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>default <code class="language-plaintext highlighter-rouge">hashCode</code>的实现：<code class="language-plaintext highlighter-rouge">return this</code>，也就是返回对象的地址，这会造成相同值的对象可能有不同的hashCode，这是我们不想看到的。重写<code class="language-plaintext highlighter-rouge">equals</code>方法也需要重写<code class="language-plaintext highlighter-rouge">hashCode</code>方法以保证<code class="language-plaintext highlighter-rouge">equals</code>的两个该类对象拥有相同的<code class="language-plaintext highlighter-rouge">hashCode</code></p><p><strong>HashMap</strong></p><p>HashMap实现了Map接口，使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。</p><p>当用put()传递键和值时，先对键调用<code class="language-plaintext highlighter-rouge">hashCode()</code>方法，根据计算得到的hashCode来计算应该将这个entry放在哈希表的哪一个bucket中，如果这个Bucket中存在一个键<code class="language-plaintext highlighter-rouge">.equals()</code>和需要Put的键相等，那么覆盖原先键的value，否则在链表头部插入这个键值对。当负载因子L超出一定的阈值后，将哈希表的索引扩展两倍并进行rehash</p><h2 id="72-priority-queue--heap">7.2 Priority Queue &amp; heap</h2><p>Priority Queue是一种支持下列API的ADT</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cm">/** (Min) Priority Queue: Allowing tracking and removal of the
  * smallest item in a priority queue. */</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MinPQ</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="o">{</span>
	<span class="cm">/** Adds the item to the priority queue. */</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Item</span> <span class="n">x</span><span class="o">);</span>
	<span class="cm">/** Returns the smallest item in the priority queue. */</span>
	<span class="kd">public</span> <span class="nc">Item</span> <span class="nf">getSmallest</span><span class="o">();</span>
	<span class="cm">/** Removes the smallest item from the priority queue. */</span>
	<span class="kd">public</span> <span class="nc">Item</span> <span class="nf">removeSmallest</span><span class="o">();</span>
	<span class="cm">/** Returns the size of the priority queue. */</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>实现PQ的数据结构：</p><p>Binary min-heap，需要有以下性质：</p><ul><li>Min-heap指的是每一个node都小于等于其所有的子节点<li>complete：如果存在缺失的节点，那么缺失的节点只能位于最底一层，所有的节点都要越靠左越好</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403120917398.png" alt="image-20210403120917398" /></p><p>PQ中的<code class="language-plaintext highlighter-rouge">getSmallest()</code>只需要返回heap的root节点即可，复杂度为Θ(1)</p><p><code class="language-plaintext highlighter-rouge">insert(N)</code>算法：从最底层的最左边的缺失节点开始插入，当插入的节点小于父节点时，调换两者位置，将此步骤进行递归调用，直到满足min-heap条件。</p><p>e.g. 向下列heap中插入3</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403122053169.png" alt="image-20210403122053169" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403122341272.png" alt="image-20210403122341272" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403122351694.png" alt="image-20210403122351694" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403122402371.png" alt="image-20210403122402371" /></p><p><code class="language-plaintext highlighter-rouge">remove()</code>算法：将最后一个节点放到被删除的节点的位子，然后判断其与子节点的大小，如果大于子节点就下放，比如删除下列heap的节点1，将最后一个节点6放到root的位置，最后连续交换节点6的位子</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403142818341.png" alt="image-20210403142818341" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403142956802.png" alt="image-20210403142956802" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403143009384.png" alt="image-20210403143009384" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403143101863.png" alt="image-20210403143101863" /></p><p><strong>heap implementation</strong></p><p>将整个Heap树的所有key按照顺序存放在一个array中，注意要将array[0]的位子空出来，方便<code class="language-plaintext highlighter-rouge">parent()</code>和<code class="language-plaintext highlighter-rouge">child()</code>的计算</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403145857581.png" alt="image-20210403145857581" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403145926477.png" alt="image-20210403145926477" /></p><p>这样可以非常方便地得到计算child和parent的公式</p><ul><li>leftChild(k) = k * 2<li>rightChild(k) = k * 2 + 1<li>parent(k) = k / 2</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre><td class="rouge-code"><pre><span class="cm">/** 最大堆的Java实现，最小堆和最大堆原理一样 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaxPQ</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>  <span class="c1">// 堆的最大容量</span>
    <span class="kt">int</span> <span class="n">heapSize</span><span class="o">;</span>  <span class="c1">// 堆的大小</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">MaxPQ</span><span class="o">(</span><span class="kt">int</span> <span class="n">_capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">capacity</span> <span class="o">=</span> <span class="n">_capacity</span><span class="o">;</span>
        <span class="n">heapSize</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">capacity</span><span class="o">];</span>
    <span class="o">}</span>
    
    <span class="c1">// 直接传入一个数组进行原地heapify</span>
    <span class="kd">public</span> <span class="nf">MaxPQ</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">_nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">capacity</span> <span class="o">=</span> <span class="n">_nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">heapSize</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="n">_nums</span><span class="o">;</span>
        <span class="n">buildMaxHeap</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// 插入操作</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">heapSize</span> <span class="o">==</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">heapSize</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">heapSize</span><span class="o">++]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">buildMaxHeap</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// 删除操作</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">poll</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="c1">// 第一个和最后一个元素进行交换，并减小heapSize</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">--</span><span class="n">heapSize</span><span class="o">);</span>
        <span class="n">maxHeapify</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// 构建堆</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">buildMaxHeap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="c1">// 从底层到高层进行heapify</span>
            <span class="n">maxHeapify</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="c1">// 对一个树进行heapify</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">maxHeapify</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 左右节点的Index</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">root</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">root</span> <span class="o">+</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="c1">// 寻找root、left、right中最大的那个节点，将这个节点和root互换</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">heapSize</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">max</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">heapSize</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">max</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">max</span> <span class="o">!=</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">max</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
            <span class="n">maxHeapify</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="c1">// 交换帮助函数</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403150630053.png" alt="image-20210403150630053" /></p><h2 id="73-data-structure-summary">7.3 Data Structure Summary</h2><p>各种ADT及其实现的数据结构总结</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210403151901497.png" alt="image-20210403151901497" /></p><h1 id="8-graphs">8 Graphs</h1><h2 id="81-intro-to-graphs">8.1 Intro to graphs</h2><p>Graph是一系列被edges连接的vertices/nodes</p><p>根据链接是否有方向，Graph可以分为directed / undirected</p><p>如果directed graph中的一个Node可以沿着一个路径回到自己，则这个graph又是cyclic的，否则就是acyclic。如果一个undirected graph存在多条从一个点到另一个点的路径，则这个graph是cyclic的</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210405193924092.png" alt="image-20210405193924092" /></p><p>Java中的Graph类的API</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Graph</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Graph</span><span class="o">(</span><span class="kt">int</span> <span class="no">V</span><span class="o">);</span>  <span class="c1">// create empty graph with v vertices</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addEdge</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">);</span>   <span class="c1">// add an edge v-w</span>
    <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">adj</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">);</span>  <span class="c1">// vertices adjacent to v</span>
    <span class="kt">int</span> <span class="nf">V</span><span class="o">();</span>  <span class="c1">// number of vertices</span>
    <span class="kt">int</span> <span class="nf">E</span><span class="o">();</span>  <span class="c1">// number of edges</span>
    
    <span class="c1">// degree is the # of adjacent vertices connected to some vertex</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">degree</span><span class="o">(</span><span class="nc">Graph</span> <span class="no">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">degree</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">degree</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">degree</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="82-graph-traversal">8.2 Graph Traversal</h2><p><strong>Depth first traversal</strong></p><p>判断某个节点s到另一个节点t之间是否有一个path：</p><ol><li>标记s<li>如果s==t 返回true<li>判断所有s的没有被标记的邻近节点是否和t相连，一旦有一个相连就返回true</ol><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DepthFirstPaths</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">s</span><span class="o">;</span>
 	
    <span class="kd">public</span> <span class="nf">DepthFirstPaths</span><span class="o">(</span><span class="nc">Graph</span> <span class="no">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="n">dfs</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
 	
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">Graph</span> <span class="no">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
            <span class="n">dfs</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
        <span class="o">}</span>        	
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>DFS的时间复杂度为Θ(V+E)，因为查找所有顶点相邻的点所需时间为Θ(E)，而访问所有顶点相邻的点所需时间为Θ(V)</p><p><strong>Breadth first traversal</strong></p><p>按照从s出发的距离排序</p><p>上面的图顺序为012453687</p><p>算法：</p><ol><li>初始化一个queue，从一个节点s开始，将其加入到queue中，初始化vertex指针v=s，重复2和3直到queue为空<li>将v从queue中删除<li>对于所有没有被访问过的v的邻近节点，将其加入到queue中，设置v为queue中的第一个元素</ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210404213726880.png" alt="" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210404213739400.png" alt="" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BreadthFirstPaths</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>
  <span class="o">...</span>
	
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">bfs</span><span class="o">(</span><span class="nc">Graph</span> <span class="no">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">fringe</span> <span class="o">=</span> 
          <span class="k">new</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
  <span class="n">fringe</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
  <span class="n">marked</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="k">while</span> <span class="o">(!</span><span class="n">fringe</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">fringe</span><span class="o">.</span><span class="na">dequeue</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
        <span class="n">fringe</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
        <span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>DFS和BFS的区别：BFS用queue(FIFO)来存储fringe，DFS用stack(FILO)来存储/或者使用递归</p><p><strong>Topological sort</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210405193459629.png" alt="image-20210405193459629" /></p><p>对于有向无环图DAG(Directed Acyclic Graph)，输出一个序列使得当s指向t时，t不能出现在s前面，比如0, 2, 1, 3, 5, 4, 7, 6</p><p>算法：从入度(degree)为0的所有节点开始，调用postorder DFS，将输出存在list中然后进行reverse</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210405193354216.png" alt="image-20210405193354216" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210405193426783.png" alt="image-20210405193426783" /></p><p>最后结果为[2, 5, 6, 0, 3, 1, 4, 7]</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DepthFirstOrder</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">reversePostorder</span><span class="o">;</span>
	<span class="kd">public</span> <span class="nf">DepthFirstOrder</span><span class="o">(</span><span class="nc">Digraph</span> <span class="no">G</span><span class="o">)</span> <span class="o">{</span>
   	 <span class="n">reversePostorder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
   	 <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
   	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="no">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span> <span class="o">{</span>
       	<span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="o">{</span> <span class="n">dfs</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span> <span class="o">}</span>
	<span class="o">}</span>
	<span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">Digraph</span> <span class="no">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
   	    <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
   	    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
           	<span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span> <span class="n">dfs</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span> <span class="o">}</span> 
         <span class="o">}</span>
         <span class="n">reversePostorder</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
 	<span class="o">}</span>
	<span class="kd">public</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">reversePostorder</span><span class="o">()</span>
	<span class="o">{</span> <span class="k">return</span> <span class="n">reversePostorder</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="83-shortest-paths">8.3 Shortest Paths</h2><p>对于unweighted edge graph来说，breadth first search可以找到从一点到另外一点的最短路径（因为是按照level排序的）。但是对于weighted edge来说，level并不能完全反映远近，因此需要用Dijkstra算法来计算最短路径</p><p><strong>Shorteset Path Tree</strong></p><p>从一个点到图上所有其他点的最短路径可以组成一个树 ，因为到任意一个其他点都一定只有一个父节点</p><p><strong>Dijkstra Algorithm</strong></p><p>假设source节点为s，节点指针为v，先将s加入minPQ中，保存每个节点到s的距离(<code class="language-plaintext highlighter-rouge">toSourceDistance</code>)为$\inf$，s到s的距离为0，重复以下动作：</p><ol><li>从minPQ中弹出目前到s距离最短的节点作为v<li>对于v的所有未访问的邻近节点<code class="language-plaintext highlighter-rouge">Node n : v</code>，计算<code class="language-plaintext highlighter-rouge">n.toSourceDistance=min(n.toSourceDistance, v.toSourceDistance+edge(n, v))</code>，其中<code class="language-plaintext highlighter-rouge">edge(n, v)</code>为n和v之间edge的weight，如果<code class="language-plaintext highlighter-rouge">v.toSourceDistance+edge(n, v) &lt; n.toSourceDistance</code>，则将<code class="language-plaintext highlighter-rouge">edgeTo(n)</code>设置为v<li>将v设置为已访问，将n加入minPQ中</ol><p>最后从终点根据edgeTo回溯到起点即可</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210406102417364.png" alt="image-20210406102417364" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210406102438502.png" alt="image-20210406102438502" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210406102457229.png" alt="image-20210406102457229" /></p><p><strong>A*算法</strong></p><p>A*算法适用于已知目的地的情况而不是对所有点查找最短路径</p><p>与Dijkstra的best first不同，Dijkstra在将v从minPQ中pop出来的依据只有该点到source的距离，但是A*考虑了该点到source的距离+该点到目标点的<em>估计距离</em>，以此为依据判断pop的先后顺序</p><p>这个估计距离<em>不能</em>大于实际距离</p><p><strong>但是注意</strong>：在更新<code class="language-plaintext highlighter-rouge">distTo</code>数列时，依然按照该点到source的距离为依据进行更新，且当访问到目标点时不能够立即停止访问，需要还保证所有目标点的相邻点都已经被访问才能够确定最短路径。这是因为在考虑估计距离的情况下，已经pop出来的节点并不一定位于最短距离的路径中，需要比较所有能够访问到目标点t的最短路径才可以。</p><p>可以参考Project 3: BearMap中用A*算法实现的Router</p><p><a href="https://github.com/tommyfan34/cs61b/blob/main/proj3/src/main/java/Router.java">https://github.com/tommyfan34/cs61b/blob/main/proj3/src/main/java/Router.java</a></p><h2 id="84-spanning-tree">8.4 Spanning Tree</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210406110202502.png" alt="image-20210406110202502" /></p><p>生成树T满足以下条件：</p><ul><li><p>是G的子图</p><li>是connected<li>是acyclic<li>包含G的所有节点</ul><p>Minimum Spanning Tree (MST): 在所有可能的生成树中拥有最小的edge weight sum</p><p><strong>cut property</strong></p><p>将一个图中所有的节点任意分为2部分，比如下图中的灰色节点和白色节点</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210406113356011.png" alt="image-20210406113356011" /></p><p>crossing edge是所有连接两种set节点的edge，上图中的红色edge</p><p>在所有crossing edge中，weight最小的那个edge一定在MST中</p><p><strong>Prim’s Algorithm</strong></p><p>这是用来计算MST的算法，基于cut property</p><p>先从任意一个node开始，这个node和剩下的node形成了2个set，将这两个set之间的cut edge中weight最小的那个加入到MST中，并且被连接的那个Node加入到MST的node set中，然后继续寻找weight最小的cut edge</p><p>和Dijkstra算法很像，但是区别在于Dijkstra中每个minPQ中节点对应的priority是到source的距离，而Prim中每个minPQ中节点对应的priority是和MST节点set之间的cut edge的最小距离（如果不和MST set相连，则priority为$\inf$。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210406125946291.png" alt="image-20210406125946291" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210406130005736.png" alt="image-20210406130005736" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210406130019352.png" alt="image-20210406130019352" /></p><p><strong>Kruskal Algorithm</strong></p><p>将所有edge加入到MinPQ中，从minPQ中依次pop一个edge e，判断如果将e加入到当前的MST中是否会出现cycle，如果不会出现cycle，就将其加入到MST中，重复上述步骤直到加入了V-1个edge为止</p><h1 id="9-sorting-algorithm">9 Sorting Algorithm</h1><h2 id="91-basic-sorting-algorithms">9.1 Basic Sorting Algorithms</h2><p><strong>Selection Sort</strong></p><ol><li>在array中unsorted部分中找到最小的Item<li>将这个Item放到sorted部分的最后<li>继续对接下来unsorted的部分进行selection sort</ol><p>复杂度$\Theta(N^2)$</p><p><strong>Heap sort</strong></p><p>与selection sort基本一样，但是将array放到了priority queue中</p><p>复杂度$\Theta(NlogN)$</p><p>可以将整个输入array作为一个heap，实现in-place heap sort从而不需要另外一个heap，以节约空间</p><ol><li>heapfication</ol><p>从后往前，进行sink(k)，即判断child(k)是否大于自己，是则进行交换</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210409102547205.png" alt="image-20210409102547205" /></p><ol><li>将heap中最大的item删除，放到array中最后一个中去（和最后一个交换，然后最后一个不断进行sink)，重复N次</ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210409102831469.png" alt="image-20210409102831469" /></p><p><strong>merge sort</strong></p><p>将一个array分成2个，分别对他们进行sort，然后进行merge，merge的方法是不断判断两个sorted array的front pointer指向的数，将较小的那个放到新的array中，并移动相应的那个sorted array的front pointer</p><p>可以将array继续分为2个，直到不能再分，此时merge sort的时间复杂度为$\Theta(NlogN)$</p><p><strong>Insertion sort</strong></p><p>从array的第一个开始将其抽出，插入到新array的正确位置使得新array按顺序排列</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210409105123025.png" alt="image-20210409105123025" /></p><p>insertion sort的复杂度$O(N^2)$</p><p>但是对于一个几乎已经全部sorted array，insertion sort的复杂度为$\Theta(N)$</p><h2 id="92-quick-sort">9.2 Quick Sort</h2><p><strong>Partition</strong></p><p>将一个array以a[j]为界分为2部分，左边的所有元素都小于a[j]，右边的所有元素都大于a[j]</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210409115333404.png" alt="image-20210409115333404" /></p><p>进行Partition的方法：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210409115525425.png" alt="image-20210409115525425" /></p><p>对于input，先扫描一遍蓝色块（大于白色块的），放到新array的最后面，再扫描白色块（array中的第一个），放到新array的蓝色块的前面，最后扫描红色块，放到新array的最前面</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210409115846121.png" alt="image-20210409115846121" /></p><p>partition时间复杂度为\(\Theta(N)\)</p><p>可以观察到，经过partition之后array的第一个元素已经被放在了正确的位置，只需要对partition之后的这个元素的左边和右边的sub array继续进行partition即可</p><p>quick sort的最好情况（每个pivot都在array的中间）时间复杂度为\(\Theta(N logN)\)</p><p>quick sort的最差情况（每个pivot都放到array的两端）时间复杂度为\(\Theta(N^2)\)</p><p>quick sort的平均情况时间复杂度为\(\Theta(NlogN)\)​</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="c1">// 快速排序</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">quicksort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">quicksort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 递归结束条件</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 返回的中枢点的位置</span>
        <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
        <span class="c1">// 对中枢点左边进行排序</span>
        <span class="n">quicksort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">pivot</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="c1">// 对中枢点右边进行排序</span>
        <span class="n">quicksort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
    <span class="c1">// 设定最左边的为中枢点</span>
    <span class="kt">int</span> <span class="n">pivotVal</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
    <span class="c1">// 左哨兵的位置为left，右哨兵的位置为right。左哨兵表示这个位置的左边所有的值都小于pivotVal</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 要从右边哨兵开始找，寻找第一个小于pivotVal的，因为pivot右边都应该大于等于pivotVal（注意不是大于）</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">pivotVal</span><span class="o">)</span> <span class="n">right</span><span class="o">--;</span>
        <span class="c1">// 寻找左边第一个大于pivotVal的</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">pivotVal</span><span class="o">)</span> <span class="n">left</span><span class="o">++;</span>
        <span class="c1">// 交换左右哨兵</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 左哨兵和右哨兵碰头，交换pivot与这个碰头的位置</span>
    <span class="n">nums</span><span class="o">[</span><span class="n">pivot</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
    <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">=</span> <span class="n">pivotVal</span><span class="o">;</span>
    <span class="c1">// 返回新的pivot位置</span>
    <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="93-stability--algorithmic-bounds">9.3 Stability &amp; Algorithmic Bounds</h2><p><strong>Stability</strong></p><p>排序算法的稳定性是指当一个待排序的序列中有多个相同的元素时，若经过排序这些元素的相对次序保持不变，则该算法是稳定的</p><p>insertion sort是稳定的，因为当下一个travelling item大于或等于前一个时，是不会进行交换的</p><p>quick sort不稳定</p><p><strong>Alorithmic Bounds</strong></p><p>所有排序算法的可能最优复杂度为$\Theta(NlogN)$</p><h2 id="94-radix-sort">9.4 Radix Sort</h2><p>不使用比较进行排序，即基数排序</p><p><strong>LSD Radix Sort</strong></p><p>Least Significant Digit Sort， 从最小位开始的基数排序</p><p>首先找到整个数组中最大数的位数，假设为k，然后从个位到k位重复进行排序，如下所示：</p><p>假设有一串数值为</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>73, 22, 93, 43, 55, 14, 28, 65, 39, 81 
</pre></table></code></div></div><p>首先根据个位数的数值将其分配到编号0-9的bucket中</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>0
1 81
2 22
3 73 93 43
4 14
5 55 65
6
7
8 28
9 39 
</pre></table></code></div></div><p>将这些bucket中的数值进行收集</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>81, 22, 73, 93, 43, 14, 55, 65, 28, 39 
</pre></table></code></div></div><p>再根据十位数的数值将其分配到编号0-9的bucket中</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>0
1 14
2 22 28
3 39
4 43
5 55
6 65
7 73
8 81
9 93
</pre></table></code></div></div><p>将这些bucket中的数值进行收集</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>14, 22, 28, 39, 43, 55, 65, 73, 81, 93
</pre></table></code></div></div><p>由于最高位为2，因此排序结束</p><p>复杂度为$O(kN)$，其中k为最大数的位数，N为数组个数</p><p><strong>MSD Radix Sort</strong></p><p>从最高位的基数开始进行排序，适用于位数比较高的情况</p><p>注意：和LSD不同，MSD在判断每一位的过程中需要将array拆分成多个sub array进行排序</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210410193603524.png" alt="image-20210410193603524" /></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">// radix sort</span>
<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">nums</span><span class="o">).</span><span class="na">max</span><span class="o">().</span><span class="na">getAsInt</span><span class="o">();</span>
<span class="kt">long</span> <span class="n">exp</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">len</span><span class="o">];</span>
<span class="k">while</span> <span class="o">(</span><span class="n">exp</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// allocate 10 buckets, count each bucket's size</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">/</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">exp</span><span class="o">)</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>
        <span class="n">cnt</span><span class="o">[</span><span class="n">index</span><span class="o">]++;</span>
    <span class="o">}</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">cnt</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">cnt</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="c1">// put the original array into each bucket</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">/</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">exp</span><span class="o">)</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>
        <span class="n">buf</span><span class="o">[--</span><span class="n">cnt</span><span class="o">[</span><span class="n">index</span><span class="o">]]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">buf</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
    <span class="n">exp</span> <span class="o">*=</span> <span class="mi">10</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="95-tries">9.5 Tries</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210410230423138.png" alt="image-20210410230423138" /></p><p>蓝色节点表示数组中有对应node结尾的元素，比如a、awals、sam、sad、sap、same</p><p>tries主要用在查找prefix上</p><p><strong>trie implementation</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/CS61B/image-20210411101437869.png" alt="image-20210411101437869" /></p><p>character不存储在node上，而是隐式地存储在link上，比如link[0]就是’a’</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TrieSet</span> <span class="o">{</span>
    <span class="c1">// support characters up through #128</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">R</span> <span class="o">=</span> <span class="mi">128</span><span class="o">;</span>
    
    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="cm">/* Up to R links */</span>
        <span class="kt">boolean</span> <span class="n">exists</span><span class="o">;</span>  <span class="c1">// node is blue or white</span>
        <span class="nc">Node</span><span class="o">[]</span> <span class="n">links</span><span class="o">;</span>
        
        <span class="kd">public</span> <span class="nf">Node</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">links</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">[</span><span class="no">R</span><span class="o">];</span>
            <span class="n">exists</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">();</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">put</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">();</span>
        <span class="o">}</span>
        
        <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">x</span><span class="o">.</span><span class="na">exists</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
        <span class="n">x</span><span class="o">.</span><span class="na">links</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">links</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">key</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>BinarayTrie的实现可以参考HW7</p><p><a href="https://github.com/tommyfan34/cs61b/blob/main/hw7/BinaryTrie.java"> https://github.com/tommyfan34/cs61b/blob/main/hw7/BinaryTrie.java </a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/lecture-notes/'>lecture notes</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/others/" class="post-tag no-text-decoration" >Others</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=UCB CS61B Lecture Notes - Xiao Fan (樊潇)&url=https://tommyfan34.github.io/posts/CS61B-notes/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=UCB CS61B Lecture Notes - Xiao Fan (樊潇)&u=https://tommyfan34.github.io/posts/CS61B-notes/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=UCB CS61B Lecture Notes - Xiao Fan (樊潇)&url=https://tommyfan34.github.io/posts/CS61B-notes/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/GAMES101/">GAMES101 Lecture Notes</a><li><a href="/posts/leetcode-notes/">Leetcode Notes</a><li><a href="/posts/LIS-Problem/">LIS Problem</a><li><a href="/posts/Monotone-Stack-Problem/">Monotone Stack Problem</a><li><a href="/posts/CS61B-notes/">UCB CS61B Lecture Notes</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/others/">Others</a> <a class="post-tag" href="/tags/computer-graphics/">Computer Graphics</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/CS61A-notes/"><div class="card-body"> <span class="timeago small" > Mar 17, 2021 <i class="unloaded">2021-03-17T18:11:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>UCB CS61A Lecture Notes</h3><div class="text-muted small"><p> 1 Introduction 本课程基于Structure and Interpretation of Computer Programs (SICP)。课程网址: https://inst.eecs.berkeley.edu/~cs61a/fa20/ 1.1 Python features doctests 在python的def关键词下的一行用"""包裹的文字是叫做docstri...</p></div></div></a></div><div class="card"> <a href="/posts/MIT-6-null-notes/"><div class="card-body"> <span class="timeago small" > Jan 14, 2021 <i class="unloaded">2021-01-14T18:32:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MIT 6.null Lecture Notes</h3><div class="text-muted small"><p> Lecture 1 Shell bash中如果想提供一个包含空格的参数，可以用‘或”“把它们引起来，或者用转义字符\，比如My\ Photos来将空格转义 $PATH是环境变量，即在本地文件夹下没有找到对应可以执行的程序时会自动在环境变量的路径中寻找相应的程序。which提示了能够运行本指令的程序路径，比如 ~$ which echo /bin...</p></div></div></a></div><div class="card"> <a href="/posts/MIT-6S081-notes/"><div class="card-body"> <span class="timeago small" > Mar 2, 2021 <i class="unloaded">2021-03-02T17:44:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MIT 6.S081 Lecture Notes</h3><div class="text-muted small"><p> 课程网址：https://pdos.csail.mit.edu/6.S081/2020/index.html 我的lab实现的github repo：https://github.com/tommyfan34/MIT_6S081 Lecture 1 Introduction 操作系统应该提供的功能：1. 多进程支持 2. 进程间隔离 3. 受控制的进程间通信 xv6：...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/CS61A-notes/" class="btn btn-outline-primary"><p>UCB CS61A Lecture Notes</p></a> <a href="/posts/leetcode-notes/" class="btn btn-outline-primary"><p>Leetcode Notes</p></a></div><div id="comments"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script> <script src='//lib.baomitu.com/valine/latest/Valine.min.js'></script> <script> new Valine({ av: AV, el: '#comments', app_id: 'wp6tzj2sW35FoU9QTAMVl64h-gzGzoHsz', app_key: 'rEv50Y8WsRaFC3Um1ccmOBHD', placeholder: '对FX说些什么吧...', notify: 'true', verify: 'true', avatar: 'mp', recordIP: 'true', enableQQ: 'true', }) </script> </br></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/tommyfan34">Xiao Fan</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/others/">Others</a> <a class="post-tag" href="/tags/computer-graphics/">Computer Graphics</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://tommyfan34.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
