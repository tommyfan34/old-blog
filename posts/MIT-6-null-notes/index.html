<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.7.2"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="MIT 6.null Lecture Notes" /><meta name="author" content="Xiao Fan" /><meta property="og:locale" content="en_US" /><meta name="description" content="Lecture 1 Shell bash中如果想提供一个包含空格的参数，可以用‘或”“把它们引起来，或者用转义字符\，比如My\ Photos来将空格转义 $PATH是环境变量，即在本地文件夹下没有找到对应可以执行的程序时会自动在环境变量的路径中寻找相应的程序。which提示了能够运行本指令的程序路径，比如 1 2 ~$ which echo /bin/echo ls -l表示以详细方式列出当前文件夹下的文件 1 2 missing:~$ ls -l /home drwxr-xr-x 1 missing users 4096 Jun 15 2019 missing 第1个字符表明这个文件的类型。d表示这是一个文件夹，如果是-表示这是一个普通文件，l表示这是一个链接文件，类似于windows下的快捷方式，b表示这是一个块设备文件，一般置于/dev目录下，没有文件大小，只有一个主设备号和辅设备号。块设备是一次传输一整块数据的设备，比如硬盘。c表示这是一个字符设备文件，一般置于/dev目录下，字符设备是一次只传输一个字符数据的设备，比如键盘。p表示这是一个命令管道文件，与shell编程有关，s表示这是一个socks文件，与shell编程有关 d后面有3*3个标志，表示不同的身份对该文件的权限。r表示可读权限，w表示可写权限，x表示可执行权限，-表示无相应权限。第一组表示该文件的所有者的权限，第二组表示文件所有者同组用户的权限，第三组表示其他用户的权限 权限后面的第一个数字表示1. 当这是一个文件时，为硬连接数，即有几个文件硬链接到了这个文件 2. 当这是一个文件夹时，为链接占用的节点，即该目录中包含的子目录的个数 对于一个文件夹来说，为了进入这个文件夹，必须拥有”search”权限，也就是拥有对这个文件夹以及其所有父路径文件夹的x权限。为了ls这个文件夹，必须拥有这个文件夹的r权限 重定向输入输出流：&lt; file将输入设定为文件，&gt; file将结果输出到文件，原先文件的内容会被覆盖 1 2 3 4 5 6 7 8 missing:~$ echo hello &gt; hello.txt missing:~$ cat hello.txt hello missing:~$ cat &lt; hello.txt hello missing:~$ cat &lt; hello.txt &gt; hello2.txt missing:~$ cat hello2.txt hello &gt;&gt;可以来向文件附加数据。|是管道符号，可以将前一个命令的输出作为下一个命令的输入。 1 2 curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=&#39; &#39; -f2 # 查看向google发送HTTP GET请求的头文件中的content length属性的值 文件描述符：一般情况下每个unix命令运行时都会打开3个文件： 标准输入文件(stdin)：文件描述符为0，unix默认从stdin输入数据 标准输出文件(stdout)：文件描述符为1，unix默认向stdout输出数据 标准错误文件(stderr)：文件描述符为2，unix会向stderr流中写入错误消息 默认情况下，command&gt;file将stdout重定向到file，command&lt;file将stdin重定向到file 1 command 2&gt;&gt;file # 将stderr追加到文件末尾// /dev/null文件是一种特殊的文件，写入到它的内容都会被丢弃，也无法从中读取到任何内容，如果希望执行某个命令，但是不希望在屏幕上显示输出结果，可以将输出重定向到/dev/null 1 command &gt;&gt; /dev/null 2&gt;&amp;1 # 屏蔽stdout和stderr command &gt;&gt; /dev/null已经将标准输出重定向，2&gt;&amp;1中的&amp;表示等同，2&gt;表示错误输出，2&gt;&amp;1表示错误输出重定向的对象等同于标准输出重定向的对象，即/dev/null sysfs：Linux内核下基于内存的文件系统，可以将很多内核参数以文件形式暴露，从而可以方便地修改kernel。比如笔记本电脑的屏幕亮度可以以文件的形式在sys/class/backlight下被暴露 1 2 3 4 5 $ sudo find -L /sys/class/backlight -maxdepth 2 -name &#39;*brightness*&#39; /sys/class/backlight/thinkpad_screen/brightness $ cd /sys/class/backlight/thinkpad_screen $ sudo echo 3 &gt; brightness # permission denied，因为&gt;重定向符号之前的sudo并不能被后面观察到，也就是说写入brightness这个操作实际上并没有执行sudo $ echo 3 | sudo tee brightness # success，tee这个命令是获取标准输入，将内容输出成文件，并将其打印到屏幕上 chmod(change mode)来控制用户对文件的权限的命令。只有文件拥有者(owner)和超级用户(super user)可以修改文件或者目录的权限 1 2 3 4 5 6 7 8 chmod [-cfvR] [--help] [--version] mode file... # mode格式为 [ugoa...][[+-=][rwxX]...][,...] # u表示该文件的拥有者，g表示与该文件的拥有者属于同一个group者，o表示其他人，a表示这三者皆是 # +表示增加权限，-表示取消权限，=表示唯一设定权限 # r表示可读取，w表示可写入，x表示可执行，X表示只有当该文件是个子目录或者该文件已经被设定过为可执行 # 示例:将file1.txt设定为所有人皆可读取 chmod ugo+r file1.txt 也可以采用八进制的方法来规定权限 # 权限 rwx 二进制 7 读+写+可执行 rwx 111 6 读+写 rw- 110 5 读+执行 r-x 101 4 只读 r– 100 3 写+执行 -wx 011 2 只写 -w- 010 1 只执行 –x 001 0 无 — 000 1 2 3 4 5 6 # file1.txt这个文件对所有的用户均可读可写可执行 chmod 777 file1.txt # file2.txt这个文件对其他用户只可执行 chmod ug=rwx,o=x file2.txt # 与以下相同 chmod 771 fil2.txt 一般比较常用的是chmod 755和chmod 777 shebang: #! 写在脚本的第一行，用来规定该脚本的解释器。#!后接解释器的绝对路径。比如想要规定这个脚本用sh来执行，那么在第一行添加 1 #!/bin/sh 推荐使用/usr/bin/env python来规定该脚本解释器，这是因为env会在$PATH中查找python解释器的安装位置，这样可以不用提供一个解释器的绝对路径，从而提高程序的可移植性 后台执行shell 在shell命令的最后一个位置加&amp; Lecture 2 Shell Tools and Scripting Shell Scripting Shell是一个用C语言编写的程序，是一种解释性语言。Windows Explorer是一个典型的图形界面shell Bourne Shell /bin/sh或/usr/bin/sh Bourne Again Shell /bin/bash 给变量赋值： 注意在定义变量时变量名不加美元符号，变量名和等号之间不能有空格。在使用一个已经定义过的变量时需要加美元符号 1 2 3 4 5 6 7 8 9 foo=bar # 注意不能是foo = bar，否则bash会认为这是运行了foo命令，并以=和bar作为参数传入 echo &quot;$foo&quot; # prints bar echo &#39;$foo&#39; # or echo &quot;${foo}&quot; # 花括号加不加可选，主要是为了清晰变量名的边界 # prints $foo # 注意在bash中&quot;和‘是不同的。在&#39;中$变量不会被替换，&quot;中$后面的变量会被替换为其值 readonly变量是只读变量，不能被赋值 1 2 myurl=&quot;www.fanxiao.tech&quot; readonly myurl 使用unset命令可以删除变量 获取字符串的长度 1 2 string=&quot;abcd&quot; echo ${#string} # 输出4 提取子字符串 从字符串的第2个字符开始截取四个字符 1 2 string=&quot;runoob is a great site&quot; echo ${string:1:4} # 输出unoo 函数 1 2 3 4 5 # 以shell脚本的名称创建一个文件夹并cd到这个文件夹中 mcd(){ mkdir -p &quot;$1&quot; cd &quot;$1&quot; } $0：脚本本身的名称 $1-$9：脚本的第1-第9个参数 $@：所有脚本的参数 $#：脚本参数的个数 $?：前一个命令的返回代码 $$：当前脚本的PID !!：完整的上一个命令，包括参数。如果一个命令只是因为没有root权限失败，则可以执行sudo !!来重新执行该命令 $_：上一个命令的最后一个参数 数组 数组索引从0开始。用括号()来表示数组，数组元素用空格分开。定义数组的一般形式为 数组名=(值1 值2 值3 值4) 如 1 array_name=(value0 value1 value2) 还可以单独定义数组的各个分量，如array_name[0]=1 读取数组元素值的方式是$(数组名[下标])，使用@则可以获取数组中的所有元素，例如 1 echo ${array_name[@]} 获取数组的长度的方法是 1 length=${array_name[@]} bash基本运算 原生bash不支持简单的数学运算，但是可以通过其他命令实现，比如expr 1 2 val=`expr 2 + 2` # 注意：表达式和运算符之间一定要有空格，例如2+2是不对的，必须写成2 + 2,注意不是单引号而是反引号 echo &quot;两数之和为$val&quot; # 输出为&quot;两数之和为4&quot; 条件表达式要放在方括号之间，并且要有空格，例如 1 2 3 4 5 6 7 8 if [$a == $b] then echo &quot;a等于b&quot; fi if [$a != $b] then echo &quot;a不等于b&quot; fi 关系运算符： 运算符 说明 -eq 检测两个数是否相等，相等则返回true -ne 检测两个数是否不等，不等则返回true -gt 检测左边的是否大于右边的，大于则返回true -lt 检测左边的是否小于右边的，小于则返回true -ge 检测左边的是否大于等于右边的，大于等于则返回true -le 检测左边的是否小于等于右边的，小于等于则返回true ! 非运算 -o 或运算 -a 与运算 注意：乘号前必须要加上反斜杠\转义才是乘法运算 test命令可以用于检查某个条件是否成立 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 数值测试 num1=100 num2=200 if test $[num1] -eq $[num2] then echo &#39;两个数相等&#39; else echo &#39;两个数不相等&#39; fi # 文件测试 cd /bin if test -e ./bash then echo &#39;文件存在&#39; else echo &#39;文件不存在&#39; fi 注意：新的test[[]]比旧的test[]更好，尽量使用[[]] 流程控制：shell编程的流程控制不可为空，即if和else的代码块里必须执行一定的动作 将if和else写成一行的方法： 1 if [ $(ps -ef | grep -c &amp;quot;ssh&amp;quot;) -gt 1]; then echo &quot;true&quot;; fi # 查找当前所有进程中ssh进程的个数，如果大于1则返回true for循环的一般格式 1 2 3 4 5 6 for var in item1 item2 ... itemN do command1 command2 commandN done 写成一行： 1 for var in item1 item2 itemN; do command1; command2; commandN; done; while循环： 1 2 3 4 5 6 7 8 9 10 11 12 int=1 while [ $int -lt 5 ] do echo $int let &quot;int++&quot; # let是bash中用于计算的工具，变量计算中不需要加上$表示变量 done # 运行结果 # 1 # 2 # 3 # 4 # 5 case选择 每个case分支从右圆括号开始，用两个分号;;表示break，跳出整个case...esac语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 echo &#39;输入1到4之间的数字&#39; echo &#39;你输入的数字为&#39; read aNum case $aNum in 1) echo &#39;你选择了1&#39; ;; 2) echo &#39;你选择了2&#39; ;; 3) echo &#39;你选择了3&#39; ;; 4) echo &#39;你选择了4&#39; ;; *) echo &#39;你没有输入1到4之间的任何数字&#39; ;; esac break命令 1 2 3 4 5 6 7 8 9 10 11 12 while true do echo -n &quot;输入1到5之间的数字&quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为$aNum!&quot; ;; *) echo &quot;你输入的数字不是1到5之间的！结束&quot; break ;; esac done shell函数 1 2 3 4 5 6 7 8 9 10 11 [function] funname [()] { action [return int] } # example demoFun(){ echo &quot;第一个shell函数&quot; } demoFun # 调用这个函数 程序的返回值：执行成功返回0，执行失败则返回其他大小的数值。注意，和C语言不同，shell中0表示true，1表示false 获取一个程序的变量值，如$(CMD)会先执行CMD，获取CMD的输出并再相应位置进行替换。比如执行for file in $(ls)，将先执行ls，然后遍历执行ls后获得的返回值 进程替换(process substitution)：&lt;(CMD)将执行CMD，然后将结果输出到一个临时文件，并把&lt;()替换为这个文件名。比如cat &lt;(ls -l)相当于ls -l | cat，diff &lt;(CMD1) &lt;(CMD2)是比较这两个CMD的区别 shell文件包含 包含外部脚本，以封装一些公用的代码作为一个独立文件 1 2 3 . file # 注意.和文件名中间有一个空格 # 或者 source file shell通配符(globbing) wildcard: 使用*或?来进行匹配，比如有foo1、foo2、foo几个文件，rm foo?将删除foo1和foo2，而rm foo*将删除foo1、foo2和foo等三个文件 花括号{用来扩展子字符串 1 2 3 convert image.{png,jpg} # will expand to convert image.png image.jpg Shell Tools tldr: – too long, didn’t read manual cheat sheet for console 寻找文件 find 1 2 3 4 5 6 7 8 9 10 11 12 # 寻找所有名为src的文件夹 find . -name src -type d # 寻找所有路径名中有test文件夹的Python文件 find . -path &#39;*/test/*.py&#39; -type f # 寻找所有在昨天被修改的文件 find . -mtime -l # 寻找所有大小在500k到10M的zip文件 find . -size +500k -size -10M -name &#39;*.tar.gz&#39; # 删除所有.tmp扩展名的文件。-exec表示在find寻找到这些文件之后可以执行的额外动作，\;表示这些额外动作的结束。{}用来指代前面find到的文件 find . -name &#39;*.tmp&#39; -exec rm {} \; # 将所有PNG文件转化为JPG文件 find . -name &#39;*.png&#39; -exec convert {} {}.jpg \; fd是更好的find，支持正则表达式查找 locate是一个使用updatedb更新的数据库进行文件查找的程序，效率比find和fd更高，但是因为是每日更新的，所以并不是最新的。 grep是基于文件内容进行搜索，grep -C是获取匹配内容的上下文(Context)，比如grep -C 5是获取匹配内容的上下各5行内容，grep -R是递归(Recursively)地进入文件夹查找文件中的内容，grep -v用来反向(inversely)选择匹配的内容 rg、ag等也是和grep类似的查找工具，其中ripgrep(rg)是一个查找神器，用来查找代码中的code snippet，可以进行自动递归搜索，自动故忽略.gitignore中的文件和二进制文件，例如 1 rg -t py &quot;import request&quot; 查找所有包含import request的python文件 history可以用来查看shell中的所有交互记录，history | grep find则可以打印出过去曾经使用的find命令 在shell中可以按CTRL+R来进行反向搜索历史，通过键入一个子字符串来搜索过去的命令 fzf是一个模糊搜索工具(fuzzy finder) zsh：一种非常牛逼的shell，可以实现根据历史的命令来进行自动命令建议 fasd是快速跳转路径的工具，可以根据访问频率来自动给出跳转路径的建议 Lecture 3 Vim 快捷键 normal mode下G: 跳转到文件的最后一行 gg跳转到文件的第一行 w：下一个word，bbeginning of word、e：end of word $：跳转到行尾，^跳转到行首 ^u：向上滚动 ^d：向下滚动 h：光标左移 j：光标下移 k：光标上移 l：光标右移 :sp file：水平方向分割窗口，并打开file :vsp file：垂直方向分割窗口，并打开file ^ww：在打开的分割窗口之间切换 /：搜索字符串，按n跳转到下一个匹配，按N跳转到上一个匹配，可以进行/{regex}正则表达式搜索 c：change，即删掉选中的字符，然后进入Insert模式 d：delete，即删掉选中的字符 u：undo ^r: redo v：进入visual模式，可以通过光标移动来进行文本块的选择 .：重复之前的键入 o(open)：在下方键入新行 :n：跳转到第n行 :%d：删除所有行，其中%表示所有行 :2,8d表示删除第2到第8行 modifier: i(inside)或a(around)，比如ci[就是删除[]内的所有字符并进入insert模式，ca(就是删除()内以及()本身这些所有的字符并且进入insert模式 counts: 在命令前面加上数字来表示重复动作，比如3w是向后跳转3个word，5j是向下跳转5行 插件推荐 CtrlP: 一种能够在vim中模糊查找工程文件的vim插件 fugitive.vim: vim的git插件 ale：code linting插件，需要先安装pylint和eslint等linting插件 sudo apt-get install vim-gtk：系统自带vim不支持复制到系统剪切板，需要重装vim 可以安装vim-airline这款主题美化插件 NERDTree目录树，在vim normal模式键入:NERDTree即可打开目录树，:q关闭目录树 在/etc/vim/vimrc最后增加以使vim使用系统剪切板 1 2 3 4 5 6 7 8 &quot; WSL yank support let s:clip = &#39;/mnt/c/Windows/System32/clip.exe&#39; &quot; change this path according to your mount point if executable(s:clip) augroup WSLYank autocmd! autocmd TextYankPost * if v:event.operator ==# &#39;y&#39; | call system(s:clip, @0) | endif augroup END endif Lecture 4 Data Wrangling RegEx +表示前面的字符必须出现一次或者多次 *表示前面的字符可以出现0次、1次或者多次 ?表示前面的字符可以出现0次或1次，加在+和*后面以实现非贪婪匹配 [abc]表示匹配其中的所有abc三个字符 [^abc]表示匹配除了a、b、c之外的其他所有字符 [A-Z]表示一个区间，匹配所有大写字母 [\s]匹配所有空白符 [\S]匹配所有非空白符，[\s\S]匹配所有字符 [\d]，digit，匹配[0-9]的数字，[\D]匹配所有非数字 .匹配除了换行符\n之外的所有字符 [\w]word，匹配字母、数字、下划线，等价于[a-zA-Z0-9_] ()标记一个子表达式的开始和结束位置，子表达式可以获取供以后使用 非捕获元：?:放在()中可以避免匹配被缓存，exp1(?=exp2)正向肯定预查，查找exp2前的exp1，(?&lt;=exp2)exp1查找exp2后的exp1，exp1(?!exp2)查找后面不是exp2的exp1，(?&lt;!exp2)exp1查找前面不是exp2的exp1 只有grep -P才支持 {}限定符表达式，用来表示匹配的长度，比如s{1,3}表示匹配1-3个空格，o{1,}表示匹配1个以上的o ^：定位符，匹配输入字符串开始位置，不要和中括号表达式中的^混淆。$：定位符，匹配输入字符串结束位置 \b：定位符，匹配单词边界 \B：定位符，匹配非单词边界 修饰符：写在正则表达式之外，用于指定额外的匹配策略\pattern\flags i-ignore，不区分大小写 g-global，查找所有的匹配项 m-multiline，多行匹配，使^和$匹配一段文本中每行的开始和结束位置 use case 获取尝试连接远程服务器的用户名 1 ssh myserver &#39;journalctl | grep sshd | grep &quot;Disconnected from&quot;&#39; | less # journalctl是日志管理工具 journalctl和from之间的&#39;&#39;quoting是为了直接在服务器来查找这些内容，再把筛选好的内容传送到本地 sed: stream editor流编辑器，利用命令行对文件进行修改 s命令：substitution，用法：s/REGEX/SUBSTITUTION比如 1 2 3 4 ssh myserver journalctl | grep ssh | grep &quot;Disconnected from&quot; | sed &#39;s/.*Disconnected from //&#39; # 删除所有&#39;Disconnected from&#39; 提取用户名 1 | sed -E &#39;s/.*?Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#39; 排列用户名，列出用户名出现重复的次数 1 2 3 4 5 ssh myserver journalctl | grep sshd | grep &quot;Disconnected from&quot; | sed -E &#39;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#39; | sort | uniq -c 其中sort可以对输入的字符串组进行排序，uniq -c将所有重复的条目去掉，对每个条目只保留一次，并且将每个条目重复的次数打印 对这个重复的次数进行排序，并打印出重复次数最多的前10个条目 1 | sort -nk1,1 | tail -n10 sort -n将会对数字进行排列，-k1,1表明只对以空白键分割的第一列进行排序 将以上筛选出的用户名以逗号分隔，打印成一行输出 1 | awk &#39;{print $2}&#39; | paste -sd, paste -s可以将多行合并为一行，-d,表明分隔符delimiter是,。 awk是一种文字流处理编程语言，与sed、grep合并成为Linux三剑客，sed擅长对一行进行处理以及进行替换，grep擅长查找，awk擅长对列进行处理 筛选出所有只出现过一次的名称以c开头e结尾的用户名并统计数量 1 | awk &#39;$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ {print $2}&#39; | wc -l xargs：将找到的文本作为命令行的参数 1 rustup toolchain list | grep nightly | grep -vE &quot;nightly-x86&quot; | sed &#39;s/-x86.*//&#39; | xargs rustup toolchain uninstall 有的命令可以接受标准输入作为参数，比如grep，这样就可以使用管道命令|，比如cat /etc/passwd | grep root相当于grep root /etc/passwd，但是大多数命令不接受标准输入作为参数，只能直接在命令行输入参数，比如echo，因此xargs就是将标准输入转为命令行参数，比如 1 2 $ echo &quot;hello world&quot; | xargs echo hello world xargs的默认命令是echo，即xargs=xargs echo http://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html 对二进制的wrangling 用ffmpeg来从摄像头捕获图像，转化为灰度图，压缩，通过ssh发送到远程服务器并在远程服务器上解压，复制并展示 1 2 ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 - | convert - -colorspace gray - | gzip | ssh mymachine &#39;gzip -d | tee copy.jpg | env DISPLAY=:0 feh -&#39; Exercise 查找/usr/share/dict/words下含有至少3个a并且不以’s结尾的单词的个数 1 grep -P &quot;(.*a){3,}.*(?&lt;!&#39;s)$&quot; /usr/share/dict/words | wc -l 其中grep -P是以perl语法输入正则表达式，以开启?&lt;! 结尾出现频率最高的两个字母是什么？ 找出前三名 1 grep -P &quot;(.*a){3,}.*(?&lt;!&#39;s)$&quot; /usr/share/dict/words | sed -E &#39;s/.*(\w\w)/\1/g&#39; | uniq -c | sort -nk1,1 | tail -n3 Lecture 5 Command Line Environment Job control UNIX使用signal来和进程进行通信，signal起到中断作用 ^C向进程发出SIGINT指令，^\向进程发出SIGQUIT指令。程序会产生core文件，相当于程序错误，kill -TERM &lt;PID&gt;向进程发出SIGTERM指令，该信号可以被阻塞和处理，通常用来要求程序自己正常退出，SIGSTOP是暂停进程 下述python指令将忽略^C的SIGINT指令 1 2 3 4 5 6 7 8 9 10 11 12 #!/usr/bin/env python import signal, time def handler(signum, time): print(&quot;\nI got a SIGINT, but I am not stopping&quot;) signal.signal(signal.SIGINT, handler) # attach SIGINT to handler i = 0 while True: time.sleep(.1) print(&quot;\r{}&quot;.format(i), end=&quot;&quot;) i += 1 ^Z向shell发出一个SIGTSTP来暂停一个进程，使用fg或bg命令来把暂停的进程放在前台或者后台运行，比如bg %1 jobs用来列出所有当前终端对话尚未完成的任务，可以使用pgrep来获取这些任务的PID，也可以使用%1、%2等获取对这些任务的引用 可以在所有任务的最后增加一个&amp;后缀来使命令跑在后台 直接kill %1来终止第1个任务 Terminal Multiplexers tmux可以在一个终端窗口下使用多个pane和tab keybinding: 默认情况下是^b。 Session：独立的工作区， tmux：来启动一个新的session tmux new -s NAME：启动一个指定了名称的session tmux ls：列出现在的所有session 在tmux里按下^b d来从当前的session中detach tmux a来attach到上一个session Windows：相当于浏览器中的tab，属于同一个session ^b ccreate一个新的窗口，通过^d来关闭这个窗口 ^b N前往第N个窗口，N为数字 ^b p前往前一个窗口 ^b n前往下一个窗口 Panes：相当于vim中的split界面 ^b &quot;水平分割窗口，^d退出当前窗口 ^b %垂直分割窗口 ^b &lt;arrow&gt;跳转窗口 ^b &lt;space&gt;在不同的窗口设计中选择 Aliases 命令的代换(aliasing) 1 alias alias_name=&quot;command_to_alias arg1 arg2&quot; 注意=左右两边没有空格 e.g. 1 2 3 4 alisa ll=&quot;ls -lh&quot; alias gs=&quot;git status&quot; alias gc=&quot;git commit&quot; alias v=&quot;vim&quot; 上述alias命令在shell关闭之后会自动重设，可以在.bashrc或者.zshrc中写入相关的alias来使设置永久有效 Dotfiles 很多程序使用纯文本文件dotfile来对程序进行配置，比如.vimrc，这些文件默认隐藏在目录中。对bash程序来说，.bashrc或.bash_profile是默认配置bash设置的文件。在很多程序中要求dotfile指定一个二进制可执行文件的路径 1 export PATH=&quot;$PATH:/path/to/program/bin&quot; 可以将所有的dotfile放在一个文件夹下，进行版本控制，并且symlink它们，这样可以方便在不同的机器上将自定义的设置进行迁移 可以参考github上一些比较受欢迎的dotfile repo，例如https://github.com/mathiasbynens/dotfiles 为了提高dotfile的可移植性，可以在dotfile中增加一些条件判断语句，例如 1 2 3 4 5 6 7 if [[ &quot;$(uname)&quot; == &quot;Linux&quot; ]]; then {do_something}; fi # Check before using shell-specific features if [[ &quot;$SHELL&quot; == &quot;zsh&quot; ]]; then {do_something}; fi # You can also make it machine-specific if [[ &quot;$(hostname)&quot; == &quot;myServer&quot; ]]; then {do_something}; fi 如果想让zsh和bash使用同一个alias配置，可以在.bashrc和.zshrc文件中加入相同的 1 2 3 if [ -f ~/.aliases ]; then source ~/.aliases fi p.s. source &lt;filename&gt;和./&lt;filename的区别在于source是直接在当前SHELL session中执行的，而./是新起了一个session Remote machines SSH(secure shell) 1 ssh user@ip_address|url_of_server [command] # [command]表示在远程服务器中执行这个命令，然后返回到本地服务器 SSH config: 客户端SSH配置文件/etc/ssh/ssh_config。服务端SSH配置文件/etc/ssh/sshd_config SSH keys：SSH服务器持有公钥，客户端持有私钥，这样就不需要每次SSH到服务器时重新键入密码了。SSH key passphrase是为了防止别人持有你的私钥采用的加密措施 通过SSH来复制文件 最简单的方法是：ssh+tee，e.g. cat localfile | ssh remote_server tee serverfile tee和cat正好相反，tee用于读取标准输入，将其内容输出成文件，而cat用于读取文件，将其输出成标准输出 secure copy scp：可以recurse over path，scp path/to/local_file remote_host:path/to/remote_file rsync是scp基础上的提升，可以检测到本地和远程文件的相同文件，并不对它们进行重复复制。rsync的语法和scp类似 SSH port forwarding端口转发 如果在本地的应用向某个被绑定的端口发送数据，则这些数据将自动通过SSH被转发到远程服务器的另一个被绑定端口并做本地调用 Dynamic Tunneling (SOCKS proxy) 1 ssh -D 8080 remote_server 在192.168.56.101的浏览器中输入http://localhost时，这个http request会被发送到8080端口，但是由于SOCKS Proxy在8080端口监听，并把这个HTTP request转发给了SSH Client，SSH Client通过SSH将这个HTTP request发送给了102的SSH服务器，102在本地解析运行这个HTTP请求，由于HTTP默认使用80端口，如果102有apache绑定在其80端口上提供服务的话，那么apache服务器将接受这个对localhost的访问请求，返回相应的web服务页面 local port forwarding 1 ssh -L &lt;local port&gt;:&lt;remote hostname&gt;:&lt;remote service port&gt; user@remoteserver 比如 1 ssh -L 8000:localhost:80 ramki@192.168.56.102 client端绑定了8000端口，任何发送到8000端口的数据都将通过SSH客户端通过22端口发送到SSH服务端，由于绑定了远程服务器的80端口，因此远程服务端将把22端口的数据转发到80端口上。在dynamic tunneling模式中，服务器会检查packet并自动决定该packet发往哪个端口，比如HTTP request发往80端口，SMTP发往25端口，但是local port forwarding将发往指定的端口 remote port forwarding 1 ssh -R &lt;remote port&gt;:&lt;local hostname&gt;:&lt;local port&gt; user@remoteserver 把所有尝试发送到远程服务器指定端口的数据从&lt;local hostname&gt;的&lt;local port&gt;发送 Exercise 写一个脚本，以实现wait [PID]的功能 1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash while : do kill -0 $1 # $1 为脚本后面跟的第一个参数，也就是PID。kill -0是尝试杀这个进程，如果这个进程不存在就会返回1，否则返回0，但是不会实际去杀掉这个进程 if [[ $? -ne 0 ]] then break fi sleep 1 done ls -al Lecture 6 Version Control Git data model 文件：blob，本质是array&lt;byte&gt; 目录：tree，本质是map&lt;string, blob | tree&gt; 快照(snapshot)：也被称为commits，本质是被追踪的最高一级tree (root)。commits无法被改变 1 2 3 4 5 6 type commit = struct { parent: array&lt;commit&gt; author: string // metadata message: string // metadata snapshot: tree } 历史：DAG(directed acyclic graph) of snapshots，每个历史中的snapshot都指向它们的父节点，父节点可以不止一个，因为当merge的时候就会出现两个父节点 1 2 3 4 o &lt;-- o &lt;-- o &lt;-- o &lt;---- o ^ / \ v --- o &lt;-- o 对象(object)：type object = blob | tree | commit 所有对象都用SHA-1 hash来引用 1 2 3 4 5 6 7 8 objects = map&lt;string, object&gt; def store(object): id = sha1(object) objects[id] = object def load(id): return objects[id] git cat-file &lt;SHA1&gt;就相当于上面的load(id)函数 引用(reference)：对commit的指针(比如master)，由于commit是SHA-hash码，人类难以记住，因此使用reference这种人类可读的字符串来指向commit，reference是可以改变的，即可以更改指向的commit。 1 2 3 4 5 6 7 8 9 10 11 12 13 references = map&lt;string, string&gt; def update_reference(name, id): references[name] = id def read_reference(name): return reference[name] def load_reference(name_or_id): if name_or_id in references: // is name return load(references[name_or_id]) else: // is id return load(name_or_id) HEAD：一个特殊的reference，用于指向我们目前看的commit 仓库(repository)：objects和references的集合 所有的git命令都是通过加入object和加入/更新references来对DAG进行操作 Git command-line interface 基础命令 git init：创建一个新的git仓库，数据存储在.git文件夹中 git status：查看目前git的状态 git add &lt;filename&gt;：将文件添加到staging area git commit：增加一个新的commit git commit -a表示automatically将所有之前已经追踪过的文件进行git add，从而省去git add的步骤 git log --all --graph --decorate：将git历史以DAG展现出来 git log -p -2显示历史中的最后2个commit的差异(patch) git log --pretty=oneline：将每个commit的信息用一行显示 过滤输出：git log --since=2.weeks：仅打印过去2周到现在的所有commit历史 --grep可以在commit信息中查找关键词进行输出过滤 git log -S function_name：只显示最后一个修改了某个特定函数的commit git log -- path/to/file：显示修改了这个文件的commit git diff &lt;filename&gt;：显示某个working directory中的文件和staging area中的差异 git diff --staged：显示在staging area中的文件和上次commit中的文件的差异 git diff &lt;version&gt; &lt;filename&gt;：显示某个文件不同commit中的差异 git checkout &lt;version&gt;：将HEAD移动到这个版本的commit git rm &lt;filename&gt;：相当于删除某个文件，并从staging area中将其删除(但是还没有commit) 如果想要在工作区中保留这个文件，但是从staging area中将其删除，使用git rm --cached &lt;filename&gt;，比如git rm log/\*.log可以删除所有log/目录下的.log后缀的文件，注意要在*前加一个\号 git tag：显示所有标签，git tag -l &quot;v1.8.6*&quot;显示所有1.8.6版本系列的标签 为某一个commit创建一个新的annotated tag（一次正式的发布，包含了创建日期、名称和邮箱、GPG签名等信息）：git tag -a v1.4 -m &quot;my version 1.4&quot; &lt;shachecksum&gt; 创建一个新的lightweight tag（仅仅是为一个commit对象起了一个别名，不包含任何其他信息）：git tag &lt;tag name&gt; 默认情况下git push时不会将tag推送到远程，可以采用git push origin --tags来将tag推送 git tag -d &lt;tag name&gt;删除某个标签 分支和合并命令 git branch：显示目前所有的分支 git branch &lt;name&gt;：创建一个新的分支 git branch -d &lt;name&gt;：删除某个分支 git checkout -b &lt;name&gt;：创建一个新的分支并且切换到这个分支，相当于git branch &lt;name&gt;; git checkout &lt;name&gt;，可以用git switch -c &lt;name&gt;代替 git merge &lt;revision&gt;：将&lt;revision&gt;合并到当前分支 git mergetool：使用合并工具来帮助处理合并冲突 git rebase：也可以达到合并分支的效果，但是和merge不同的是分叉会被取消 git merge：origin和mywork产生了分叉 git rebase：没有分叉，Commit5’和6‘以补丁的形式存在，放在./git/rebase目录中 远程命令 origin是默认的被克隆的远程名称（不是分支名，origin的master分支为origin/master)，被track的上游远程分支可以以@{upstream}或@{u}指代 git remote：显示所有已知的远程，增加一个-vflag来显示远程仓库的URL，或者git remote show &lt;remote&gt;来显示更多信息 git remote add &lt;name&gt; &lt;url&gt;：增加一个新的远程 git remote rm &lt;name&gt;：删除某个远程 git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;：将objects发送到远程分支，并且更新远程分支的reference git push &lt;remote&gt; --delete &lt;remote branch&gt;：删除远程分支 git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;：设置本地branch和远程branch的连接关系，从而可以直接进行git push而不需要指定远程branch git branch -vv查看目前正在追踪的远程分支 git fetch：从远程项目拉取所有的objects/reference，但是并不merge到working directory中，对working directory没有任何影响 git pull：相当于git fetch; git merge git clone：从远程分支下载repo，将本地的master分支追踪远程的master分支(本地分支和远程分支存在连接关系，运行git push时本地分支将知道push到哪个远程分支) git rebase：将一个分支rebase到另一个分支上，这样可以使分叉的commit变成线性的 撤销命令 所有的commit大概率是可以被恢复的，但是没有被commit的snapshot很难被恢复 git commit --amend：修改commit的内容 比如 1 2 3 git commit -m &#39;Initial commit&#39; git add forgotton_file git commit --amend 最终只有一个initial commit，里面包括了forgotton_file git reset HEAD &lt;file&gt;：把文件从staging area撤出，但是不会修改文件 也可以使用git restore --staged &lt;file&gt; git restore &lt;file&gt;则是将还未stage的文件恢复到上一次commit时的状态 git checkout -- &lt;file&gt;：把文件在工作区的修改全部撤销，撤销到最近一次git commit或git add的状态。当文件自修改后还没有放到暂存区时，使用本命令将回到和版本库相同的状态（但git还是知道修改的），当文件已经添加到暂存区，并且又做了修改之后，则回到添加到暂存区时的状态。 高级命令 git config：配置git，分成三个层面的配置，包括系统级别、用户级别、仓库级别 git config --system -l查看系统配置，配置文件存储于[path]/etc.gitconfig git config --global -l查看用户配置，配置文件存储于~/.gitconfig或~/.config/git/config文件 git config --local -l查看仓库配置，配置文件存储于[repo]/.git/config 优先级：仓库配置&gt;用户配置&gt;系统配置 设置main为默认的分支名：git config --global init.defaultBranch main git clone --depth=1：浅克隆，将忽略之前所有的版本历史 git add -p：交互式添加到暂存区，能够方便地将一个文件中的部分内容添加到暂存区 git rebase -i：interactive rebasing git blame：显示哪个用户编辑了哪一条 git stash：将目前还不想提交但是已经修改的内容（包括工作区和暂存区）保存到堆栈中，后续可以在某个分支上恢复出堆栈的内容。git stash pop将堆栈中的内容弹出到当前分支上，堆栈内容被删除，而git stash apply则将堆栈中的内容应用到当前分支上，和git stash pop不同的是堆栈中的内容并不会被删除，适用于应用到多个分支的情况 .gitignore：指定不需要track的文件 Git workflow https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow 软件开发的workflow，规定了分支的类型和怎样合并分支 master分支：软件的release版本分支 develop分支：开发分支 feature分支：每个单独的feature作为一个分支，以develop作为父分支 推荐阅读：pro git Lecture 7 Debugging and Profiling Logging Linux终端显示不同的颜色，使用ANSI escape颜色码 echo -e &quot;\e[1;31mThis is red\e[0m&quot; 显示红色的This is red echo -e &quot;\e[1;42mGreen Background\e[0m&quot;显示绿色背景的Green Background 大多数程序将日志文件存放在/var/log目录下，systemd是一个system的daemon程序，将所有系统日志存放在var/log/journal下，可以用journalctl来查看 logger &quot;logging info&quot;可以将log记录到journal中 Debugging pdb：python debugger s(tep)：单步执行，相当于step into n(ext)：单步执行，相当于step over l(ist)：列出执行到的那行代码的前后十一行 c(ontinue)：继续执行，直到遇到下一条断点 b(reakpoint)：设置断点 cl(ear)：清除断点 r(eturn)：执行当前运行函数直到结束 p(rint) &lt;expression&gt;：输出expression的值 q(uit)：退出debugger restart：重新debug 使用python -m pdb &lt;filename.py&gt;来进行pdb调试，其中-m表示将模块(module)当作脚本运行，也就是将pdb当作脚本运行 gdb(GNU debugger)：C/C++ debugger，也支持Go和Rust调试，用法和pdb类似 静态代码分析：无需用编译器编译运行即可扫描出代码错误 pyflakes是python的静态扫描工具，shellcheck可以对shell scripts进行扫描 code linting：在编译前即标出警告和错误的位置 一些linter推荐： https://github.com/caramelomartins/awesome-linters#cc Profiling 获取程序运行的资源占用以及时间信息 Timing Real time: 真实时间，包括了被其他进程占用的时间和等待I/O以及网络的时间 User time: 用户时间，即CPU运行用户代码所花费的时间 Sys time: 系统时间，即CPU运行kernal代码所花费的时间 time &lt;command&gt;可以计算上述三个时间 CPU profiler 最常见的profiler，两种类型： tracing profiler: 记录每个函数调用 sampling profiler：周期性地对程序采样，记录程序的堆栈 对于python程序，使用cProfile来作为profiler python -m cProfile -s tottime &lt;filename.py&gt; 但是由于cProfiler将所有内部调用函数的开销都统计在内，很难看出真正把时间都花在了哪里，因此可以使用line_profiler来统计每一行代码所花费的时间，这样更加直观，需要添加一个decorator @profile来声明需要进行profiling的函数 可以使用flame graph来将CPU profiling可视化 memory profiler 内存泄漏：即使在不需要用到这些内存的时候也不将其释放，在没有垃圾收集的语言，比如C/C++中可以使用valgrind来显示内存泄漏，python可以使用memory_profiler来进行memory profiling 函数调用图：python中可以选择pycallgraph来显示哪个函数调用了哪个 resource monitoring htop：top的升级版，来观察系统资源使用情况 free：观察系统可用内存使用情况 df：当前文件夹中磁盘使用情况 nethogs/iftop/ss：网络使用情况 hyperfine：对程序进行快速benchmark，例如比较fd和find的速度 1 hyperfine --warmup 3 &#39;fd -e jpg&#39; &#39;find . -iname &quot;*.jpg&quot;&#39; Lecture 8 Metaprogramming Build systems 将依赖编译构建为二进制文件的流程需要用到build systems，比如make 定义： 依赖(dependency) 目标(target) 构建规则(rule) 在某个目录下执行make时，make将会查找该目录下的Makefile，示例如下所示 1 2 3 4 5 6 7 8 # this is comment @# @ is to turn off the echoing of comment # .ONESHELL: paper.pdf: paper.tex plot-data.png pdflatex paper.tex plot-data.png plot-%.png: %.dat plot.py ./plot.py -i $*.dat -o $@ 冒号左边是需要构建的目标文件，冒号右边是依赖文件，下面一行是构建规则,，注意每行命令在单独的shell中执行，这些shell之间没有继承关系，除非将几行命令写在一行中，中间用分号分割，或者加上.ONESHELL:命令，每一个这样的组合构成了一个directive %是一个样式，匹配任意字符串，如果需要构建的是plot-data.png，那么就会去寻找data.dat这个依赖文件 $@是目前的target 目标文件如果已经构建成功，而依赖文件没有作任何更新，那么再执行make将不会有任何动作，如果某个依赖文件更新，那么只对和该依赖文件有关的编译动作进行重新编译。 除了文件名，目标还可以是某个操作的名字，称为伪目标，比如make clean不是make一个叫做clean的文件，而是删除对象文件，因此要把clean声明为伪目标 1 2 3 .PHONY: clean clean: rm *.o temp make install将可执行文件复制到正确的路径，即被复制到某个PATH包含的路径 Dependency management 有多种不同的依赖： 依赖程序：例如python 依赖系统包(system packages)：例如openssl 编程语言中的库(library)：例如matplotlib 仓库：管理各种依赖的地方，比如ubuntu中的apt、Ruby中的gem、Python中的pip以及nodejs中的npm versioning：对软件版本控制 semantic versioning: major.minor.patch patch：新的版本不改变API，增加patch# minor：如果对API的改变是向后兼容的，增加minor# major：如果对API的改变不向后兼容，增加major# lock file：列出所有依赖的版本信息的文件，需要手动对依赖库中的软件进行升级 vendoring：将所有依赖的源代码复制到项目中，来获得对依赖的完全控制权 Continuous Integration System (CI) 持续集成，即一旦进行了源代码的commit，即进行自动编译测试，将代码集成到主干，从而尽快发现错误，防止分支大幅偏离主干 比较多的CI工具包括Travis CI、Azure Pipelines和Github Actions CI是事件触发，一旦被触发，CI将起一个虚拟机，在其中运行用户规定的recipe所需要执行的命令。GitHub Pages就是一个CI系统，每次md文件被commit到repo后jekyll就会将其编译为HTML并deploy到服务器上 git本身就是一个简单的CI系统，在.git/hooks下有一些事件触发的脚本，比如pre-commit.sample,在commit时被触发 测试 test suite：所有测试的集合 unit test：单元测试，对某一个feature进行单独测试 integration test：集成测试，对各个单元继续联合测试 regression test：回归测试，对之前所有产生bug的条件进行测试从而保证相同的bug不再出现 mocking：用一个假的Implementation来代替一个功能模块来实现对其他依赖于此模块的其他模块进行测试 Lecture 9 Security and Cryptography Hash functions 将一个任意长度的bytes array映射到一个固定长度的byte 其中一种Hash function是SHA1，生成160位输出(40个16进制字符) 可以使用sha1sum命令来输出一个文件的SHA1哈希值 哈希函数有以下的特性： deterministic：相同的输入总是生成相同输出 non-invertible：已知输出，很难得到输入 collision resistant：两个不同的输入很难得到相同的输出 Key Derivation Functions (KDF) 本质上属于Hash函数 给一个passphrase(相当于用户的password)，生成一个固定长度的key，通常KDF相当缓慢，为了防止brute force破解密码 KDF可以用于存储网站密码，比如生成一个随机的salt，然后存储salt以及KDF(password+salt)，用重新生成KDF(password+salt)来验证每次的登陆尝试 Symmetric cryptography 对称加密的过程： 1 2 3 keygen() -&gt; key # 随机生成一个key，通信双方交换这个key，key需要保密 encrypt(plaintext, key) -&gt; ciphertext decrypt(ciphertext, key) -&gt; plaintext 对称加密的特性： 即便拥有ciphertext，没有key的情况下也无法得到plain text 显然正确性，即decrypt(encrypt(message, key), key) = message 比较著名的对称加密算法：AES Asymmetric cryptography 非对称加密，有一个公钥，不需要保密，还有一个私钥，自己保存，需要保密。这样可以解决对称加密中需要交换密钥的问题 非对称加密的过程： 1 2 3 keygen() -&gt; (public key, private key) encrypt(plaintext, public key) -&gt; ciphertext decrypt(ciphertext, private key) -&gt; plaintext 非对称加密可以用于签名/验证过程： 1 2 sign(message, private key) -&gt; signature verify(signature, message, public key) -&gt; &lt;bool&gt;is_signature 非对称加密的应用： PGP邮件加密 私人通信频道 公钥分发：如何确认别人得到的公钥确实是我们给他们的公钥？ 著名的非对称算法：RSA算法 GPG(GNU Private Guard)是一个使用RSA算法对文件进行加密的软件 使用方法：https://www.digitalocean.com/community/tutorials/how-to-use-gpg-to-encrypt-and-sign-messages case study Two-Factor Authentication (2FA)：用一个passphrase和某个authenticator(授权文件或物理设备，如YubiKey)来防止passphrase的泄露 磁盘加密：使用对称加密，需要passphrase，Linux上可以使用cryptsetup+LUKS，Windows上可以使用BitLocker SSH：ssh-keygen是非对称加密，生成一个公钥和密钥，密钥采用KDF进行对称加密，因此需要一个passphrase。服务器需要知道公钥，私钥保存在本地。服务器先选一个随机的信息发送给client，要求client对该信息进行签名，client将该信息签名之后发送给server，server通过公钥验证该签名 Lecture 10 Miscellaneous Daemons 守护进程，开机自动运行在后台的进程，这些进程一般后缀都有一个d，比如sshd就是SSH的守护进程，负责监听SSH请求。systemd是linux的系统守护进程，负责运行和设置守护进程，可以运行systemctl status来列出当前正在运行的daemon。可以使用cron来定时运行守护进程 FUSE (Filesystem in User SpacE) 用户空间文件系统，即用户可以通过FUSE在用户空间定制实现自己的文件系统而不必在内核态 fuse_user是开发的用户态的文件系统程序，该程序启动的时候会将自己开发的接口注册到fuse中，比如读写文件的接口，遍历目录的接口等等。 同时，通过该程序在系统某个路径挂载fuse文件系统，比如/tmp/file_on_fuse_fs。此时如果在该目录中有相关操作时，请求会经过VFS到fuse的内核模块（上图中的步骤1），fuse内核模块根据请求类型，调用用户态应用注册的函数（上图中步骤2），然后将处理结果通过VFS返回给系统调用（步骤3）。 SSHFS就是一个FUSE文件系统，可以通过SSH链接在本地打开远程服务器的文件/文件夹 API 大多数的线上服务有可以让你通过编程获取一定形式的API，这些API都有固定结构的URL，经常是以api.service.com为root 很多API会要求一个token来获取服务，可以通过OAuth这个协议来获取token token和密码是不同的，token是短期的，到期自动失效，也可以被数据所有者撤销，且有权限范围 Command Line flags/patterns 大多数命令行有类似的flag，比如： dry run：只会打印出如果不在dry run模式下的结果，但实际上什么修改都不会进行 --verbose或-v：打印详细内容，-vvv打印更详细的内容，--quiet打印简短的内容 -代替文件名表示标准输入输出 --表示停止将后面的字符以flag对待，比如rm -- -r就是删除-r这个文件而不是进行递归删除 tiling window manager 瓦片窗口管理器，窗口永远平铺，很多使用Lua进行编程 Linux快捷键 ^l：清屏 ^u：删除光标前的全部指令 Linux安装必需的包： gcc 1 2 sudo apt update sudo apt-get install build-essential" /><meta property="og:description" content="Lecture 1 Shell bash中如果想提供一个包含空格的参数，可以用‘或”“把它们引起来，或者用转义字符\，比如My\ Photos来将空格转义 $PATH是环境变量，即在本地文件夹下没有找到对应可以执行的程序时会自动在环境变量的路径中寻找相应的程序。which提示了能够运行本指令的程序路径，比如 1 2 ~$ which echo /bin/echo ls -l表示以详细方式列出当前文件夹下的文件 1 2 missing:~$ ls -l /home drwxr-xr-x 1 missing users 4096 Jun 15 2019 missing 第1个字符表明这个文件的类型。d表示这是一个文件夹，如果是-表示这是一个普通文件，l表示这是一个链接文件，类似于windows下的快捷方式，b表示这是一个块设备文件，一般置于/dev目录下，没有文件大小，只有一个主设备号和辅设备号。块设备是一次传输一整块数据的设备，比如硬盘。c表示这是一个字符设备文件，一般置于/dev目录下，字符设备是一次只传输一个字符数据的设备，比如键盘。p表示这是一个命令管道文件，与shell编程有关，s表示这是一个socks文件，与shell编程有关 d后面有3*3个标志，表示不同的身份对该文件的权限。r表示可读权限，w表示可写权限，x表示可执行权限，-表示无相应权限。第一组表示该文件的所有者的权限，第二组表示文件所有者同组用户的权限，第三组表示其他用户的权限 权限后面的第一个数字表示1. 当这是一个文件时，为硬连接数，即有几个文件硬链接到了这个文件 2. 当这是一个文件夹时，为链接占用的节点，即该目录中包含的子目录的个数 对于一个文件夹来说，为了进入这个文件夹，必须拥有”search”权限，也就是拥有对这个文件夹以及其所有父路径文件夹的x权限。为了ls这个文件夹，必须拥有这个文件夹的r权限 重定向输入输出流：&lt; file将输入设定为文件，&gt; file将结果输出到文件，原先文件的内容会被覆盖 1 2 3 4 5 6 7 8 missing:~$ echo hello &gt; hello.txt missing:~$ cat hello.txt hello missing:~$ cat &lt; hello.txt hello missing:~$ cat &lt; hello.txt &gt; hello2.txt missing:~$ cat hello2.txt hello &gt;&gt;可以来向文件附加数据。|是管道符号，可以将前一个命令的输出作为下一个命令的输入。 1 2 curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=&#39; &#39; -f2 # 查看向google发送HTTP GET请求的头文件中的content length属性的值 文件描述符：一般情况下每个unix命令运行时都会打开3个文件： 标准输入文件(stdin)：文件描述符为0，unix默认从stdin输入数据 标准输出文件(stdout)：文件描述符为1，unix默认向stdout输出数据 标准错误文件(stderr)：文件描述符为2，unix会向stderr流中写入错误消息 默认情况下，command&gt;file将stdout重定向到file，command&lt;file将stdin重定向到file 1 command 2&gt;&gt;file # 将stderr追加到文件末尾// /dev/null文件是一种特殊的文件，写入到它的内容都会被丢弃，也无法从中读取到任何内容，如果希望执行某个命令，但是不希望在屏幕上显示输出结果，可以将输出重定向到/dev/null 1 command &gt;&gt; /dev/null 2&gt;&amp;1 # 屏蔽stdout和stderr command &gt;&gt; /dev/null已经将标准输出重定向，2&gt;&amp;1中的&amp;表示等同，2&gt;表示错误输出，2&gt;&amp;1表示错误输出重定向的对象等同于标准输出重定向的对象，即/dev/null sysfs：Linux内核下基于内存的文件系统，可以将很多内核参数以文件形式暴露，从而可以方便地修改kernel。比如笔记本电脑的屏幕亮度可以以文件的形式在sys/class/backlight下被暴露 1 2 3 4 5 $ sudo find -L /sys/class/backlight -maxdepth 2 -name &#39;*brightness*&#39; /sys/class/backlight/thinkpad_screen/brightness $ cd /sys/class/backlight/thinkpad_screen $ sudo echo 3 &gt; brightness # permission denied，因为&gt;重定向符号之前的sudo并不能被后面观察到，也就是说写入brightness这个操作实际上并没有执行sudo $ echo 3 | sudo tee brightness # success，tee这个命令是获取标准输入，将内容输出成文件，并将其打印到屏幕上 chmod(change mode)来控制用户对文件的权限的命令。只有文件拥有者(owner)和超级用户(super user)可以修改文件或者目录的权限 1 2 3 4 5 6 7 8 chmod [-cfvR] [--help] [--version] mode file... # mode格式为 [ugoa...][[+-=][rwxX]...][,...] # u表示该文件的拥有者，g表示与该文件的拥有者属于同一个group者，o表示其他人，a表示这三者皆是 # +表示增加权限，-表示取消权限，=表示唯一设定权限 # r表示可读取，w表示可写入，x表示可执行，X表示只有当该文件是个子目录或者该文件已经被设定过为可执行 # 示例:将file1.txt设定为所有人皆可读取 chmod ugo+r file1.txt 也可以采用八进制的方法来规定权限 # 权限 rwx 二进制 7 读+写+可执行 rwx 111 6 读+写 rw- 110 5 读+执行 r-x 101 4 只读 r– 100 3 写+执行 -wx 011 2 只写 -w- 010 1 只执行 –x 001 0 无 — 000 1 2 3 4 5 6 # file1.txt这个文件对所有的用户均可读可写可执行 chmod 777 file1.txt # file2.txt这个文件对其他用户只可执行 chmod ug=rwx,o=x file2.txt # 与以下相同 chmod 771 fil2.txt 一般比较常用的是chmod 755和chmod 777 shebang: #! 写在脚本的第一行，用来规定该脚本的解释器。#!后接解释器的绝对路径。比如想要规定这个脚本用sh来执行，那么在第一行添加 1 #!/bin/sh 推荐使用/usr/bin/env python来规定该脚本解释器，这是因为env会在$PATH中查找python解释器的安装位置，这样可以不用提供一个解释器的绝对路径，从而提高程序的可移植性 后台执行shell 在shell命令的最后一个位置加&amp; Lecture 2 Shell Tools and Scripting Shell Scripting Shell是一个用C语言编写的程序，是一种解释性语言。Windows Explorer是一个典型的图形界面shell Bourne Shell /bin/sh或/usr/bin/sh Bourne Again Shell /bin/bash 给变量赋值： 注意在定义变量时变量名不加美元符号，变量名和等号之间不能有空格。在使用一个已经定义过的变量时需要加美元符号 1 2 3 4 5 6 7 8 9 foo=bar # 注意不能是foo = bar，否则bash会认为这是运行了foo命令，并以=和bar作为参数传入 echo &quot;$foo&quot; # prints bar echo &#39;$foo&#39; # or echo &quot;${foo}&quot; # 花括号加不加可选，主要是为了清晰变量名的边界 # prints $foo # 注意在bash中&quot;和‘是不同的。在&#39;中$变量不会被替换，&quot;中$后面的变量会被替换为其值 readonly变量是只读变量，不能被赋值 1 2 myurl=&quot;www.fanxiao.tech&quot; readonly myurl 使用unset命令可以删除变量 获取字符串的长度 1 2 string=&quot;abcd&quot; echo ${#string} # 输出4 提取子字符串 从字符串的第2个字符开始截取四个字符 1 2 string=&quot;runoob is a great site&quot; echo ${string:1:4} # 输出unoo 函数 1 2 3 4 5 # 以shell脚本的名称创建一个文件夹并cd到这个文件夹中 mcd(){ mkdir -p &quot;$1&quot; cd &quot;$1&quot; } $0：脚本本身的名称 $1-$9：脚本的第1-第9个参数 $@：所有脚本的参数 $#：脚本参数的个数 $?：前一个命令的返回代码 $$：当前脚本的PID !!：完整的上一个命令，包括参数。如果一个命令只是因为没有root权限失败，则可以执行sudo !!来重新执行该命令 $_：上一个命令的最后一个参数 数组 数组索引从0开始。用括号()来表示数组，数组元素用空格分开。定义数组的一般形式为 数组名=(值1 值2 值3 值4) 如 1 array_name=(value0 value1 value2) 还可以单独定义数组的各个分量，如array_name[0]=1 读取数组元素值的方式是$(数组名[下标])，使用@则可以获取数组中的所有元素，例如 1 echo ${array_name[@]} 获取数组的长度的方法是 1 length=${array_name[@]} bash基本运算 原生bash不支持简单的数学运算，但是可以通过其他命令实现，比如expr 1 2 val=`expr 2 + 2` # 注意：表达式和运算符之间一定要有空格，例如2+2是不对的，必须写成2 + 2,注意不是单引号而是反引号 echo &quot;两数之和为$val&quot; # 输出为&quot;两数之和为4&quot; 条件表达式要放在方括号之间，并且要有空格，例如 1 2 3 4 5 6 7 8 if [$a == $b] then echo &quot;a等于b&quot; fi if [$a != $b] then echo &quot;a不等于b&quot; fi 关系运算符： 运算符 说明 -eq 检测两个数是否相等，相等则返回true -ne 检测两个数是否不等，不等则返回true -gt 检测左边的是否大于右边的，大于则返回true -lt 检测左边的是否小于右边的，小于则返回true -ge 检测左边的是否大于等于右边的，大于等于则返回true -le 检测左边的是否小于等于右边的，小于等于则返回true ! 非运算 -o 或运算 -a 与运算 注意：乘号前必须要加上反斜杠\转义才是乘法运算 test命令可以用于检查某个条件是否成立 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 数值测试 num1=100 num2=200 if test $[num1] -eq $[num2] then echo &#39;两个数相等&#39; else echo &#39;两个数不相等&#39; fi # 文件测试 cd /bin if test -e ./bash then echo &#39;文件存在&#39; else echo &#39;文件不存在&#39; fi 注意：新的test[[]]比旧的test[]更好，尽量使用[[]] 流程控制：shell编程的流程控制不可为空，即if和else的代码块里必须执行一定的动作 将if和else写成一行的方法： 1 if [ $(ps -ef | grep -c &amp;quot;ssh&amp;quot;) -gt 1]; then echo &quot;true&quot;; fi # 查找当前所有进程中ssh进程的个数，如果大于1则返回true for循环的一般格式 1 2 3 4 5 6 for var in item1 item2 ... itemN do command1 command2 commandN done 写成一行： 1 for var in item1 item2 itemN; do command1; command2; commandN; done; while循环： 1 2 3 4 5 6 7 8 9 10 11 12 int=1 while [ $int -lt 5 ] do echo $int let &quot;int++&quot; # let是bash中用于计算的工具，变量计算中不需要加上$表示变量 done # 运行结果 # 1 # 2 # 3 # 4 # 5 case选择 每个case分支从右圆括号开始，用两个分号;;表示break，跳出整个case...esac语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 echo &#39;输入1到4之间的数字&#39; echo &#39;你输入的数字为&#39; read aNum case $aNum in 1) echo &#39;你选择了1&#39; ;; 2) echo &#39;你选择了2&#39; ;; 3) echo &#39;你选择了3&#39; ;; 4) echo &#39;你选择了4&#39; ;; *) echo &#39;你没有输入1到4之间的任何数字&#39; ;; esac break命令 1 2 3 4 5 6 7 8 9 10 11 12 while true do echo -n &quot;输入1到5之间的数字&quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为$aNum!&quot; ;; *) echo &quot;你输入的数字不是1到5之间的！结束&quot; break ;; esac done shell函数 1 2 3 4 5 6 7 8 9 10 11 [function] funname [()] { action [return int] } # example demoFun(){ echo &quot;第一个shell函数&quot; } demoFun # 调用这个函数 程序的返回值：执行成功返回0，执行失败则返回其他大小的数值。注意，和C语言不同，shell中0表示true，1表示false 获取一个程序的变量值，如$(CMD)会先执行CMD，获取CMD的输出并再相应位置进行替换。比如执行for file in $(ls)，将先执行ls，然后遍历执行ls后获得的返回值 进程替换(process substitution)：&lt;(CMD)将执行CMD，然后将结果输出到一个临时文件，并把&lt;()替换为这个文件名。比如cat &lt;(ls -l)相当于ls -l | cat，diff &lt;(CMD1) &lt;(CMD2)是比较这两个CMD的区别 shell文件包含 包含外部脚本，以封装一些公用的代码作为一个独立文件 1 2 3 . file # 注意.和文件名中间有一个空格 # 或者 source file shell通配符(globbing) wildcard: 使用*或?来进行匹配，比如有foo1、foo2、foo几个文件，rm foo?将删除foo1和foo2，而rm foo*将删除foo1、foo2和foo等三个文件 花括号{用来扩展子字符串 1 2 3 convert image.{png,jpg} # will expand to convert image.png image.jpg Shell Tools tldr: – too long, didn’t read manual cheat sheet for console 寻找文件 find 1 2 3 4 5 6 7 8 9 10 11 12 # 寻找所有名为src的文件夹 find . -name src -type d # 寻找所有路径名中有test文件夹的Python文件 find . -path &#39;*/test/*.py&#39; -type f # 寻找所有在昨天被修改的文件 find . -mtime -l # 寻找所有大小在500k到10M的zip文件 find . -size +500k -size -10M -name &#39;*.tar.gz&#39; # 删除所有.tmp扩展名的文件。-exec表示在find寻找到这些文件之后可以执行的额外动作，\;表示这些额外动作的结束。{}用来指代前面find到的文件 find . -name &#39;*.tmp&#39; -exec rm {} \; # 将所有PNG文件转化为JPG文件 find . -name &#39;*.png&#39; -exec convert {} {}.jpg \; fd是更好的find，支持正则表达式查找 locate是一个使用updatedb更新的数据库进行文件查找的程序，效率比find和fd更高，但是因为是每日更新的，所以并不是最新的。 grep是基于文件内容进行搜索，grep -C是获取匹配内容的上下文(Context)，比如grep -C 5是获取匹配内容的上下各5行内容，grep -R是递归(Recursively)地进入文件夹查找文件中的内容，grep -v用来反向(inversely)选择匹配的内容 rg、ag等也是和grep类似的查找工具，其中ripgrep(rg)是一个查找神器，用来查找代码中的code snippet，可以进行自动递归搜索，自动故忽略.gitignore中的文件和二进制文件，例如 1 rg -t py &quot;import request&quot; 查找所有包含import request的python文件 history可以用来查看shell中的所有交互记录，history | grep find则可以打印出过去曾经使用的find命令 在shell中可以按CTRL+R来进行反向搜索历史，通过键入一个子字符串来搜索过去的命令 fzf是一个模糊搜索工具(fuzzy finder) zsh：一种非常牛逼的shell，可以实现根据历史的命令来进行自动命令建议 fasd是快速跳转路径的工具，可以根据访问频率来自动给出跳转路径的建议 Lecture 3 Vim 快捷键 normal mode下G: 跳转到文件的最后一行 gg跳转到文件的第一行 w：下一个word，bbeginning of word、e：end of word $：跳转到行尾，^跳转到行首 ^u：向上滚动 ^d：向下滚动 h：光标左移 j：光标下移 k：光标上移 l：光标右移 :sp file：水平方向分割窗口，并打开file :vsp file：垂直方向分割窗口，并打开file ^ww：在打开的分割窗口之间切换 /：搜索字符串，按n跳转到下一个匹配，按N跳转到上一个匹配，可以进行/{regex}正则表达式搜索 c：change，即删掉选中的字符，然后进入Insert模式 d：delete，即删掉选中的字符 u：undo ^r: redo v：进入visual模式，可以通过光标移动来进行文本块的选择 .：重复之前的键入 o(open)：在下方键入新行 :n：跳转到第n行 :%d：删除所有行，其中%表示所有行 :2,8d表示删除第2到第8行 modifier: i(inside)或a(around)，比如ci[就是删除[]内的所有字符并进入insert模式，ca(就是删除()内以及()本身这些所有的字符并且进入insert模式 counts: 在命令前面加上数字来表示重复动作，比如3w是向后跳转3个word，5j是向下跳转5行 插件推荐 CtrlP: 一种能够在vim中模糊查找工程文件的vim插件 fugitive.vim: vim的git插件 ale：code linting插件，需要先安装pylint和eslint等linting插件 sudo apt-get install vim-gtk：系统自带vim不支持复制到系统剪切板，需要重装vim 可以安装vim-airline这款主题美化插件 NERDTree目录树，在vim normal模式键入:NERDTree即可打开目录树，:q关闭目录树 在/etc/vim/vimrc最后增加以使vim使用系统剪切板 1 2 3 4 5 6 7 8 &quot; WSL yank support let s:clip = &#39;/mnt/c/Windows/System32/clip.exe&#39; &quot; change this path according to your mount point if executable(s:clip) augroup WSLYank autocmd! autocmd TextYankPost * if v:event.operator ==# &#39;y&#39; | call system(s:clip, @0) | endif augroup END endif Lecture 4 Data Wrangling RegEx +表示前面的字符必须出现一次或者多次 *表示前面的字符可以出现0次、1次或者多次 ?表示前面的字符可以出现0次或1次，加在+和*后面以实现非贪婪匹配 [abc]表示匹配其中的所有abc三个字符 [^abc]表示匹配除了a、b、c之外的其他所有字符 [A-Z]表示一个区间，匹配所有大写字母 [\s]匹配所有空白符 [\S]匹配所有非空白符，[\s\S]匹配所有字符 [\d]，digit，匹配[0-9]的数字，[\D]匹配所有非数字 .匹配除了换行符\n之外的所有字符 [\w]word，匹配字母、数字、下划线，等价于[a-zA-Z0-9_] ()标记一个子表达式的开始和结束位置，子表达式可以获取供以后使用 非捕获元：?:放在()中可以避免匹配被缓存，exp1(?=exp2)正向肯定预查，查找exp2前的exp1，(?&lt;=exp2)exp1查找exp2后的exp1，exp1(?!exp2)查找后面不是exp2的exp1，(?&lt;!exp2)exp1查找前面不是exp2的exp1 只有grep -P才支持 {}限定符表达式，用来表示匹配的长度，比如s{1,3}表示匹配1-3个空格，o{1,}表示匹配1个以上的o ^：定位符，匹配输入字符串开始位置，不要和中括号表达式中的^混淆。$：定位符，匹配输入字符串结束位置 \b：定位符，匹配单词边界 \B：定位符，匹配非单词边界 修饰符：写在正则表达式之外，用于指定额外的匹配策略\pattern\flags i-ignore，不区分大小写 g-global，查找所有的匹配项 m-multiline，多行匹配，使^和$匹配一段文本中每行的开始和结束位置 use case 获取尝试连接远程服务器的用户名 1 ssh myserver &#39;journalctl | grep sshd | grep &quot;Disconnected from&quot;&#39; | less # journalctl是日志管理工具 journalctl和from之间的&#39;&#39;quoting是为了直接在服务器来查找这些内容，再把筛选好的内容传送到本地 sed: stream editor流编辑器，利用命令行对文件进行修改 s命令：substitution，用法：s/REGEX/SUBSTITUTION比如 1 2 3 4 ssh myserver journalctl | grep ssh | grep &quot;Disconnected from&quot; | sed &#39;s/.*Disconnected from //&#39; # 删除所有&#39;Disconnected from&#39; 提取用户名 1 | sed -E &#39;s/.*?Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#39; 排列用户名，列出用户名出现重复的次数 1 2 3 4 5 ssh myserver journalctl | grep sshd | grep &quot;Disconnected from&quot; | sed -E &#39;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#39; | sort | uniq -c 其中sort可以对输入的字符串组进行排序，uniq -c将所有重复的条目去掉，对每个条目只保留一次，并且将每个条目重复的次数打印 对这个重复的次数进行排序，并打印出重复次数最多的前10个条目 1 | sort -nk1,1 | tail -n10 sort -n将会对数字进行排列，-k1,1表明只对以空白键分割的第一列进行排序 将以上筛选出的用户名以逗号分隔，打印成一行输出 1 | awk &#39;{print $2}&#39; | paste -sd, paste -s可以将多行合并为一行，-d,表明分隔符delimiter是,。 awk是一种文字流处理编程语言，与sed、grep合并成为Linux三剑客，sed擅长对一行进行处理以及进行替换，grep擅长查找，awk擅长对列进行处理 筛选出所有只出现过一次的名称以c开头e结尾的用户名并统计数量 1 | awk &#39;$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ {print $2}&#39; | wc -l xargs：将找到的文本作为命令行的参数 1 rustup toolchain list | grep nightly | grep -vE &quot;nightly-x86&quot; | sed &#39;s/-x86.*//&#39; | xargs rustup toolchain uninstall 有的命令可以接受标准输入作为参数，比如grep，这样就可以使用管道命令|，比如cat /etc/passwd | grep root相当于grep root /etc/passwd，但是大多数命令不接受标准输入作为参数，只能直接在命令行输入参数，比如echo，因此xargs就是将标准输入转为命令行参数，比如 1 2 $ echo &quot;hello world&quot; | xargs echo hello world xargs的默认命令是echo，即xargs=xargs echo http://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html 对二进制的wrangling 用ffmpeg来从摄像头捕获图像，转化为灰度图，压缩，通过ssh发送到远程服务器并在远程服务器上解压，复制并展示 1 2 ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 - | convert - -colorspace gray - | gzip | ssh mymachine &#39;gzip -d | tee copy.jpg | env DISPLAY=:0 feh -&#39; Exercise 查找/usr/share/dict/words下含有至少3个a并且不以’s结尾的单词的个数 1 grep -P &quot;(.*a){3,}.*(?&lt;!&#39;s)$&quot; /usr/share/dict/words | wc -l 其中grep -P是以perl语法输入正则表达式，以开启?&lt;! 结尾出现频率最高的两个字母是什么？ 找出前三名 1 grep -P &quot;(.*a){3,}.*(?&lt;!&#39;s)$&quot; /usr/share/dict/words | sed -E &#39;s/.*(\w\w)/\1/g&#39; | uniq -c | sort -nk1,1 | tail -n3 Lecture 5 Command Line Environment Job control UNIX使用signal来和进程进行通信，signal起到中断作用 ^C向进程发出SIGINT指令，^\向进程发出SIGQUIT指令。程序会产生core文件，相当于程序错误，kill -TERM &lt;PID&gt;向进程发出SIGTERM指令，该信号可以被阻塞和处理，通常用来要求程序自己正常退出，SIGSTOP是暂停进程 下述python指令将忽略^C的SIGINT指令 1 2 3 4 5 6 7 8 9 10 11 12 #!/usr/bin/env python import signal, time def handler(signum, time): print(&quot;\nI got a SIGINT, but I am not stopping&quot;) signal.signal(signal.SIGINT, handler) # attach SIGINT to handler i = 0 while True: time.sleep(.1) print(&quot;\r{}&quot;.format(i), end=&quot;&quot;) i += 1 ^Z向shell发出一个SIGTSTP来暂停一个进程，使用fg或bg命令来把暂停的进程放在前台或者后台运行，比如bg %1 jobs用来列出所有当前终端对话尚未完成的任务，可以使用pgrep来获取这些任务的PID，也可以使用%1、%2等获取对这些任务的引用 可以在所有任务的最后增加一个&amp;后缀来使命令跑在后台 直接kill %1来终止第1个任务 Terminal Multiplexers tmux可以在一个终端窗口下使用多个pane和tab keybinding: 默认情况下是^b。 Session：独立的工作区， tmux：来启动一个新的session tmux new -s NAME：启动一个指定了名称的session tmux ls：列出现在的所有session 在tmux里按下^b d来从当前的session中detach tmux a来attach到上一个session Windows：相当于浏览器中的tab，属于同一个session ^b ccreate一个新的窗口，通过^d来关闭这个窗口 ^b N前往第N个窗口，N为数字 ^b p前往前一个窗口 ^b n前往下一个窗口 Panes：相当于vim中的split界面 ^b &quot;水平分割窗口，^d退出当前窗口 ^b %垂直分割窗口 ^b &lt;arrow&gt;跳转窗口 ^b &lt;space&gt;在不同的窗口设计中选择 Aliases 命令的代换(aliasing) 1 alias alias_name=&quot;command_to_alias arg1 arg2&quot; 注意=左右两边没有空格 e.g. 1 2 3 4 alisa ll=&quot;ls -lh&quot; alias gs=&quot;git status&quot; alias gc=&quot;git commit&quot; alias v=&quot;vim&quot; 上述alias命令在shell关闭之后会自动重设，可以在.bashrc或者.zshrc中写入相关的alias来使设置永久有效 Dotfiles 很多程序使用纯文本文件dotfile来对程序进行配置，比如.vimrc，这些文件默认隐藏在目录中。对bash程序来说，.bashrc或.bash_profile是默认配置bash设置的文件。在很多程序中要求dotfile指定一个二进制可执行文件的路径 1 export PATH=&quot;$PATH:/path/to/program/bin&quot; 可以将所有的dotfile放在一个文件夹下，进行版本控制，并且symlink它们，这样可以方便在不同的机器上将自定义的设置进行迁移 可以参考github上一些比较受欢迎的dotfile repo，例如https://github.com/mathiasbynens/dotfiles 为了提高dotfile的可移植性，可以在dotfile中增加一些条件判断语句，例如 1 2 3 4 5 6 7 if [[ &quot;$(uname)&quot; == &quot;Linux&quot; ]]; then {do_something}; fi # Check before using shell-specific features if [[ &quot;$SHELL&quot; == &quot;zsh&quot; ]]; then {do_something}; fi # You can also make it machine-specific if [[ &quot;$(hostname)&quot; == &quot;myServer&quot; ]]; then {do_something}; fi 如果想让zsh和bash使用同一个alias配置，可以在.bashrc和.zshrc文件中加入相同的 1 2 3 if [ -f ~/.aliases ]; then source ~/.aliases fi p.s. source &lt;filename&gt;和./&lt;filename的区别在于source是直接在当前SHELL session中执行的，而./是新起了一个session Remote machines SSH(secure shell) 1 ssh user@ip_address|url_of_server [command] # [command]表示在远程服务器中执行这个命令，然后返回到本地服务器 SSH config: 客户端SSH配置文件/etc/ssh/ssh_config。服务端SSH配置文件/etc/ssh/sshd_config SSH keys：SSH服务器持有公钥，客户端持有私钥，这样就不需要每次SSH到服务器时重新键入密码了。SSH key passphrase是为了防止别人持有你的私钥采用的加密措施 通过SSH来复制文件 最简单的方法是：ssh+tee，e.g. cat localfile | ssh remote_server tee serverfile tee和cat正好相反，tee用于读取标准输入，将其内容输出成文件，而cat用于读取文件，将其输出成标准输出 secure copy scp：可以recurse over path，scp path/to/local_file remote_host:path/to/remote_file rsync是scp基础上的提升，可以检测到本地和远程文件的相同文件，并不对它们进行重复复制。rsync的语法和scp类似 SSH port forwarding端口转发 如果在本地的应用向某个被绑定的端口发送数据，则这些数据将自动通过SSH被转发到远程服务器的另一个被绑定端口并做本地调用 Dynamic Tunneling (SOCKS proxy) 1 ssh -D 8080 remote_server 在192.168.56.101的浏览器中输入http://localhost时，这个http request会被发送到8080端口，但是由于SOCKS Proxy在8080端口监听，并把这个HTTP request转发给了SSH Client，SSH Client通过SSH将这个HTTP request发送给了102的SSH服务器，102在本地解析运行这个HTTP请求，由于HTTP默认使用80端口，如果102有apache绑定在其80端口上提供服务的话，那么apache服务器将接受这个对localhost的访问请求，返回相应的web服务页面 local port forwarding 1 ssh -L &lt;local port&gt;:&lt;remote hostname&gt;:&lt;remote service port&gt; user@remoteserver 比如 1 ssh -L 8000:localhost:80 ramki@192.168.56.102 client端绑定了8000端口，任何发送到8000端口的数据都将通过SSH客户端通过22端口发送到SSH服务端，由于绑定了远程服务器的80端口，因此远程服务端将把22端口的数据转发到80端口上。在dynamic tunneling模式中，服务器会检查packet并自动决定该packet发往哪个端口，比如HTTP request发往80端口，SMTP发往25端口，但是local port forwarding将发往指定的端口 remote port forwarding 1 ssh -R &lt;remote port&gt;:&lt;local hostname&gt;:&lt;local port&gt; user@remoteserver 把所有尝试发送到远程服务器指定端口的数据从&lt;local hostname&gt;的&lt;local port&gt;发送 Exercise 写一个脚本，以实现wait [PID]的功能 1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash while : do kill -0 $1 # $1 为脚本后面跟的第一个参数，也就是PID。kill -0是尝试杀这个进程，如果这个进程不存在就会返回1，否则返回0，但是不会实际去杀掉这个进程 if [[ $? -ne 0 ]] then break fi sleep 1 done ls -al Lecture 6 Version Control Git data model 文件：blob，本质是array&lt;byte&gt; 目录：tree，本质是map&lt;string, blob | tree&gt; 快照(snapshot)：也被称为commits，本质是被追踪的最高一级tree (root)。commits无法被改变 1 2 3 4 5 6 type commit = struct { parent: array&lt;commit&gt; author: string // metadata message: string // metadata snapshot: tree } 历史：DAG(directed acyclic graph) of snapshots，每个历史中的snapshot都指向它们的父节点，父节点可以不止一个，因为当merge的时候就会出现两个父节点 1 2 3 4 o &lt;-- o &lt;-- o &lt;-- o &lt;---- o ^ / \ v --- o &lt;-- o 对象(object)：type object = blob | tree | commit 所有对象都用SHA-1 hash来引用 1 2 3 4 5 6 7 8 objects = map&lt;string, object&gt; def store(object): id = sha1(object) objects[id] = object def load(id): return objects[id] git cat-file &lt;SHA1&gt;就相当于上面的load(id)函数 引用(reference)：对commit的指针(比如master)，由于commit是SHA-hash码，人类难以记住，因此使用reference这种人类可读的字符串来指向commit，reference是可以改变的，即可以更改指向的commit。 1 2 3 4 5 6 7 8 9 10 11 12 13 references = map&lt;string, string&gt; def update_reference(name, id): references[name] = id def read_reference(name): return reference[name] def load_reference(name_or_id): if name_or_id in references: // is name return load(references[name_or_id]) else: // is id return load(name_or_id) HEAD：一个特殊的reference，用于指向我们目前看的commit 仓库(repository)：objects和references的集合 所有的git命令都是通过加入object和加入/更新references来对DAG进行操作 Git command-line interface 基础命令 git init：创建一个新的git仓库，数据存储在.git文件夹中 git status：查看目前git的状态 git add &lt;filename&gt;：将文件添加到staging area git commit：增加一个新的commit git commit -a表示automatically将所有之前已经追踪过的文件进行git add，从而省去git add的步骤 git log --all --graph --decorate：将git历史以DAG展现出来 git log -p -2显示历史中的最后2个commit的差异(patch) git log --pretty=oneline：将每个commit的信息用一行显示 过滤输出：git log --since=2.weeks：仅打印过去2周到现在的所有commit历史 --grep可以在commit信息中查找关键词进行输出过滤 git log -S function_name：只显示最后一个修改了某个特定函数的commit git log -- path/to/file：显示修改了这个文件的commit git diff &lt;filename&gt;：显示某个working directory中的文件和staging area中的差异 git diff --staged：显示在staging area中的文件和上次commit中的文件的差异 git diff &lt;version&gt; &lt;filename&gt;：显示某个文件不同commit中的差异 git checkout &lt;version&gt;：将HEAD移动到这个版本的commit git rm &lt;filename&gt;：相当于删除某个文件，并从staging area中将其删除(但是还没有commit) 如果想要在工作区中保留这个文件，但是从staging area中将其删除，使用git rm --cached &lt;filename&gt;，比如git rm log/\*.log可以删除所有log/目录下的.log后缀的文件，注意要在*前加一个\号 git tag：显示所有标签，git tag -l &quot;v1.8.6*&quot;显示所有1.8.6版本系列的标签 为某一个commit创建一个新的annotated tag（一次正式的发布，包含了创建日期、名称和邮箱、GPG签名等信息）：git tag -a v1.4 -m &quot;my version 1.4&quot; &lt;shachecksum&gt; 创建一个新的lightweight tag（仅仅是为一个commit对象起了一个别名，不包含任何其他信息）：git tag &lt;tag name&gt; 默认情况下git push时不会将tag推送到远程，可以采用git push origin --tags来将tag推送 git tag -d &lt;tag name&gt;删除某个标签 分支和合并命令 git branch：显示目前所有的分支 git branch &lt;name&gt;：创建一个新的分支 git branch -d &lt;name&gt;：删除某个分支 git checkout -b &lt;name&gt;：创建一个新的分支并且切换到这个分支，相当于git branch &lt;name&gt;; git checkout &lt;name&gt;，可以用git switch -c &lt;name&gt;代替 git merge &lt;revision&gt;：将&lt;revision&gt;合并到当前分支 git mergetool：使用合并工具来帮助处理合并冲突 git rebase：也可以达到合并分支的效果，但是和merge不同的是分叉会被取消 git merge：origin和mywork产生了分叉 git rebase：没有分叉，Commit5’和6‘以补丁的形式存在，放在./git/rebase目录中 远程命令 origin是默认的被克隆的远程名称（不是分支名，origin的master分支为origin/master)，被track的上游远程分支可以以@{upstream}或@{u}指代 git remote：显示所有已知的远程，增加一个-vflag来显示远程仓库的URL，或者git remote show &lt;remote&gt;来显示更多信息 git remote add &lt;name&gt; &lt;url&gt;：增加一个新的远程 git remote rm &lt;name&gt;：删除某个远程 git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;：将objects发送到远程分支，并且更新远程分支的reference git push &lt;remote&gt; --delete &lt;remote branch&gt;：删除远程分支 git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;：设置本地branch和远程branch的连接关系，从而可以直接进行git push而不需要指定远程branch git branch -vv查看目前正在追踪的远程分支 git fetch：从远程项目拉取所有的objects/reference，但是并不merge到working directory中，对working directory没有任何影响 git pull：相当于git fetch; git merge git clone：从远程分支下载repo，将本地的master分支追踪远程的master分支(本地分支和远程分支存在连接关系，运行git push时本地分支将知道push到哪个远程分支) git rebase：将一个分支rebase到另一个分支上，这样可以使分叉的commit变成线性的 撤销命令 所有的commit大概率是可以被恢复的，但是没有被commit的snapshot很难被恢复 git commit --amend：修改commit的内容 比如 1 2 3 git commit -m &#39;Initial commit&#39; git add forgotton_file git commit --amend 最终只有一个initial commit，里面包括了forgotton_file git reset HEAD &lt;file&gt;：把文件从staging area撤出，但是不会修改文件 也可以使用git restore --staged &lt;file&gt; git restore &lt;file&gt;则是将还未stage的文件恢复到上一次commit时的状态 git checkout -- &lt;file&gt;：把文件在工作区的修改全部撤销，撤销到最近一次git commit或git add的状态。当文件自修改后还没有放到暂存区时，使用本命令将回到和版本库相同的状态（但git还是知道修改的），当文件已经添加到暂存区，并且又做了修改之后，则回到添加到暂存区时的状态。 高级命令 git config：配置git，分成三个层面的配置，包括系统级别、用户级别、仓库级别 git config --system -l查看系统配置，配置文件存储于[path]/etc.gitconfig git config --global -l查看用户配置，配置文件存储于~/.gitconfig或~/.config/git/config文件 git config --local -l查看仓库配置，配置文件存储于[repo]/.git/config 优先级：仓库配置&gt;用户配置&gt;系统配置 设置main为默认的分支名：git config --global init.defaultBranch main git clone --depth=1：浅克隆，将忽略之前所有的版本历史 git add -p：交互式添加到暂存区，能够方便地将一个文件中的部分内容添加到暂存区 git rebase -i：interactive rebasing git blame：显示哪个用户编辑了哪一条 git stash：将目前还不想提交但是已经修改的内容（包括工作区和暂存区）保存到堆栈中，后续可以在某个分支上恢复出堆栈的内容。git stash pop将堆栈中的内容弹出到当前分支上，堆栈内容被删除，而git stash apply则将堆栈中的内容应用到当前分支上，和git stash pop不同的是堆栈中的内容并不会被删除，适用于应用到多个分支的情况 .gitignore：指定不需要track的文件 Git workflow https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow 软件开发的workflow，规定了分支的类型和怎样合并分支 master分支：软件的release版本分支 develop分支：开发分支 feature分支：每个单独的feature作为一个分支，以develop作为父分支 推荐阅读：pro git Lecture 7 Debugging and Profiling Logging Linux终端显示不同的颜色，使用ANSI escape颜色码 echo -e &quot;\e[1;31mThis is red\e[0m&quot; 显示红色的This is red echo -e &quot;\e[1;42mGreen Background\e[0m&quot;显示绿色背景的Green Background 大多数程序将日志文件存放在/var/log目录下，systemd是一个system的daemon程序，将所有系统日志存放在var/log/journal下，可以用journalctl来查看 logger &quot;logging info&quot;可以将log记录到journal中 Debugging pdb：python debugger s(tep)：单步执行，相当于step into n(ext)：单步执行，相当于step over l(ist)：列出执行到的那行代码的前后十一行 c(ontinue)：继续执行，直到遇到下一条断点 b(reakpoint)：设置断点 cl(ear)：清除断点 r(eturn)：执行当前运行函数直到结束 p(rint) &lt;expression&gt;：输出expression的值 q(uit)：退出debugger restart：重新debug 使用python -m pdb &lt;filename.py&gt;来进行pdb调试，其中-m表示将模块(module)当作脚本运行，也就是将pdb当作脚本运行 gdb(GNU debugger)：C/C++ debugger，也支持Go和Rust调试，用法和pdb类似 静态代码分析：无需用编译器编译运行即可扫描出代码错误 pyflakes是python的静态扫描工具，shellcheck可以对shell scripts进行扫描 code linting：在编译前即标出警告和错误的位置 一些linter推荐： https://github.com/caramelomartins/awesome-linters#cc Profiling 获取程序运行的资源占用以及时间信息 Timing Real time: 真实时间，包括了被其他进程占用的时间和等待I/O以及网络的时间 User time: 用户时间，即CPU运行用户代码所花费的时间 Sys time: 系统时间，即CPU运行kernal代码所花费的时间 time &lt;command&gt;可以计算上述三个时间 CPU profiler 最常见的profiler，两种类型： tracing profiler: 记录每个函数调用 sampling profiler：周期性地对程序采样，记录程序的堆栈 对于python程序，使用cProfile来作为profiler python -m cProfile -s tottime &lt;filename.py&gt; 但是由于cProfiler将所有内部调用函数的开销都统计在内，很难看出真正把时间都花在了哪里，因此可以使用line_profiler来统计每一行代码所花费的时间，这样更加直观，需要添加一个decorator @profile来声明需要进行profiling的函数 可以使用flame graph来将CPU profiling可视化 memory profiler 内存泄漏：即使在不需要用到这些内存的时候也不将其释放，在没有垃圾收集的语言，比如C/C++中可以使用valgrind来显示内存泄漏，python可以使用memory_profiler来进行memory profiling 函数调用图：python中可以选择pycallgraph来显示哪个函数调用了哪个 resource monitoring htop：top的升级版，来观察系统资源使用情况 free：观察系统可用内存使用情况 df：当前文件夹中磁盘使用情况 nethogs/iftop/ss：网络使用情况 hyperfine：对程序进行快速benchmark，例如比较fd和find的速度 1 hyperfine --warmup 3 &#39;fd -e jpg&#39; &#39;find . -iname &quot;*.jpg&quot;&#39; Lecture 8 Metaprogramming Build systems 将依赖编译构建为二进制文件的流程需要用到build systems，比如make 定义： 依赖(dependency) 目标(target) 构建规则(rule) 在某个目录下执行make时，make将会查找该目录下的Makefile，示例如下所示 1 2 3 4 5 6 7 8 # this is comment @# @ is to turn off the echoing of comment # .ONESHELL: paper.pdf: paper.tex plot-data.png pdflatex paper.tex plot-data.png plot-%.png: %.dat plot.py ./plot.py -i $*.dat -o $@ 冒号左边是需要构建的目标文件，冒号右边是依赖文件，下面一行是构建规则,，注意每行命令在单独的shell中执行，这些shell之间没有继承关系，除非将几行命令写在一行中，中间用分号分割，或者加上.ONESHELL:命令，每一个这样的组合构成了一个directive %是一个样式，匹配任意字符串，如果需要构建的是plot-data.png，那么就会去寻找data.dat这个依赖文件 $@是目前的target 目标文件如果已经构建成功，而依赖文件没有作任何更新，那么再执行make将不会有任何动作，如果某个依赖文件更新，那么只对和该依赖文件有关的编译动作进行重新编译。 除了文件名，目标还可以是某个操作的名字，称为伪目标，比如make clean不是make一个叫做clean的文件，而是删除对象文件，因此要把clean声明为伪目标 1 2 3 .PHONY: clean clean: rm *.o temp make install将可执行文件复制到正确的路径，即被复制到某个PATH包含的路径 Dependency management 有多种不同的依赖： 依赖程序：例如python 依赖系统包(system packages)：例如openssl 编程语言中的库(library)：例如matplotlib 仓库：管理各种依赖的地方，比如ubuntu中的apt、Ruby中的gem、Python中的pip以及nodejs中的npm versioning：对软件版本控制 semantic versioning: major.minor.patch patch：新的版本不改变API，增加patch# minor：如果对API的改变是向后兼容的，增加minor# major：如果对API的改变不向后兼容，增加major# lock file：列出所有依赖的版本信息的文件，需要手动对依赖库中的软件进行升级 vendoring：将所有依赖的源代码复制到项目中，来获得对依赖的完全控制权 Continuous Integration System (CI) 持续集成，即一旦进行了源代码的commit，即进行自动编译测试，将代码集成到主干，从而尽快发现错误，防止分支大幅偏离主干 比较多的CI工具包括Travis CI、Azure Pipelines和Github Actions CI是事件触发，一旦被触发，CI将起一个虚拟机，在其中运行用户规定的recipe所需要执行的命令。GitHub Pages就是一个CI系统，每次md文件被commit到repo后jekyll就会将其编译为HTML并deploy到服务器上 git本身就是一个简单的CI系统，在.git/hooks下有一些事件触发的脚本，比如pre-commit.sample,在commit时被触发 测试 test suite：所有测试的集合 unit test：单元测试，对某一个feature进行单独测试 integration test：集成测试，对各个单元继续联合测试 regression test：回归测试，对之前所有产生bug的条件进行测试从而保证相同的bug不再出现 mocking：用一个假的Implementation来代替一个功能模块来实现对其他依赖于此模块的其他模块进行测试 Lecture 9 Security and Cryptography Hash functions 将一个任意长度的bytes array映射到一个固定长度的byte 其中一种Hash function是SHA1，生成160位输出(40个16进制字符) 可以使用sha1sum命令来输出一个文件的SHA1哈希值 哈希函数有以下的特性： deterministic：相同的输入总是生成相同输出 non-invertible：已知输出，很难得到输入 collision resistant：两个不同的输入很难得到相同的输出 Key Derivation Functions (KDF) 本质上属于Hash函数 给一个passphrase(相当于用户的password)，生成一个固定长度的key，通常KDF相当缓慢，为了防止brute force破解密码 KDF可以用于存储网站密码，比如生成一个随机的salt，然后存储salt以及KDF(password+salt)，用重新生成KDF(password+salt)来验证每次的登陆尝试 Symmetric cryptography 对称加密的过程： 1 2 3 keygen() -&gt; key # 随机生成一个key，通信双方交换这个key，key需要保密 encrypt(plaintext, key) -&gt; ciphertext decrypt(ciphertext, key) -&gt; plaintext 对称加密的特性： 即便拥有ciphertext，没有key的情况下也无法得到plain text 显然正确性，即decrypt(encrypt(message, key), key) = message 比较著名的对称加密算法：AES Asymmetric cryptography 非对称加密，有一个公钥，不需要保密，还有一个私钥，自己保存，需要保密。这样可以解决对称加密中需要交换密钥的问题 非对称加密的过程： 1 2 3 keygen() -&gt; (public key, private key) encrypt(plaintext, public key) -&gt; ciphertext decrypt(ciphertext, private key) -&gt; plaintext 非对称加密可以用于签名/验证过程： 1 2 sign(message, private key) -&gt; signature verify(signature, message, public key) -&gt; &lt;bool&gt;is_signature 非对称加密的应用： PGP邮件加密 私人通信频道 公钥分发：如何确认别人得到的公钥确实是我们给他们的公钥？ 著名的非对称算法：RSA算法 GPG(GNU Private Guard)是一个使用RSA算法对文件进行加密的软件 使用方法：https://www.digitalocean.com/community/tutorials/how-to-use-gpg-to-encrypt-and-sign-messages case study Two-Factor Authentication (2FA)：用一个passphrase和某个authenticator(授权文件或物理设备，如YubiKey)来防止passphrase的泄露 磁盘加密：使用对称加密，需要passphrase，Linux上可以使用cryptsetup+LUKS，Windows上可以使用BitLocker SSH：ssh-keygen是非对称加密，生成一个公钥和密钥，密钥采用KDF进行对称加密，因此需要一个passphrase。服务器需要知道公钥，私钥保存在本地。服务器先选一个随机的信息发送给client，要求client对该信息进行签名，client将该信息签名之后发送给server，server通过公钥验证该签名 Lecture 10 Miscellaneous Daemons 守护进程，开机自动运行在后台的进程，这些进程一般后缀都有一个d，比如sshd就是SSH的守护进程，负责监听SSH请求。systemd是linux的系统守护进程，负责运行和设置守护进程，可以运行systemctl status来列出当前正在运行的daemon。可以使用cron来定时运行守护进程 FUSE (Filesystem in User SpacE) 用户空间文件系统，即用户可以通过FUSE在用户空间定制实现自己的文件系统而不必在内核态 fuse_user是开发的用户态的文件系统程序，该程序启动的时候会将自己开发的接口注册到fuse中，比如读写文件的接口，遍历目录的接口等等。 同时，通过该程序在系统某个路径挂载fuse文件系统，比如/tmp/file_on_fuse_fs。此时如果在该目录中有相关操作时，请求会经过VFS到fuse的内核模块（上图中的步骤1），fuse内核模块根据请求类型，调用用户态应用注册的函数（上图中步骤2），然后将处理结果通过VFS返回给系统调用（步骤3）。 SSHFS就是一个FUSE文件系统，可以通过SSH链接在本地打开远程服务器的文件/文件夹 API 大多数的线上服务有可以让你通过编程获取一定形式的API，这些API都有固定结构的URL，经常是以api.service.com为root 很多API会要求一个token来获取服务，可以通过OAuth这个协议来获取token token和密码是不同的，token是短期的，到期自动失效，也可以被数据所有者撤销，且有权限范围 Command Line flags/patterns 大多数命令行有类似的flag，比如： dry run：只会打印出如果不在dry run模式下的结果，但实际上什么修改都不会进行 --verbose或-v：打印详细内容，-vvv打印更详细的内容，--quiet打印简短的内容 -代替文件名表示标准输入输出 --表示停止将后面的字符以flag对待，比如rm -- -r就是删除-r这个文件而不是进行递归删除 tiling window manager 瓦片窗口管理器，窗口永远平铺，很多使用Lua进行编程 Linux快捷键 ^l：清屏 ^u：删除光标前的全部指令 Linux安装必需的包： gcc 1 2 sudo apt update sudo apt-get install build-essential" /><link rel="canonical" href="https://tommyfan34.github.io/posts/MIT-6-null-notes/" /><meta property="og:url" content="https://tommyfan34.github.io/posts/MIT-6-null-notes/" /><meta property="og:site_name" content="Xiao Fan (樊潇)" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-01-14T18:32:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="MIT 6.null Lecture Notes" /><meta name="twitter:site" content="@tommyfan34" /><meta name="twitter:creator" content="@Xiao Fan" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Xiao Fan"},"description":"Lecture 1 Shell bash中如果想提供一个包含空格的参数，可以用‘或”“把它们引起来，或者用转义字符\\，比如My\\ Photos来将空格转义 $PATH是环境变量，即在本地文件夹下没有找到对应可以执行的程序时会自动在环境变量的路径中寻找相应的程序。which提示了能够运行本指令的程序路径，比如 1 2 ~$ which echo /bin/echo ls -l表示以详细方式列出当前文件夹下的文件 1 2 missing:~$ ls -l /home drwxr-xr-x 1 missing users 4096 Jun 15 2019 missing 第1个字符表明这个文件的类型。d表示这是一个文件夹，如果是-表示这是一个普通文件，l表示这是一个链接文件，类似于windows下的快捷方式，b表示这是一个块设备文件，一般置于/dev目录下，没有文件大小，只有一个主设备号和辅设备号。块设备是一次传输一整块数据的设备，比如硬盘。c表示这是一个字符设备文件，一般置于/dev目录下，字符设备是一次只传输一个字符数据的设备，比如键盘。p表示这是一个命令管道文件，与shell编程有关，s表示这是一个socks文件，与shell编程有关 d后面有3*3个标志，表示不同的身份对该文件的权限。r表示可读权限，w表示可写权限，x表示可执行权限，-表示无相应权限。第一组表示该文件的所有者的权限，第二组表示文件所有者同组用户的权限，第三组表示其他用户的权限 权限后面的第一个数字表示1. 当这是一个文件时，为硬连接数，即有几个文件硬链接到了这个文件 2. 当这是一个文件夹时，为链接占用的节点，即该目录中包含的子目录的个数 对于一个文件夹来说，为了进入这个文件夹，必须拥有”search”权限，也就是拥有对这个文件夹以及其所有父路径文件夹的x权限。为了ls这个文件夹，必须拥有这个文件夹的r权限 重定向输入输出流：&lt; file将输入设定为文件，&gt; file将结果输出到文件，原先文件的内容会被覆盖 1 2 3 4 5 6 7 8 missing:~$ echo hello &gt; hello.txt missing:~$ cat hello.txt hello missing:~$ cat &lt; hello.txt hello missing:~$ cat &lt; hello.txt &gt; hello2.txt missing:~$ cat hello2.txt hello &gt;&gt;可以来向文件附加数据。|是管道符号，可以将前一个命令的输出作为下一个命令的输入。 1 2 curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=&#39; &#39; -f2 # 查看向google发送HTTP GET请求的头文件中的content length属性的值 文件描述符：一般情况下每个unix命令运行时都会打开3个文件： 标准输入文件(stdin)：文件描述符为0，unix默认从stdin输入数据 标准输出文件(stdout)：文件描述符为1，unix默认向stdout输出数据 标准错误文件(stderr)：文件描述符为2，unix会向stderr流中写入错误消息 默认情况下，command&gt;file将stdout重定向到file，command&lt;file将stdin重定向到file 1 command 2&gt;&gt;file # 将stderr追加到文件末尾// /dev/null文件是一种特殊的文件，写入到它的内容都会被丢弃，也无法从中读取到任何内容，如果希望执行某个命令，但是不希望在屏幕上显示输出结果，可以将输出重定向到/dev/null 1 command &gt;&gt; /dev/null 2&gt;&amp;1 # 屏蔽stdout和stderr command &gt;&gt; /dev/null已经将标准输出重定向，2&gt;&amp;1中的&amp;表示等同，2&gt;表示错误输出，2&gt;&amp;1表示错误输出重定向的对象等同于标准输出重定向的对象，即/dev/null sysfs：Linux内核下基于内存的文件系统，可以将很多内核参数以文件形式暴露，从而可以方便地修改kernel。比如笔记本电脑的屏幕亮度可以以文件的形式在sys/class/backlight下被暴露 1 2 3 4 5 $ sudo find -L /sys/class/backlight -maxdepth 2 -name &#39;*brightness*&#39; /sys/class/backlight/thinkpad_screen/brightness $ cd /sys/class/backlight/thinkpad_screen $ sudo echo 3 &gt; brightness # permission denied，因为&gt;重定向符号之前的sudo并不能被后面观察到，也就是说写入brightness这个操作实际上并没有执行sudo $ echo 3 | sudo tee brightness # success，tee这个命令是获取标准输入，将内容输出成文件，并将其打印到屏幕上 chmod(change mode)来控制用户对文件的权限的命令。只有文件拥有者(owner)和超级用户(super user)可以修改文件或者目录的权限 1 2 3 4 5 6 7 8 chmod [-cfvR] [--help] [--version] mode file... # mode格式为 [ugoa...][[+-=][rwxX]...][,...] # u表示该文件的拥有者，g表示与该文件的拥有者属于同一个group者，o表示其他人，a表示这三者皆是 # +表示增加权限，-表示取消权限，=表示唯一设定权限 # r表示可读取，w表示可写入，x表示可执行，X表示只有当该文件是个子目录或者该文件已经被设定过为可执行 # 示例:将file1.txt设定为所有人皆可读取 chmod ugo+r file1.txt 也可以采用八进制的方法来规定权限 # 权限 rwx 二进制 7 读+写+可执行 rwx 111 6 读+写 rw- 110 5 读+执行 r-x 101 4 只读 r– 100 3 写+执行 -wx 011 2 只写 -w- 010 1 只执行 –x 001 0 无 — 000 1 2 3 4 5 6 # file1.txt这个文件对所有的用户均可读可写可执行 chmod 777 file1.txt # file2.txt这个文件对其他用户只可执行 chmod ug=rwx,o=x file2.txt # 与以下相同 chmod 771 fil2.txt 一般比较常用的是chmod 755和chmod 777 shebang: #! 写在脚本的第一行，用来规定该脚本的解释器。#!后接解释器的绝对路径。比如想要规定这个脚本用sh来执行，那么在第一行添加 1 #!/bin/sh 推荐使用/usr/bin/env python来规定该脚本解释器，这是因为env会在$PATH中查找python解释器的安装位置，这样可以不用提供一个解释器的绝对路径，从而提高程序的可移植性 后台执行shell 在shell命令的最后一个位置加&amp; Lecture 2 Shell Tools and Scripting Shell Scripting Shell是一个用C语言编写的程序，是一种解释性语言。Windows Explorer是一个典型的图形界面shell Bourne Shell /bin/sh或/usr/bin/sh Bourne Again Shell /bin/bash 给变量赋值： 注意在定义变量时变量名不加美元符号，变量名和等号之间不能有空格。在使用一个已经定义过的变量时需要加美元符号 1 2 3 4 5 6 7 8 9 foo=bar # 注意不能是foo = bar，否则bash会认为这是运行了foo命令，并以=和bar作为参数传入 echo &quot;$foo&quot; # prints bar echo &#39;$foo&#39; # or echo &quot;${foo}&quot; # 花括号加不加可选，主要是为了清晰变量名的边界 # prints $foo # 注意在bash中&quot;和‘是不同的。在&#39;中$变量不会被替换，&quot;中$后面的变量会被替换为其值 readonly变量是只读变量，不能被赋值 1 2 myurl=&quot;www.fanxiao.tech&quot; readonly myurl 使用unset命令可以删除变量 获取字符串的长度 1 2 string=&quot;abcd&quot; echo ${#string} # 输出4 提取子字符串 从字符串的第2个字符开始截取四个字符 1 2 string=&quot;runoob is a great site&quot; echo ${string:1:4} # 输出unoo 函数 1 2 3 4 5 # 以shell脚本的名称创建一个文件夹并cd到这个文件夹中 mcd(){ mkdir -p &quot;$1&quot; cd &quot;$1&quot; } $0：脚本本身的名称 $1-$9：脚本的第1-第9个参数 $@：所有脚本的参数 $#：脚本参数的个数 $?：前一个命令的返回代码 $$：当前脚本的PID !!：完整的上一个命令，包括参数。如果一个命令只是因为没有root权限失败，则可以执行sudo !!来重新执行该命令 $_：上一个命令的最后一个参数 数组 数组索引从0开始。用括号()来表示数组，数组元素用空格分开。定义数组的一般形式为 数组名=(值1 值2 值3 值4) 如 1 array_name=(value0 value1 value2) 还可以单独定义数组的各个分量，如array_name[0]=1 读取数组元素值的方式是$(数组名[下标])，使用@则可以获取数组中的所有元素，例如 1 echo ${array_name[@]} 获取数组的长度的方法是 1 length=${array_name[@]} bash基本运算 原生bash不支持简单的数学运算，但是可以通过其他命令实现，比如expr 1 2 val=`expr 2 + 2` # 注意：表达式和运算符之间一定要有空格，例如2+2是不对的，必须写成2 + 2,注意不是单引号而是反引号 echo &quot;两数之和为$val&quot; # 输出为&quot;两数之和为4&quot; 条件表达式要放在方括号之间，并且要有空格，例如 1 2 3 4 5 6 7 8 if [$a == $b] then echo &quot;a等于b&quot; fi if [$a != $b] then echo &quot;a不等于b&quot; fi 关系运算符： 运算符 说明 -eq 检测两个数是否相等，相等则返回true -ne 检测两个数是否不等，不等则返回true -gt 检测左边的是否大于右边的，大于则返回true -lt 检测左边的是否小于右边的，小于则返回true -ge 检测左边的是否大于等于右边的，大于等于则返回true -le 检测左边的是否小于等于右边的，小于等于则返回true ! 非运算 -o 或运算 -a 与运算 注意：乘号前必须要加上反斜杠\\转义才是乘法运算 test命令可以用于检查某个条件是否成立 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 数值测试 num1=100 num2=200 if test $[num1] -eq $[num2] then echo &#39;两个数相等&#39; else echo &#39;两个数不相等&#39; fi # 文件测试 cd /bin if test -e ./bash then echo &#39;文件存在&#39; else echo &#39;文件不存在&#39; fi 注意：新的test[[]]比旧的test[]更好，尽量使用[[]] 流程控制：shell编程的流程控制不可为空，即if和else的代码块里必须执行一定的动作 将if和else写成一行的方法： 1 if [ $(ps -ef | grep -c &amp;quot;ssh&amp;quot;) -gt 1]; then echo &quot;true&quot;; fi # 查找当前所有进程中ssh进程的个数，如果大于1则返回true for循环的一般格式 1 2 3 4 5 6 for var in item1 item2 ... itemN do command1 command2 commandN done 写成一行： 1 for var in item1 item2 itemN; do command1; command2; commandN; done; while循环： 1 2 3 4 5 6 7 8 9 10 11 12 int=1 while [ $int -lt 5 ] do echo $int let &quot;int++&quot; # let是bash中用于计算的工具，变量计算中不需要加上$表示变量 done # 运行结果 # 1 # 2 # 3 # 4 # 5 case选择 每个case分支从右圆括号开始，用两个分号;;表示break，跳出整个case...esac语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 echo &#39;输入1到4之间的数字&#39; echo &#39;你输入的数字为&#39; read aNum case $aNum in 1) echo &#39;你选择了1&#39; ;; 2) echo &#39;你选择了2&#39; ;; 3) echo &#39;你选择了3&#39; ;; 4) echo &#39;你选择了4&#39; ;; *) echo &#39;你没有输入1到4之间的任何数字&#39; ;; esac break命令 1 2 3 4 5 6 7 8 9 10 11 12 while true do echo -n &quot;输入1到5之间的数字&quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为$aNum!&quot; ;; *) echo &quot;你输入的数字不是1到5之间的！结束&quot; break ;; esac done shell函数 1 2 3 4 5 6 7 8 9 10 11 [function] funname [()] { action [return int] } # example demoFun(){ echo &quot;第一个shell函数&quot; } demoFun # 调用这个函数 程序的返回值：执行成功返回0，执行失败则返回其他大小的数值。注意，和C语言不同，shell中0表示true，1表示false 获取一个程序的变量值，如$(CMD)会先执行CMD，获取CMD的输出并再相应位置进行替换。比如执行for file in $(ls)，将先执行ls，然后遍历执行ls后获得的返回值 进程替换(process substitution)：&lt;(CMD)将执行CMD，然后将结果输出到一个临时文件，并把&lt;()替换为这个文件名。比如cat &lt;(ls -l)相当于ls -l | cat，diff &lt;(CMD1) &lt;(CMD2)是比较这两个CMD的区别 shell文件包含 包含外部脚本，以封装一些公用的代码作为一个独立文件 1 2 3 . file # 注意.和文件名中间有一个空格 # 或者 source file shell通配符(globbing) wildcard: 使用*或?来进行匹配，比如有foo1、foo2、foo几个文件，rm foo?将删除foo1和foo2，而rm foo*将删除foo1、foo2和foo等三个文件 花括号{用来扩展子字符串 1 2 3 convert image.{png,jpg} # will expand to convert image.png image.jpg Shell Tools tldr: – too long, didn’t read manual cheat sheet for console 寻找文件 find 1 2 3 4 5 6 7 8 9 10 11 12 # 寻找所有名为src的文件夹 find . -name src -type d # 寻找所有路径名中有test文件夹的Python文件 find . -path &#39;*/test/*.py&#39; -type f # 寻找所有在昨天被修改的文件 find . -mtime -l # 寻找所有大小在500k到10M的zip文件 find . -size +500k -size -10M -name &#39;*.tar.gz&#39; # 删除所有.tmp扩展名的文件。-exec表示在find寻找到这些文件之后可以执行的额外动作，\\;表示这些额外动作的结束。{}用来指代前面find到的文件 find . -name &#39;*.tmp&#39; -exec rm {} \\; # 将所有PNG文件转化为JPG文件 find . -name &#39;*.png&#39; -exec convert {} {}.jpg \\; fd是更好的find，支持正则表达式查找 locate是一个使用updatedb更新的数据库进行文件查找的程序，效率比find和fd更高，但是因为是每日更新的，所以并不是最新的。 grep是基于文件内容进行搜索，grep -C是获取匹配内容的上下文(Context)，比如grep -C 5是获取匹配内容的上下各5行内容，grep -R是递归(Recursively)地进入文件夹查找文件中的内容，grep -v用来反向(inversely)选择匹配的内容 rg、ag等也是和grep类似的查找工具，其中ripgrep(rg)是一个查找神器，用来查找代码中的code snippet，可以进行自动递归搜索，自动故忽略.gitignore中的文件和二进制文件，例如 1 rg -t py &quot;import request&quot; 查找所有包含import request的python文件 history可以用来查看shell中的所有交互记录，history | grep find则可以打印出过去曾经使用的find命令 在shell中可以按CTRL+R来进行反向搜索历史，通过键入一个子字符串来搜索过去的命令 fzf是一个模糊搜索工具(fuzzy finder) zsh：一种非常牛逼的shell，可以实现根据历史的命令来进行自动命令建议 fasd是快速跳转路径的工具，可以根据访问频率来自动给出跳转路径的建议 Lecture 3 Vim 快捷键 normal mode下G: 跳转到文件的最后一行 gg跳转到文件的第一行 w：下一个word，bbeginning of word、e：end of word $：跳转到行尾，^跳转到行首 ^u：向上滚动 ^d：向下滚动 h：光标左移 j：光标下移 k：光标上移 l：光标右移 :sp file：水平方向分割窗口，并打开file :vsp file：垂直方向分割窗口，并打开file ^ww：在打开的分割窗口之间切换 /：搜索字符串，按n跳转到下一个匹配，按N跳转到上一个匹配，可以进行/{regex}正则表达式搜索 c：change，即删掉选中的字符，然后进入Insert模式 d：delete，即删掉选中的字符 u：undo ^r: redo v：进入visual模式，可以通过光标移动来进行文本块的选择 .：重复之前的键入 o(open)：在下方键入新行 :n：跳转到第n行 :%d：删除所有行，其中%表示所有行 :2,8d表示删除第2到第8行 modifier: i(inside)或a(around)，比如ci[就是删除[]内的所有字符并进入insert模式，ca(就是删除()内以及()本身这些所有的字符并且进入insert模式 counts: 在命令前面加上数字来表示重复动作，比如3w是向后跳转3个word，5j是向下跳转5行 插件推荐 CtrlP: 一种能够在vim中模糊查找工程文件的vim插件 fugitive.vim: vim的git插件 ale：code linting插件，需要先安装pylint和eslint等linting插件 sudo apt-get install vim-gtk：系统自带vim不支持复制到系统剪切板，需要重装vim 可以安装vim-airline这款主题美化插件 NERDTree目录树，在vim normal模式键入:NERDTree即可打开目录树，:q关闭目录树 在/etc/vim/vimrc最后增加以使vim使用系统剪切板 1 2 3 4 5 6 7 8 &quot; WSL yank support let s:clip = &#39;/mnt/c/Windows/System32/clip.exe&#39; &quot; change this path according to your mount point if executable(s:clip) augroup WSLYank autocmd! autocmd TextYankPost * if v:event.operator ==# &#39;y&#39; | call system(s:clip, @0) | endif augroup END endif Lecture 4 Data Wrangling RegEx +表示前面的字符必须出现一次或者多次 *表示前面的字符可以出现0次、1次或者多次 ?表示前面的字符可以出现0次或1次，加在+和*后面以实现非贪婪匹配 [abc]表示匹配其中的所有abc三个字符 [^abc]表示匹配除了a、b、c之外的其他所有字符 [A-Z]表示一个区间，匹配所有大写字母 [\\s]匹配所有空白符 [\\S]匹配所有非空白符，[\\s\\S]匹配所有字符 [\\d]，digit，匹配[0-9]的数字，[\\D]匹配所有非数字 .匹配除了换行符\\n之外的所有字符 [\\w]word，匹配字母、数字、下划线，等价于[a-zA-Z0-9_] ()标记一个子表达式的开始和结束位置，子表达式可以获取供以后使用 非捕获元：?:放在()中可以避免匹配被缓存，exp1(?=exp2)正向肯定预查，查找exp2前的exp1，(?&lt;=exp2)exp1查找exp2后的exp1，exp1(?!exp2)查找后面不是exp2的exp1，(?&lt;!exp2)exp1查找前面不是exp2的exp1 只有grep -P才支持 {}限定符表达式，用来表示匹配的长度，比如s{1,3}表示匹配1-3个空格，o{1,}表示匹配1个以上的o ^：定位符，匹配输入字符串开始位置，不要和中括号表达式中的^混淆。$：定位符，匹配输入字符串结束位置 \\b：定位符，匹配单词边界 \\B：定位符，匹配非单词边界 修饰符：写在正则表达式之外，用于指定额外的匹配策略\\pattern\\flags i-ignore，不区分大小写 g-global，查找所有的匹配项 m-multiline，多行匹配，使^和$匹配一段文本中每行的开始和结束位置 use case 获取尝试连接远程服务器的用户名 1 ssh myserver &#39;journalctl | grep sshd | grep &quot;Disconnected from&quot;&#39; | less # journalctl是日志管理工具 journalctl和from之间的&#39;&#39;quoting是为了直接在服务器来查找这些内容，再把筛选好的内容传送到本地 sed: stream editor流编辑器，利用命令行对文件进行修改 s命令：substitution，用法：s/REGEX/SUBSTITUTION比如 1 2 3 4 ssh myserver journalctl | grep ssh | grep &quot;Disconnected from&quot; | sed &#39;s/.*Disconnected from //&#39; # 删除所有&#39;Disconnected from&#39; 提取用户名 1 | sed -E &#39;s/.*?Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/&#39; 排列用户名，列出用户名出现重复的次数 1 2 3 4 5 ssh myserver journalctl | grep sshd | grep &quot;Disconnected from&quot; | sed -E &#39;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/&#39; | sort | uniq -c 其中sort可以对输入的字符串组进行排序，uniq -c将所有重复的条目去掉，对每个条目只保留一次，并且将每个条目重复的次数打印 对这个重复的次数进行排序，并打印出重复次数最多的前10个条目 1 | sort -nk1,1 | tail -n10 sort -n将会对数字进行排列，-k1,1表明只对以空白键分割的第一列进行排序 将以上筛选出的用户名以逗号分隔，打印成一行输出 1 | awk &#39;{print $2}&#39; | paste -sd, paste -s可以将多行合并为一行，-d,表明分隔符delimiter是,。 awk是一种文字流处理编程语言，与sed、grep合并成为Linux三剑客，sed擅长对一行进行处理以及进行替换，grep擅长查找，awk擅长对列进行处理 筛选出所有只出现过一次的名称以c开头e结尾的用户名并统计数量 1 | awk &#39;$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ {print $2}&#39; | wc -l xargs：将找到的文本作为命令行的参数 1 rustup toolchain list | grep nightly | grep -vE &quot;nightly-x86&quot; | sed &#39;s/-x86.*//&#39; | xargs rustup toolchain uninstall 有的命令可以接受标准输入作为参数，比如grep，这样就可以使用管道命令|，比如cat /etc/passwd | grep root相当于grep root /etc/passwd，但是大多数命令不接受标准输入作为参数，只能直接在命令行输入参数，比如echo，因此xargs就是将标准输入转为命令行参数，比如 1 2 $ echo &quot;hello world&quot; | xargs echo hello world xargs的默认命令是echo，即xargs=xargs echo http://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html 对二进制的wrangling 用ffmpeg来从摄像头捕获图像，转化为灰度图，压缩，通过ssh发送到远程服务器并在远程服务器上解压，复制并展示 1 2 ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 - | convert - -colorspace gray - | gzip | ssh mymachine &#39;gzip -d | tee copy.jpg | env DISPLAY=:0 feh -&#39; Exercise 查找/usr/share/dict/words下含有至少3个a并且不以’s结尾的单词的个数 1 grep -P &quot;(.*a){3,}.*(?&lt;!&#39;s)$&quot; /usr/share/dict/words | wc -l 其中grep -P是以perl语法输入正则表达式，以开启?&lt;! 结尾出现频率最高的两个字母是什么？ 找出前三名 1 grep -P &quot;(.*a){3,}.*(?&lt;!&#39;s)$&quot; /usr/share/dict/words | sed -E &#39;s/.*(\\w\\w)/\\1/g&#39; | uniq -c | sort -nk1,1 | tail -n3 Lecture 5 Command Line Environment Job control UNIX使用signal来和进程进行通信，signal起到中断作用 ^C向进程发出SIGINT指令，^\\向进程发出SIGQUIT指令。程序会产生core文件，相当于程序错误，kill -TERM &lt;PID&gt;向进程发出SIGTERM指令，该信号可以被阻塞和处理，通常用来要求程序自己正常退出，SIGSTOP是暂停进程 下述python指令将忽略^C的SIGINT指令 1 2 3 4 5 6 7 8 9 10 11 12 #!/usr/bin/env python import signal, time def handler(signum, time): print(&quot;\\nI got a SIGINT, but I am not stopping&quot;) signal.signal(signal.SIGINT, handler) # attach SIGINT to handler i = 0 while True: time.sleep(.1) print(&quot;\\r{}&quot;.format(i), end=&quot;&quot;) i += 1 ^Z向shell发出一个SIGTSTP来暂停一个进程，使用fg或bg命令来把暂停的进程放在前台或者后台运行，比如bg %1 jobs用来列出所有当前终端对话尚未完成的任务，可以使用pgrep来获取这些任务的PID，也可以使用%1、%2等获取对这些任务的引用 可以在所有任务的最后增加一个&amp;后缀来使命令跑在后台 直接kill %1来终止第1个任务 Terminal Multiplexers tmux可以在一个终端窗口下使用多个pane和tab keybinding: 默认情况下是^b。 Session：独立的工作区， tmux：来启动一个新的session tmux new -s NAME：启动一个指定了名称的session tmux ls：列出现在的所有session 在tmux里按下^b d来从当前的session中detach tmux a来attach到上一个session Windows：相当于浏览器中的tab，属于同一个session ^b ccreate一个新的窗口，通过^d来关闭这个窗口 ^b N前往第N个窗口，N为数字 ^b p前往前一个窗口 ^b n前往下一个窗口 Panes：相当于vim中的split界面 ^b &quot;水平分割窗口，^d退出当前窗口 ^b %垂直分割窗口 ^b &lt;arrow&gt;跳转窗口 ^b &lt;space&gt;在不同的窗口设计中选择 Aliases 命令的代换(aliasing) 1 alias alias_name=&quot;command_to_alias arg1 arg2&quot; 注意=左右两边没有空格 e.g. 1 2 3 4 alisa ll=&quot;ls -lh&quot; alias gs=&quot;git status&quot; alias gc=&quot;git commit&quot; alias v=&quot;vim&quot; 上述alias命令在shell关闭之后会自动重设，可以在.bashrc或者.zshrc中写入相关的alias来使设置永久有效 Dotfiles 很多程序使用纯文本文件dotfile来对程序进行配置，比如.vimrc，这些文件默认隐藏在目录中。对bash程序来说，.bashrc或.bash_profile是默认配置bash设置的文件。在很多程序中要求dotfile指定一个二进制可执行文件的路径 1 export PATH=&quot;$PATH:/path/to/program/bin&quot; 可以将所有的dotfile放在一个文件夹下，进行版本控制，并且symlink它们，这样可以方便在不同的机器上将自定义的设置进行迁移 可以参考github上一些比较受欢迎的dotfile repo，例如https://github.com/mathiasbynens/dotfiles 为了提高dotfile的可移植性，可以在dotfile中增加一些条件判断语句，例如 1 2 3 4 5 6 7 if [[ &quot;$(uname)&quot; == &quot;Linux&quot; ]]; then {do_something}; fi # Check before using shell-specific features if [[ &quot;$SHELL&quot; == &quot;zsh&quot; ]]; then {do_something}; fi # You can also make it machine-specific if [[ &quot;$(hostname)&quot; == &quot;myServer&quot; ]]; then {do_something}; fi 如果想让zsh和bash使用同一个alias配置，可以在.bashrc和.zshrc文件中加入相同的 1 2 3 if [ -f ~/.aliases ]; then source ~/.aliases fi p.s. source &lt;filename&gt;和./&lt;filename的区别在于source是直接在当前SHELL session中执行的，而./是新起了一个session Remote machines SSH(secure shell) 1 ssh user@ip_address|url_of_server [command] # [command]表示在远程服务器中执行这个命令，然后返回到本地服务器 SSH config: 客户端SSH配置文件/etc/ssh/ssh_config。服务端SSH配置文件/etc/ssh/sshd_config SSH keys：SSH服务器持有公钥，客户端持有私钥，这样就不需要每次SSH到服务器时重新键入密码了。SSH key passphrase是为了防止别人持有你的私钥采用的加密措施 通过SSH来复制文件 最简单的方法是：ssh+tee，e.g. cat localfile | ssh remote_server tee serverfile tee和cat正好相反，tee用于读取标准输入，将其内容输出成文件，而cat用于读取文件，将其输出成标准输出 secure copy scp：可以recurse over path，scp path/to/local_file remote_host:path/to/remote_file rsync是scp基础上的提升，可以检测到本地和远程文件的相同文件，并不对它们进行重复复制。rsync的语法和scp类似 SSH port forwarding端口转发 如果在本地的应用向某个被绑定的端口发送数据，则这些数据将自动通过SSH被转发到远程服务器的另一个被绑定端口并做本地调用 Dynamic Tunneling (SOCKS proxy) 1 ssh -D 8080 remote_server 在192.168.56.101的浏览器中输入http://localhost时，这个http request会被发送到8080端口，但是由于SOCKS Proxy在8080端口监听，并把这个HTTP request转发给了SSH Client，SSH Client通过SSH将这个HTTP request发送给了102的SSH服务器，102在本地解析运行这个HTTP请求，由于HTTP默认使用80端口，如果102有apache绑定在其80端口上提供服务的话，那么apache服务器将接受这个对localhost的访问请求，返回相应的web服务页面 local port forwarding 1 ssh -L &lt;local port&gt;:&lt;remote hostname&gt;:&lt;remote service port&gt; user@remoteserver 比如 1 ssh -L 8000:localhost:80 ramki@192.168.56.102 client端绑定了8000端口，任何发送到8000端口的数据都将通过SSH客户端通过22端口发送到SSH服务端，由于绑定了远程服务器的80端口，因此远程服务端将把22端口的数据转发到80端口上。在dynamic tunneling模式中，服务器会检查packet并自动决定该packet发往哪个端口，比如HTTP request发往80端口，SMTP发往25端口，但是local port forwarding将发往指定的端口 remote port forwarding 1 ssh -R &lt;remote port&gt;:&lt;local hostname&gt;:&lt;local port&gt; user@remoteserver 把所有尝试发送到远程服务器指定端口的数据从&lt;local hostname&gt;的&lt;local port&gt;发送 Exercise 写一个脚本，以实现wait [PID]的功能 1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash while : do kill -0 $1 # $1 为脚本后面跟的第一个参数，也就是PID。kill -0是尝试杀这个进程，如果这个进程不存在就会返回1，否则返回0，但是不会实际去杀掉这个进程 if [[ $? -ne 0 ]] then break fi sleep 1 done ls -al Lecture 6 Version Control Git data model 文件：blob，本质是array&lt;byte&gt; 目录：tree，本质是map&lt;string, blob | tree&gt; 快照(snapshot)：也被称为commits，本质是被追踪的最高一级tree (root)。commits无法被改变 1 2 3 4 5 6 type commit = struct { parent: array&lt;commit&gt; author: string // metadata message: string // metadata snapshot: tree } 历史：DAG(directed acyclic graph) of snapshots，每个历史中的snapshot都指向它们的父节点，父节点可以不止一个，因为当merge的时候就会出现两个父节点 1 2 3 4 o &lt;-- o &lt;-- o &lt;-- o &lt;---- o ^ / \\ v --- o &lt;-- o 对象(object)：type object = blob | tree | commit 所有对象都用SHA-1 hash来引用 1 2 3 4 5 6 7 8 objects = map&lt;string, object&gt; def store(object): id = sha1(object) objects[id] = object def load(id): return objects[id] git cat-file &lt;SHA1&gt;就相当于上面的load(id)函数 引用(reference)：对commit的指针(比如master)，由于commit是SHA-hash码，人类难以记住，因此使用reference这种人类可读的字符串来指向commit，reference是可以改变的，即可以更改指向的commit。 1 2 3 4 5 6 7 8 9 10 11 12 13 references = map&lt;string, string&gt; def update_reference(name, id): references[name] = id def read_reference(name): return reference[name] def load_reference(name_or_id): if name_or_id in references: // is name return load(references[name_or_id]) else: // is id return load(name_or_id) HEAD：一个特殊的reference，用于指向我们目前看的commit 仓库(repository)：objects和references的集合 所有的git命令都是通过加入object和加入/更新references来对DAG进行操作 Git command-line interface 基础命令 git init：创建一个新的git仓库，数据存储在.git文件夹中 git status：查看目前git的状态 git add &lt;filename&gt;：将文件添加到staging area git commit：增加一个新的commit git commit -a表示automatically将所有之前已经追踪过的文件进行git add，从而省去git add的步骤 git log --all --graph --decorate：将git历史以DAG展现出来 git log -p -2显示历史中的最后2个commit的差异(patch) git log --pretty=oneline：将每个commit的信息用一行显示 过滤输出：git log --since=2.weeks：仅打印过去2周到现在的所有commit历史 --grep可以在commit信息中查找关键词进行输出过滤 git log -S function_name：只显示最后一个修改了某个特定函数的commit git log -- path/to/file：显示修改了这个文件的commit git diff &lt;filename&gt;：显示某个working directory中的文件和staging area中的差异 git diff --staged：显示在staging area中的文件和上次commit中的文件的差异 git diff &lt;version&gt; &lt;filename&gt;：显示某个文件不同commit中的差异 git checkout &lt;version&gt;：将HEAD移动到这个版本的commit git rm &lt;filename&gt;：相当于删除某个文件，并从staging area中将其删除(但是还没有commit) 如果想要在工作区中保留这个文件，但是从staging area中将其删除，使用git rm --cached &lt;filename&gt;，比如git rm log/\\*.log可以删除所有log/目录下的.log后缀的文件，注意要在*前加一个\\号 git tag：显示所有标签，git tag -l &quot;v1.8.6*&quot;显示所有1.8.6版本系列的标签 为某一个commit创建一个新的annotated tag（一次正式的发布，包含了创建日期、名称和邮箱、GPG签名等信息）：git tag -a v1.4 -m &quot;my version 1.4&quot; &lt;shachecksum&gt; 创建一个新的lightweight tag（仅仅是为一个commit对象起了一个别名，不包含任何其他信息）：git tag &lt;tag name&gt; 默认情况下git push时不会将tag推送到远程，可以采用git push origin --tags来将tag推送 git tag -d &lt;tag name&gt;删除某个标签 分支和合并命令 git branch：显示目前所有的分支 git branch &lt;name&gt;：创建一个新的分支 git branch -d &lt;name&gt;：删除某个分支 git checkout -b &lt;name&gt;：创建一个新的分支并且切换到这个分支，相当于git branch &lt;name&gt;; git checkout &lt;name&gt;，可以用git switch -c &lt;name&gt;代替 git merge &lt;revision&gt;：将&lt;revision&gt;合并到当前分支 git mergetool：使用合并工具来帮助处理合并冲突 git rebase：也可以达到合并分支的效果，但是和merge不同的是分叉会被取消 git merge：origin和mywork产生了分叉 git rebase：没有分叉，Commit5’和6‘以补丁的形式存在，放在./git/rebase目录中 远程命令 origin是默认的被克隆的远程名称（不是分支名，origin的master分支为origin/master)，被track的上游远程分支可以以@{upstream}或@{u}指代 git remote：显示所有已知的远程，增加一个-vflag来显示远程仓库的URL，或者git remote show &lt;remote&gt;来显示更多信息 git remote add &lt;name&gt; &lt;url&gt;：增加一个新的远程 git remote rm &lt;name&gt;：删除某个远程 git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;：将objects发送到远程分支，并且更新远程分支的reference git push &lt;remote&gt; --delete &lt;remote branch&gt;：删除远程分支 git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;：设置本地branch和远程branch的连接关系，从而可以直接进行git push而不需要指定远程branch git branch -vv查看目前正在追踪的远程分支 git fetch：从远程项目拉取所有的objects/reference，但是并不merge到working directory中，对working directory没有任何影响 git pull：相当于git fetch; git merge git clone：从远程分支下载repo，将本地的master分支追踪远程的master分支(本地分支和远程分支存在连接关系，运行git push时本地分支将知道push到哪个远程分支) git rebase：将一个分支rebase到另一个分支上，这样可以使分叉的commit变成线性的 撤销命令 所有的commit大概率是可以被恢复的，但是没有被commit的snapshot很难被恢复 git commit --amend：修改commit的内容 比如 1 2 3 git commit -m &#39;Initial commit&#39; git add forgotton_file git commit --amend 最终只有一个initial commit，里面包括了forgotton_file git reset HEAD &lt;file&gt;：把文件从staging area撤出，但是不会修改文件 也可以使用git restore --staged &lt;file&gt; git restore &lt;file&gt;则是将还未stage的文件恢复到上一次commit时的状态 git checkout -- &lt;file&gt;：把文件在工作区的修改全部撤销，撤销到最近一次git commit或git add的状态。当文件自修改后还没有放到暂存区时，使用本命令将回到和版本库相同的状态（但git还是知道修改的），当文件已经添加到暂存区，并且又做了修改之后，则回到添加到暂存区时的状态。 高级命令 git config：配置git，分成三个层面的配置，包括系统级别、用户级别、仓库级别 git config --system -l查看系统配置，配置文件存储于[path]/etc.gitconfig git config --global -l查看用户配置，配置文件存储于~/.gitconfig或~/.config/git/config文件 git config --local -l查看仓库配置，配置文件存储于[repo]/.git/config 优先级：仓库配置&gt;用户配置&gt;系统配置 设置main为默认的分支名：git config --global init.defaultBranch main git clone --depth=1：浅克隆，将忽略之前所有的版本历史 git add -p：交互式添加到暂存区，能够方便地将一个文件中的部分内容添加到暂存区 git rebase -i：interactive rebasing git blame：显示哪个用户编辑了哪一条 git stash：将目前还不想提交但是已经修改的内容（包括工作区和暂存区）保存到堆栈中，后续可以在某个分支上恢复出堆栈的内容。git stash pop将堆栈中的内容弹出到当前分支上，堆栈内容被删除，而git stash apply则将堆栈中的内容应用到当前分支上，和git stash pop不同的是堆栈中的内容并不会被删除，适用于应用到多个分支的情况 .gitignore：指定不需要track的文件 Git workflow https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow 软件开发的workflow，规定了分支的类型和怎样合并分支 master分支：软件的release版本分支 develop分支：开发分支 feature分支：每个单独的feature作为一个分支，以develop作为父分支 推荐阅读：pro git Lecture 7 Debugging and Profiling Logging Linux终端显示不同的颜色，使用ANSI escape颜色码 echo -e &quot;\\e[1;31mThis is red\\e[0m&quot; 显示红色的This is red echo -e &quot;\\e[1;42mGreen Background\\e[0m&quot;显示绿色背景的Green Background 大多数程序将日志文件存放在/var/log目录下，systemd是一个system的daemon程序，将所有系统日志存放在var/log/journal下，可以用journalctl来查看 logger &quot;logging info&quot;可以将log记录到journal中 Debugging pdb：python debugger s(tep)：单步执行，相当于step into n(ext)：单步执行，相当于step over l(ist)：列出执行到的那行代码的前后十一行 c(ontinue)：继续执行，直到遇到下一条断点 b(reakpoint)：设置断点 cl(ear)：清除断点 r(eturn)：执行当前运行函数直到结束 p(rint) &lt;expression&gt;：输出expression的值 q(uit)：退出debugger restart：重新debug 使用python -m pdb &lt;filename.py&gt;来进行pdb调试，其中-m表示将模块(module)当作脚本运行，也就是将pdb当作脚本运行 gdb(GNU debugger)：C/C++ debugger，也支持Go和Rust调试，用法和pdb类似 静态代码分析：无需用编译器编译运行即可扫描出代码错误 pyflakes是python的静态扫描工具，shellcheck可以对shell scripts进行扫描 code linting：在编译前即标出警告和错误的位置 一些linter推荐： https://github.com/caramelomartins/awesome-linters#cc Profiling 获取程序运行的资源占用以及时间信息 Timing Real time: 真实时间，包括了被其他进程占用的时间和等待I/O以及网络的时间 User time: 用户时间，即CPU运行用户代码所花费的时间 Sys time: 系统时间，即CPU运行kernal代码所花费的时间 time &lt;command&gt;可以计算上述三个时间 CPU profiler 最常见的profiler，两种类型： tracing profiler: 记录每个函数调用 sampling profiler：周期性地对程序采样，记录程序的堆栈 对于python程序，使用cProfile来作为profiler python -m cProfile -s tottime &lt;filename.py&gt; 但是由于cProfiler将所有内部调用函数的开销都统计在内，很难看出真正把时间都花在了哪里，因此可以使用line_profiler来统计每一行代码所花费的时间，这样更加直观，需要添加一个decorator @profile来声明需要进行profiling的函数 可以使用flame graph来将CPU profiling可视化 memory profiler 内存泄漏：即使在不需要用到这些内存的时候也不将其释放，在没有垃圾收集的语言，比如C/C++中可以使用valgrind来显示内存泄漏，python可以使用memory_profiler来进行memory profiling 函数调用图：python中可以选择pycallgraph来显示哪个函数调用了哪个 resource monitoring htop：top的升级版，来观察系统资源使用情况 free：观察系统可用内存使用情况 df：当前文件夹中磁盘使用情况 nethogs/iftop/ss：网络使用情况 hyperfine：对程序进行快速benchmark，例如比较fd和find的速度 1 hyperfine --warmup 3 &#39;fd -e jpg&#39; &#39;find . -iname &quot;*.jpg&quot;&#39; Lecture 8 Metaprogramming Build systems 将依赖编译构建为二进制文件的流程需要用到build systems，比如make 定义： 依赖(dependency) 目标(target) 构建规则(rule) 在某个目录下执行make时，make将会查找该目录下的Makefile，示例如下所示 1 2 3 4 5 6 7 8 # this is comment @# @ is to turn off the echoing of comment # .ONESHELL: paper.pdf: paper.tex plot-data.png pdflatex paper.tex plot-data.png plot-%.png: %.dat plot.py ./plot.py -i $*.dat -o $@ 冒号左边是需要构建的目标文件，冒号右边是依赖文件，下面一行是构建规则,，注意每行命令在单独的shell中执行，这些shell之间没有继承关系，除非将几行命令写在一行中，中间用分号分割，或者加上.ONESHELL:命令，每一个这样的组合构成了一个directive %是一个样式，匹配任意字符串，如果需要构建的是plot-data.png，那么就会去寻找data.dat这个依赖文件 $@是目前的target 目标文件如果已经构建成功，而依赖文件没有作任何更新，那么再执行make将不会有任何动作，如果某个依赖文件更新，那么只对和该依赖文件有关的编译动作进行重新编译。 除了文件名，目标还可以是某个操作的名字，称为伪目标，比如make clean不是make一个叫做clean的文件，而是删除对象文件，因此要把clean声明为伪目标 1 2 3 .PHONY: clean clean: rm *.o temp make install将可执行文件复制到正确的路径，即被复制到某个PATH包含的路径 Dependency management 有多种不同的依赖： 依赖程序：例如python 依赖系统包(system packages)：例如openssl 编程语言中的库(library)：例如matplotlib 仓库：管理各种依赖的地方，比如ubuntu中的apt、Ruby中的gem、Python中的pip以及nodejs中的npm versioning：对软件版本控制 semantic versioning: major.minor.patch patch：新的版本不改变API，增加patch# minor：如果对API的改变是向后兼容的，增加minor# major：如果对API的改变不向后兼容，增加major# lock file：列出所有依赖的版本信息的文件，需要手动对依赖库中的软件进行升级 vendoring：将所有依赖的源代码复制到项目中，来获得对依赖的完全控制权 Continuous Integration System (CI) 持续集成，即一旦进行了源代码的commit，即进行自动编译测试，将代码集成到主干，从而尽快发现错误，防止分支大幅偏离主干 比较多的CI工具包括Travis CI、Azure Pipelines和Github Actions CI是事件触发，一旦被触发，CI将起一个虚拟机，在其中运行用户规定的recipe所需要执行的命令。GitHub Pages就是一个CI系统，每次md文件被commit到repo后jekyll就会将其编译为HTML并deploy到服务器上 git本身就是一个简单的CI系统，在.git/hooks下有一些事件触发的脚本，比如pre-commit.sample,在commit时被触发 测试 test suite：所有测试的集合 unit test：单元测试，对某一个feature进行单独测试 integration test：集成测试，对各个单元继续联合测试 regression test：回归测试，对之前所有产生bug的条件进行测试从而保证相同的bug不再出现 mocking：用一个假的Implementation来代替一个功能模块来实现对其他依赖于此模块的其他模块进行测试 Lecture 9 Security and Cryptography Hash functions 将一个任意长度的bytes array映射到一个固定长度的byte 其中一种Hash function是SHA1，生成160位输出(40个16进制字符) 可以使用sha1sum命令来输出一个文件的SHA1哈希值 哈希函数有以下的特性： deterministic：相同的输入总是生成相同输出 non-invertible：已知输出，很难得到输入 collision resistant：两个不同的输入很难得到相同的输出 Key Derivation Functions (KDF) 本质上属于Hash函数 给一个passphrase(相当于用户的password)，生成一个固定长度的key，通常KDF相当缓慢，为了防止brute force破解密码 KDF可以用于存储网站密码，比如生成一个随机的salt，然后存储salt以及KDF(password+salt)，用重新生成KDF(password+salt)来验证每次的登陆尝试 Symmetric cryptography 对称加密的过程： 1 2 3 keygen() -&gt; key # 随机生成一个key，通信双方交换这个key，key需要保密 encrypt(plaintext, key) -&gt; ciphertext decrypt(ciphertext, key) -&gt; plaintext 对称加密的特性： 即便拥有ciphertext，没有key的情况下也无法得到plain text 显然正确性，即decrypt(encrypt(message, key), key) = message 比较著名的对称加密算法：AES Asymmetric cryptography 非对称加密，有一个公钥，不需要保密，还有一个私钥，自己保存，需要保密。这样可以解决对称加密中需要交换密钥的问题 非对称加密的过程： 1 2 3 keygen() -&gt; (public key, private key) encrypt(plaintext, public key) -&gt; ciphertext decrypt(ciphertext, private key) -&gt; plaintext 非对称加密可以用于签名/验证过程： 1 2 sign(message, private key) -&gt; signature verify(signature, message, public key) -&gt; &lt;bool&gt;is_signature 非对称加密的应用： PGP邮件加密 私人通信频道 公钥分发：如何确认别人得到的公钥确实是我们给他们的公钥？ 著名的非对称算法：RSA算法 GPG(GNU Private Guard)是一个使用RSA算法对文件进行加密的软件 使用方法：https://www.digitalocean.com/community/tutorials/how-to-use-gpg-to-encrypt-and-sign-messages case study Two-Factor Authentication (2FA)：用一个passphrase和某个authenticator(授权文件或物理设备，如YubiKey)来防止passphrase的泄露 磁盘加密：使用对称加密，需要passphrase，Linux上可以使用cryptsetup+LUKS，Windows上可以使用BitLocker SSH：ssh-keygen是非对称加密，生成一个公钥和密钥，密钥采用KDF进行对称加密，因此需要一个passphrase。服务器需要知道公钥，私钥保存在本地。服务器先选一个随机的信息发送给client，要求client对该信息进行签名，client将该信息签名之后发送给server，server通过公钥验证该签名 Lecture 10 Miscellaneous Daemons 守护进程，开机自动运行在后台的进程，这些进程一般后缀都有一个d，比如sshd就是SSH的守护进程，负责监听SSH请求。systemd是linux的系统守护进程，负责运行和设置守护进程，可以运行systemctl status来列出当前正在运行的daemon。可以使用cron来定时运行守护进程 FUSE (Filesystem in User SpacE) 用户空间文件系统，即用户可以通过FUSE在用户空间定制实现自己的文件系统而不必在内核态 fuse_user是开发的用户态的文件系统程序，该程序启动的时候会将自己开发的接口注册到fuse中，比如读写文件的接口，遍历目录的接口等等。 同时，通过该程序在系统某个路径挂载fuse文件系统，比如/tmp/file_on_fuse_fs。此时如果在该目录中有相关操作时，请求会经过VFS到fuse的内核模块（上图中的步骤1），fuse内核模块根据请求类型，调用用户态应用注册的函数（上图中步骤2），然后将处理结果通过VFS返回给系统调用（步骤3）。 SSHFS就是一个FUSE文件系统，可以通过SSH链接在本地打开远程服务器的文件/文件夹 API 大多数的线上服务有可以让你通过编程获取一定形式的API，这些API都有固定结构的URL，经常是以api.service.com为root 很多API会要求一个token来获取服务，可以通过OAuth这个协议来获取token token和密码是不同的，token是短期的，到期自动失效，也可以被数据所有者撤销，且有权限范围 Command Line flags/patterns 大多数命令行有类似的flag，比如： dry run：只会打印出如果不在dry run模式下的结果，但实际上什么修改都不会进行 --verbose或-v：打印详细内容，-vvv打印更详细的内容，--quiet打印简短的内容 -代替文件名表示标准输入输出 --表示停止将后面的字符以flag对待，比如rm -- -r就是删除-r这个文件而不是进行递归删除 tiling window manager 瓦片窗口管理器，窗口永远平铺，很多使用Lua进行编程 Linux快捷键 ^l：清屏 ^u：删除光标前的全部指令 Linux安装必需的包： gcc 1 2 sudo apt update sudo apt-get install build-essential","headline":"MIT 6.null Lecture Notes","url":"https://tommyfan34.github.io/posts/MIT-6-null-notes/","@type":"BlogPosting","dateModified":"2021-01-14T19:59:12+08:00","datePublished":"2021-01-14T18:32:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://tommyfan34.github.io/posts/MIT-6-null-notes/"},"@context":"https://schema.org"}</script><title>MIT 6.null Lecture Notes | Xiao Fan (樊潇)</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" href="/assets/css/post.css" as="style"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-FTKB0LQYH6"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-FTKB0LQYH6'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/sample/me.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Xiao Fan (樊潇)</a></div><div class="site-subtitle font-italic">Lots of hair | 低质量人类男性，新一线城市做题家，屎山代码制造机</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tabs/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tabs/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/tabs/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tabs/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/tommyfan34" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/tommyfan34" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['tommyfanzju','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="https://www.linkedin.com/in/xiao-fan-6a21b7171" aria-label="linkedin" class="order-6" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://www.facebook.com/tommyfanzju" aria-label="facebook" class="order-7" target="_blank" rel="noopener"> <i class="fab fa-facebook"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>MIT 6.null Lecture Notes</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>MIT 6.null Lecture Notes</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Jan 14, 2021, 6:32 PM +0800" > Jan 14, 2021 <i class="unloaded">2021-01-14T18:32:00+08:00</i> </span> by <span class="author"> Xiao Fan </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Jan 14, 2021, 7:59 PM +0800" > Jan 14, 2021 <i class="unloaded">2021-01-14T19:59:12+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="12653 words">70 min</span></div></div><div class="post-content"><h1 id="lecture-1-shell">Lecture 1 Shell</h1><ul><li><p>bash中如果想提供一个包含空格的参数，可以用‘或”“把它们引起来，或者用转义字符\，比如My\ Photos来将空格转义</p><li><p><code class="language-plaintext highlighter-rouge">$PATH</code>是环境变量，即在本地文件夹下没有找到对应可以执行的程序时会自动在环境变量的路径中寻找相应的程序。<code class="language-plaintext highlighter-rouge">which</code>提示了能够运行本指令的程序路径，比如</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>~<span class="nv">$ </span>which <span class="nb">echo</span>
/bin/echo
</pre></table></code></div></div><li><p><code class="language-plaintext highlighter-rouge">ls -l</code>表示以详细方式列出当前文件夹下的文件</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>missing:~<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> /home
drwxr-xr-x 1 missing  <span class="nb">users  </span>4096 Jun 15  2019 missing
</pre></table></code></div></div><p>第1个字符表明这个文件的类型。d表示这是一个文件夹，如果是-表示这是一个普通文件，l表示这是一个链接文件，类似于windows下的快捷方式，b表示这是一个块设备文件，一般置于/dev目录下，没有文件大小，只有一个主设备号和辅设备号。块设备是一次传输一整块数据的设备，比如硬盘。c表示这是一个字符设备文件，一般置于/dev目录下，字符设备是一次只传输一个字符数据的设备，比如键盘。p表示这是一个命令管道文件，与shell编程有关，s表示这是一个socks文件，与shell编程有关</p><p>d后面有3*3个标志，表示不同的身份对该文件的权限。r表示可读权限，w表示可写权限，x表示可执行权限，-表示无相应权限。第一组表示该文件的所有者的权限，第二组表示文件所有者同组用户的权限，第三组表示其他用户的权限</p><p>权限后面的第一个数字表示1. 当这是一个文件时，为硬连接数，即有几个文件硬链接到了这个文件 2. 当这是一个文件夹时，为链接占用的节点，即该目录中包含的子目录的个数</p><p>对于一个文件夹来说，为了进入这个文件夹，必须拥有”search”权限，也就是拥有对这个文件夹<font color="red">以及其所有父路径文件夹</font>的x权限。为了<code class="language-plaintext highlighter-rouge">ls</code>这个文件夹，必须拥有这个文件夹的r权限</p><li><p><strong>重定向输入输出流</strong>：<code class="language-plaintext highlighter-rouge">&lt; file</code>将输入设定为文件，<code class="language-plaintext highlighter-rouge">&gt; file</code>将结果输出到文件，原先文件的内容会被覆盖</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>missing:~<span class="nv">$ </span><span class="nb">echo </span>hello <span class="o">&gt;</span> hello.txt
missing:~<span class="nv">$ </span><span class="nb">cat </span>hello.txt
hello
missing:~<span class="nv">$ </span><span class="nb">cat</span> &lt; hello.txt
hello
missing:~<span class="nv">$ </span><span class="nb">cat</span> &lt; hello.txt <span class="o">&gt;</span> hello2.txt
missing:~<span class="nv">$ </span><span class="nb">cat </span>hello2.txt
hello
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">&gt;&gt;</code>可以来向文件附加数据。<code class="language-plaintext highlighter-rouge">|</code>是管道符号，可以将前一个命令的输出作为下一个命令的输入。</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>curl <span class="nt">--head</span> <span class="nt">--silent</span> google.com | <span class="nb">grep</span> <span class="nt">--ignore-case</span> content-length | <span class="nb">cut</span> <span class="nt">--delimiter</span><span class="o">=</span><span class="s1">' '</span> <span class="nt">-f2</span>
<span class="c"># 查看向google发送HTTP GET请求的头文件中的content length属性的值</span>
</pre></table></code></div></div><p>文件描述符：一般情况下每个unix命令运行时都会打开3个文件：</p><ul><li>标准输入文件(stdin)：文件描述符为0，unix默认从stdin输入数据<li>标准输出文件(stdout)：文件描述符为1，unix默认向stdout输出数据<li>标准错误文件(stderr)：文件描述符为2，unix会向stderr流中写入错误消息</ul><p>默认情况下，<code class="language-plaintext highlighter-rouge">command&gt;file</code>将stdout重定向到file，<code class="language-plaintext highlighter-rouge">command&lt;file</code>将stdin重定向到file</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">command </span>2&gt;&gt;file <span class="c"># 将stderr追加到文件末尾//</span>
</pre></table></code></div></div><p>/dev/null文件是一种特殊的文件，写入到它的内容都会被丢弃，也无法从中读取到任何内容，如果希望执行某个命令，但是不希望在屏幕上显示输出结果，可以将输出重定向到/dev/null</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">command</span> <span class="o">&gt;&gt;</span> /dev/null 2&gt;&amp;1 <span class="c"># 屏蔽stdout和stderr</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">command &gt;&gt; /dev/null</code>已经将标准输出重定向，<code class="language-plaintext highlighter-rouge">2&gt;&amp;1</code>中的<code class="language-plaintext highlighter-rouge">&amp;</code>表示等同，<code class="language-plaintext highlighter-rouge">2&gt;</code>表示错误输出，<code class="language-plaintext highlighter-rouge">2&gt;&amp;1</code>表示错误输出重定向的对象等同于标准输出重定向的对象，即<code class="language-plaintext highlighter-rouge">/dev/null</code></p><li><p><code class="language-plaintext highlighter-rouge">sysfs</code>：Linux内核下基于内存的文件系统，可以将很多内核参数以文件形式暴露，从而可以方便地修改kernel。比如笔记本电脑的屏幕亮度可以以文件的形式在<code class="language-plaintext highlighter-rouge">sys/class/backlight</code>下被暴露</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">sudo </span>find <span class="nt">-L</span> /sys/class/backlight <span class="nt">-maxdepth</span> 2 <span class="nt">-name</span> <span class="s1">'*brightness*'</span>
/sys/class/backlight/thinkpad_screen/brightness
<span class="nv">$ </span><span class="nb">cd</span> /sys/class/backlight/thinkpad_screen
<span class="nv">$ </span><span class="nb">sudo echo </span>3 <span class="o">&gt;</span> brightness  <span class="c"># permission denied，因为&gt;重定向符号之前的sudo并不能被后面观察到，也就是说写入brightness这个操作实际上并没有执行sudo</span>
<span class="nv">$ </span><span class="nb">echo </span>3 | <span class="nb">sudo tee </span>brightness  <span class="c"># success，tee这个命令是获取标准输入，将内容输出成文件，并将其打印到屏幕上</span>
</pre></table></code></div></div><li><p><code class="language-plaintext highlighter-rouge">chmod</code>(change mode)来控制用户对文件的权限的命令。只有文件拥有者(owner)和超级用户(super user)可以修改文件或者目录的权限</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nb">chmod</span> <span class="o">[</span><span class="nt">-cfvR</span><span class="o">]</span> <span class="o">[</span><span class="nt">--help</span><span class="o">]</span> <span class="o">[</span><span class="nt">--version</span><span class="o">]</span> mode file...
<span class="c"># mode格式为</span>
<span class="o">[</span>ugoa...][[+-<span class="o">=][</span>rwxX]...][,...]
<span class="c"># u表示该文件的拥有者，g表示与该文件的拥有者属于同一个group者，o表示其他人，a表示这三者皆是</span>
<span class="c"># +表示增加权限，-表示取消权限，=表示唯一设定权限</span>
<span class="c"># r表示可读取，w表示可写入，x表示可执行，X表示只有当该文件是个子目录或者该文件已经被设定过为可执行</span>
<span class="c"># 示例:将file1.txt设定为所有人皆可读取</span>
<span class="nb">chmod </span>ugo+r file1.txt
</pre></table></code></div></div><p>也可以采用八进制的方法来规定权限</p><div class="table-wrapper"><table><thead><tr><th>#<th>权限<th>rwx<th>二进制<tbody><tr><td>7<td>读+写+可执行<td>rwx<td>111<tr><td>6<td>读+写<td>rw-<td>110<tr><td>5<td>读+执行<td>r-x<td>101<tr><td>4<td>只读<td>r–<td>100<tr><td>3<td>写+执行<td>-wx<td>011<tr><td>2<td>只写<td>-w-<td>010<tr><td>1<td>只执行<td>–x<td>001<tr><td>0<td>无<td>—<td>000</table></div><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c"># file1.txt这个文件对所有的用户均可读可写可执行</span>
<span class="nb">chmod </span>777 file1.txt
<span class="c"># file2.txt这个文件对其他用户只可执行</span>
<span class="nb">chmod </span><span class="nv">ug</span><span class="o">=</span>rwx,o<span class="o">=</span>x file2.txt
<span class="c"># 与以下相同</span>
<span class="nb">chmod </span>771 fil2.txt
</pre></table></code></div></div><p>一般比较常用的是<code class="language-plaintext highlighter-rouge">chmod 755</code>和<code class="language-plaintext highlighter-rouge">chmod 777</code></p><li><p>shebang: <code class="language-plaintext highlighter-rouge">#!</code></p><p>写在脚本的第一行，用来规定该脚本的解释器。<code class="language-plaintext highlighter-rouge">#!</code>后接解释器的绝对路径。比如想要规定这个脚本用sh来执行，那么在第一行添加</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="c">#!/bin/sh</span>
</pre></table></code></div></div><p>推荐使用<code class="language-plaintext highlighter-rouge">/usr/bin/env python</code>来规定该脚本解释器，这是因为<code class="language-plaintext highlighter-rouge">env</code>会在<code class="language-plaintext highlighter-rouge">$PATH</code>中查找python解释器的安装位置，这样可以不用提供一个解释器的绝对路径，从而提高程序的可移植性</p><li><p>后台执行shell</p><p>在shell命令的最后一个位置加<code class="language-plaintext highlighter-rouge">&amp;</code></p></ul><h1 id="lecture-2-shell-tools-and-scripting">Lecture 2 Shell Tools and Scripting</h1><h2 id="shell-scripting">Shell Scripting</h2><p>Shell是一个用C语言编写的程序，是一种解释性语言。Windows Explorer是一个典型的图形界面shell</p><p>Bourne Shell /bin/sh或/usr/bin/sh</p><p>Bourne Again Shell /bin/bash</p><ul><li><p>给变量赋值：</p><p>注意在定义变量时变量名不加美元符号，变量名和等号之间不能有空格。在使用一个已经定义过的变量时需要加美元符号</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nv">foo</span><span class="o">=</span>bar
<span class="c"># 注意不能是foo = bar，否则bash会认为这是运行了foo命令，并以=和bar作为参数传入</span>
<span class="nb">echo</span> <span class="s2">"</span><span class="nv">$foo</span><span class="s2">"</span>
<span class="c"># prints bar</span>
<span class="nb">echo</span> <span class="s1">'$foo'</span>
<span class="c"># or</span>
<span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">foo</span><span class="k">}</span><span class="s2">"</span> <span class="c"># 花括号加不加可选，主要是为了清晰变量名的边界</span>
<span class="c"># prints $foo</span>
<span class="c"># 注意在bash中"和‘是不同的。在'中$变量不会被替换，"中$后面的变量会被替换为其值</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">readonly</code>变量是只读变量，不能被赋值</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">myurl</span><span class="o">=</span><span class="s2">"www.fanxiao.tech"</span>
<span class="nb">readonly </span>myurl
</pre></table></code></div></div><p>使用<code class="language-plaintext highlighter-rouge">unset</code>命令可以删除变量</p><li><p>获取字符串的长度</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">string</span><span class="o">=</span><span class="s2">"abcd"</span>
<span class="nb">echo</span> <span class="k">${#</span><span class="nv">string</span><span class="k">}</span> <span class="c"># 输出4</span>
</pre></table></code></div></div><li><p>提取子字符串</p><p>从字符串的第2个字符开始截取四个字符</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">string</span><span class="o">=</span><span class="s2">"runoob is a great site"</span>
<span class="nb">echo</span> <span class="k">${</span><span class="nv">string</span>:1:4<span class="k">}</span> <span class="c"># 输出unoo</span>
</pre></table></code></div></div><li><p>函数</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c"># 以shell脚本的名称创建一个文件夹并cd到这个文件夹中</span>
mcd<span class="o">(){</span>
	<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>
	<span class="nb">cd</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">$0</code>：脚本本身的名称<li><code class="language-plaintext highlighter-rouge">$1</code>-<code class="language-plaintext highlighter-rouge">$9</code>：脚本的第1-第9个参数<li><code class="language-plaintext highlighter-rouge">$@</code>：所有脚本的参数<li><code class="language-plaintext highlighter-rouge">$#</code>：脚本参数的个数<li><code class="language-plaintext highlighter-rouge">$?</code>：前一个命令的返回代码<li><code class="language-plaintext highlighter-rouge">$$</code>：当前脚本的PID<li><code class="language-plaintext highlighter-rouge">!!</code>：完整的上一个命令，包括参数。如果一个命令只是因为没有root权限失败，则可以执行<code class="language-plaintext highlighter-rouge">sudo !!</code>来重新执行该命令<li><code class="language-plaintext highlighter-rouge">$_</code>：上一个命令的最后一个参数</ul><li><p>数组</p><p>数组索引从0开始。用括号()来表示数组，数组元素用空格分开。定义数组的一般形式为</p><p>数组名=(值1 值2 值3 值4)</p><p>如</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">array_name</span><span class="o">=(</span>value0 value1 value2<span class="o">)</span>
</pre></table></code></div></div><p>还可以单独定义数组的各个分量，如<code class="language-plaintext highlighter-rouge">array_name[0]=1</code></p><p>读取数组元素值的方式是<code class="language-plaintext highlighter-rouge">$(数组名[下标])</code>，使用<code class="language-plaintext highlighter-rouge">@</code>则可以获取数组中的所有元素，例如</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">echo</span> <span class="k">${</span><span class="nv">array_name</span><span class="p">[@]</span><span class="k">}</span>
</pre></table></code></div></div><p>获取数组的长度的方法是</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">length</span><span class="o">=</span><span class="k">${</span><span class="nv">array_name</span><span class="p">[@]</span><span class="k">}</span>
</pre></table></code></div></div><li><p>bash基本运算</p><p>原生bash不支持简单的数学运算，但是可以通过其他命令实现，比如<code class="language-plaintext highlighter-rouge">expr</code></p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">val</span><span class="o">=</span><span class="sb">`</span><span class="nb">expr </span>2 + 2<span class="sb">`</span>   <span class="c"># 注意：表达式和运算符之间一定要有空格，例如2+2是不对的，必须写成2 + 2,注意不是单引号而是反引号</span>
<span class="nb">echo</span> <span class="s2">"两数之和为</span><span class="nv">$val</span><span class="s2">"</span>  <span class="c"># 输出为"两数之和为4"</span>
</pre></table></code></div></div><p>条件表达式要放在方括号之间，并且要有空格，例如</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">[</span><span class="nv">$a</span> <span class="o">==</span> <span class="nv">$b</span><span class="o">]</span>
<span class="k">then
	</span><span class="nb">echo</span> <span class="s2">"a等于b"</span>
<span class="k">fi
if</span> <span class="o">[</span><span class="nv">$a</span> <span class="o">!=</span> <span class="nv">$b</span><span class="o">]</span>
<span class="k">then
	</span><span class="nb">echo</span> <span class="s2">"a不等于b"</span>
<span class="k">fi</span>
</pre></table></code></div></div><p>关系运算符：</p><div class="table-wrapper"><table><thead><tr><th>运算符<th>说明<tbody><tr><td>-eq<td>检测两个数是否相等，相等则返回true<tr><td>-ne<td>检测两个数是否不等，不等则返回true<tr><td>-gt<td>检测左边的是否大于右边的，大于则返回true<tr><td>-lt<td>检测左边的是否小于右边的，小于则返回true<tr><td>-ge<td>检测左边的是否大于等于右边的，大于等于则返回true<tr><td>-le<td>检测左边的是否小于等于右边的，小于等于则返回true<tr><td>!<td>非运算<tr><td>-o<td>或运算<tr><td>-a<td>与运算</table></div><p>注意：乘号前必须要加上反斜杠\转义才是乘法运算</p><li><p><code class="language-plaintext highlighter-rouge">test</code>命令可以用于检查某个条件是否成立</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c"># 数值测试</span>
<span class="nv">num1</span><span class="o">=</span>100
<span class="nv">num2</span><span class="o">=</span>200
<span class="k">if </span><span class="nb">test</span> <span class="nv">$[</span>num1] <span class="nt">-eq</span> <span class="nv">$[</span>num2]
<span class="k">then
	</span><span class="nb">echo</span> <span class="s1">'两个数相等'</span>
<span class="k">else
	</span><span class="nb">echo</span> <span class="s1">'两个数不相等'</span>
<span class="k">fi</span>
  
<span class="c"># 文件测试</span>
<span class="nb">cd</span> /bin
<span class="k">if </span><span class="nb">test</span> <span class="nt">-e</span> ./bash
<span class="k">then 
	</span><span class="nb">echo</span> <span class="s1">'文件存在'</span>
<span class="k">else
	</span><span class="nb">echo</span> <span class="s1">'文件不存在'</span>
<span class="k">fi</span>
</pre></table></code></div></div><p>注意：新的test<code class="language-plaintext highlighter-rouge">[[]]</code>比旧的test<code class="language-plaintext highlighter-rouge">[]</code>更好，尽量使用<code class="language-plaintext highlighter-rouge">[[]]</code></p><li><p>流程控制：shell编程的流程控制不可为空，即<code class="language-plaintext highlighter-rouge">if</code>和<code class="language-plaintext highlighter-rouge">else</code>的代码块里必须执行一定的动作</p><p>将<code class="language-plaintext highlighter-rouge">if</code>和<code class="language-plaintext highlighter-rouge">else</code>写成一行的方法：</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">[</span> <span class="si">$(</span>ps <span class="nt">-ef</span> | <span class="nb">grep</span> <span class="nt">-c</span> &amp;quot<span class="p">;</span>ssh&amp;quot<span class="p">;</span><span class="si">)</span> <span class="nt">-gt</span> 1]<span class="p">;</span> <span class="k">then </span><span class="nb">echo</span> <span class="s2">"true"</span><span class="p">;</span> <span class="k">fi</span> <span class="c"># 查找当前所有进程中ssh进程的个数，如果大于1则返回true</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">for</code>循环的一般格式</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">for </span>var <span class="k">in </span>item1 item2 ... itemN
<span class="k">do
	</span>command1
	command2
	commandN
<span class="k">done</span>
</pre></table></code></div></div><p>写成一行：</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">for </span>var <span class="k">in </span>item1 item2 itemN<span class="p">;</span> <span class="k">do </span>command1<span class="p">;</span> command2<span class="p">;</span> commandN<span class="p">;</span> <span class="k">done</span><span class="p">;</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">while</code>循环：</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="nv">int</span><span class="o">=</span>1
<span class="k">while</span> <span class="o">[</span> <span class="nv">$int</span> <span class="nt">-lt</span> 5 <span class="o">]</span>
<span class="k">do
	</span><span class="nb">echo</span> <span class="nv">$int</span>
	<span class="nb">let</span> <span class="s2">"int++"</span>  <span class="c"># let是bash中用于计算的工具，变量计算中不需要加上$表示变量</span>
<span class="k">done</span>
<span class="c"># 运行结果</span>
<span class="c"># 1</span>
<span class="c"># 2</span>
<span class="c"># 3</span>
<span class="c"># 4</span>
<span class="c"># 5</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">case</code>选择</p><p>每个case分支从右圆括号开始，用两个分号<code class="language-plaintext highlighter-rouge">;;</code>表示break，跳出整个<code class="language-plaintext highlighter-rouge">case...esac</code>语句</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="nb">echo</span> <span class="s1">'输入1到4之间的数字'</span>
<span class="nb">echo</span> <span class="s1">'你输入的数字为'</span>
<span class="nb">read </span>aNum
<span class="k">case</span> <span class="nv">$aNum</span> <span class="k">in
	</span>1<span class="p">)</span> <span class="nb">echo</span> <span class="s1">'你选择了1'</span>
	<span class="p">;;</span>
	2<span class="p">)</span> <span class="nb">echo</span> <span class="s1">'你选择了2'</span>
	<span class="p">;;</span>
	3<span class="p">)</span> <span class="nb">echo</span> <span class="s1">'你选择了3'</span>
	<span class="p">;;</span>
	4<span class="p">)</span> <span class="nb">echo</span> <span class="s1">'你选择了4'</span>
	<span class="p">;;</span>
	<span class="k">*</span><span class="p">)</span> <span class="nb">echo</span> <span class="s1">'你没有输入1到4之间的任何数字'</span>
	<span class="p">;;</span>
<span class="k">esac</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">break</code>命令</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">while </span><span class="nb">true
</span><span class="k">do
	</span><span class="nb">echo</span> <span class="nt">-n</span> <span class="s2">"输入1到5之间的数字"</span>
	<span class="nb">read </span>aNum
	<span class="k">case</span> <span class="nv">$aNum</span> <span class="k">in
		</span>1|2|3|4|5<span class="p">)</span> <span class="nb">echo</span> <span class="s2">"你输入的数字为</span><span class="nv">$aNum</span><span class="s2">!"</span>
		<span class="p">;;</span>
		<span class="k">*</span><span class="p">)</span> <span class="nb">echo</span> <span class="s2">"你输入的数字不是1到5之间的！结束"</span>
			<span class="nb">break</span>
        <span class="p">;;</span>
    <span class="k">esac</span>
<span class="k">done</span>
</pre></table></code></div></div><li><p>shell函数</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="o">[</span><span class="k">function</span><span class="o">]</span> funname <span class="o">[()]</span>
<span class="o">{</span>
	action
	<span class="o">[</span><span class="k">return </span>int]
<span class="o">}</span>
  
<span class="c"># example</span>
demoFun<span class="o">(){</span>
	<span class="nb">echo</span> <span class="s2">"第一个shell函数"</span>
<span class="o">}</span>
demoFun <span class="c"># 调用这个函数</span>
</pre></table></code></div></div><li><p>程序的返回值：执行成功返回0，执行失败则返回其他大小的数值。注意，和C语言不同，shell中0表示true，1表示false</p><p>获取一个程序的变量值，如<code class="language-plaintext highlighter-rouge">$(CMD)</code>会先执行<code class="language-plaintext highlighter-rouge">CMD</code>，获取<code class="language-plaintext highlighter-rouge">CMD</code>的输出并再相应位置进行替换。比如执行<code class="language-plaintext highlighter-rouge">for file in $(ls)</code>，将先执行<code class="language-plaintext highlighter-rouge">ls</code>，然后遍历执行<code class="language-plaintext highlighter-rouge">ls</code>后获得的返回值</p><li><p>进程替换(process substitution)：<code class="language-plaintext highlighter-rouge">&lt;(CMD)</code>将执行<code class="language-plaintext highlighter-rouge">CMD</code>，然后将结果输出到一个临时文件，并把<code class="language-plaintext highlighter-rouge">&lt;()</code>替换为这个文件名。比如<code class="language-plaintext highlighter-rouge">cat &lt;(ls -l)</code>相当于<code class="language-plaintext highlighter-rouge">ls -l | cat</code>，<code class="language-plaintext highlighter-rouge">diff &lt;(CMD1) &lt;(CMD2)</code>是比较这两个<code class="language-plaintext highlighter-rouge">CMD</code>的区别</p><li><p>shell文件包含</p><p>包含外部脚本，以封装一些公用的代码作为一个独立文件</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nb">.</span> file <span class="c"># 注意.和文件名中间有一个空格</span>
<span class="c"># 或者</span>
<span class="nb">source </span>file
</pre></table></code></div></div><li><p>shell通配符(globbing)</p><p>wildcard: 使用<code class="language-plaintext highlighter-rouge">*</code>或<code class="language-plaintext highlighter-rouge">?</code>来进行匹配，比如有<code class="language-plaintext highlighter-rouge">foo1</code>、<code class="language-plaintext highlighter-rouge">foo2</code>、<code class="language-plaintext highlighter-rouge">foo</code>几个文件，<code class="language-plaintext highlighter-rouge">rm foo?</code>将删除<code class="language-plaintext highlighter-rouge">foo1</code>和<code class="language-plaintext highlighter-rouge">foo2</code>，而<code class="language-plaintext highlighter-rouge">rm foo*</code>将删除<code class="language-plaintext highlighter-rouge">foo1</code>、<code class="language-plaintext highlighter-rouge">foo2</code>和<code class="language-plaintext highlighter-rouge">foo</code>等三个文件</p><li><p>花括号<code class="language-plaintext highlighter-rouge">{</code>用来扩展子字符串</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>convert image.<span class="o">{</span>png,jpg<span class="o">}</span>
<span class="c"># will expand to</span>
convert image.png image.jpg
</pre></table></code></div></div></ul><h2 id="shell-tools">Shell Tools</h2><p><code class="language-plaintext highlighter-rouge">tldr</code>: – too long, didn’t read manual cheat sheet for console</p><ul><li><p>寻找文件</p><p><code class="language-plaintext highlighter-rouge">find</code></p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c"># 寻找所有名为src的文件夹</span>
find <span class="nb">.</span> <span class="nt">-name</span> src <span class="nt">-type</span> d
<span class="c"># 寻找所有路径名中有test文件夹的Python文件</span>
find <span class="nb">.</span> <span class="nt">-path</span> <span class="s1">'*/test/*.py'</span> <span class="nt">-type</span> f
<span class="c"># 寻找所有在昨天被修改的文件</span>
find <span class="nb">.</span> <span class="nt">-mtime</span> <span class="nt">-l</span>
<span class="c"># 寻找所有大小在500k到10M的zip文件</span>
find <span class="nb">.</span> <span class="nt">-size</span> +500k <span class="nt">-size</span> <span class="nt">-10M</span> <span class="nt">-name</span> <span class="s1">'*.tar.gz'</span>
<span class="c"># 删除所有.tmp扩展名的文件。-exec表示在find寻找到这些文件之后可以执行的额外动作，\;表示这些额外动作的结束。{}用来指代前面find到的文件</span>
find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.tmp'</span> <span class="nt">-exec</span> <span class="nb">rm</span> <span class="o">{}</span> <span class="se">\;</span>
<span class="c"># 将所有PNG文件转化为JPG文件</span>
find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.png'</span> <span class="nt">-exec</span> convert <span class="o">{}</span> <span class="o">{}</span>.jpg <span class="se">\;</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">fd</code>是更好的<code class="language-plaintext highlighter-rouge">find</code>，支持正则表达式查找</p><p><code class="language-plaintext highlighter-rouge">locate</code>是一个使用<code class="language-plaintext highlighter-rouge">updatedb</code>更新的数据库进行文件查找的程序，效率比<code class="language-plaintext highlighter-rouge">find</code>和<code class="language-plaintext highlighter-rouge">fd</code>更高，但是因为是每日更新的，所以并不是最新的。</p><p><code class="language-plaintext highlighter-rouge">grep</code>是基于文件内容进行搜索，<code class="language-plaintext highlighter-rouge">grep -C</code>是获取匹配内容的上下文(<strong>C</strong>ontext)，比如<code class="language-plaintext highlighter-rouge">grep -C 5</code>是获取匹配内容的上下各5行内容，<code class="language-plaintext highlighter-rouge">grep -R</code>是递归(<strong>R</strong>ecursively)地进入文件夹查找文件中的内容，<code class="language-plaintext highlighter-rouge">grep -v</code>用来反向(in<strong>v</strong>ersely)选择匹配的内容</p><p><code class="language-plaintext highlighter-rouge">rg</code>、<code class="language-plaintext highlighter-rouge">ag</code>等也是和<code class="language-plaintext highlighter-rouge">grep</code>类似的查找工具，其中<code class="language-plaintext highlighter-rouge">ripgrep(rg)</code>是一个查找神器，用来查找代码中的code snippet，可以进行自动递归搜索，自动故忽略.gitignore中的文件和二进制文件，例如</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>rg <span class="nt">-t</span> py <span class="s2">"import request"</span>
</pre></table></code></div></div><p>查找所有包含<code class="language-plaintext highlighter-rouge">import request</code>的python文件</p><p><code class="language-plaintext highlighter-rouge">history</code>可以用来查看shell中的所有交互记录，<code class="language-plaintext highlighter-rouge">history | grep find</code>则可以打印出过去曾经使用的<code class="language-plaintext highlighter-rouge">find</code>命令</p><p>在shell中可以按<kbd>CTRL</kbd>+<kbd>R</kbd>来进行反向搜索历史，通过键入一个子字符串来搜索过去的命令</p><p><code class="language-plaintext highlighter-rouge">fzf</code>是一个模糊搜索工具(fuzzy finder)</p><p><code class="language-plaintext highlighter-rouge">zsh</code>：一种非常牛逼的shell，可以实现根据历史的命令来进行自动命令建议</p><p><code class="language-plaintext highlighter-rouge">fasd</code>是快速跳转路径的工具，可以根据访问频率来自动给出跳转路径的建议</p></ul><h1 id="lecture-3-vim">Lecture 3 Vim</h1><h2 id="快捷键">快捷键</h2><ul><li>normal mode下<kbd>G</kbd>: 跳转到文件的最后一行<li><code class="language-plaintext highlighter-rouge">gg</code>跳转到文件的第一行<li><kbd>w</kbd>：下一个word，<kbd>b</kbd>beginning of word、<kbd>e</kbd>：end of word<li><kbd>$</kbd>：跳转到行尾，<kbd>^</kbd>跳转到行首<li><kbd>^u</kbd>：向上滚动 <kbd>^d</kbd>：向下滚动<li><kbd>h</kbd>：光标左移 <kbd>j</kbd>：光标下移 <kbd>k</kbd>：光标上移 <kbd>l</kbd>：光标右移<li><code class="language-plaintext highlighter-rouge">:sp file</code>：水平方向分割窗口，并打开file<li><code class="language-plaintext highlighter-rouge">:vsp file</code>：垂直方向分割窗口，并打开file<ul><li><code class="language-plaintext highlighter-rouge">^ww</code>：在打开的分割窗口之间切换</ul><li><kbd>/</kbd>：搜索字符串，按<kbd>n</kbd>跳转到下一个匹配，按<kbd>N</kbd>跳转到上一个匹配，可以进行<code class="language-plaintext highlighter-rouge">/{regex}</code>正则表达式搜索<li><kbd>c</kbd>：change，即删掉选中的字符，然后进入Insert模式<li><kbd>d</kbd>：delete，即删掉选中的字符<li><kbd>u</kbd>：undo <kbd>^r</kbd>: redo<li><kbd>v</kbd>：进入visual模式，可以通过光标移动来进行文本块的选择<li><kbd>.</kbd>：重复之前的键入<li><kbd>o</kbd>(open)：<font color="red">在下方键入新行</font><li><code class="language-plaintext highlighter-rouge">:n</code>：跳转到第n行<li><code class="language-plaintext highlighter-rouge">:%d</code>：删除所有行，其中<code class="language-plaintext highlighter-rouge">%</code>表示所有行 <code class="language-plaintext highlighter-rouge">:2,8d</code>表示删除第2到第8行<li>modifier: <kbd>i</kbd>(inside)或<kbd>a</kbd>(around)，比如<code class="language-plaintext highlighter-rouge">ci[</code>就是删除[]内的所有字符并进入insert模式，<code class="language-plaintext highlighter-rouge">ca(</code>就是删除()内以及()本身这些所有的字符并且进入insert模式<li>counts: 在命令前面加上数字来表示重复动作，比如<code class="language-plaintext highlighter-rouge">3w</code>是向后跳转3个word，<code class="language-plaintext highlighter-rouge">5j</code>是向下跳转5行</ul><h2 id="插件推荐">插件推荐</h2><p>CtrlP: 一种能够在vim中模糊查找工程文件的vim插件</p><p>fugitive.vim: vim的git插件</p><p>ale：code linting插件，需要先安装pylint和eslint等linting插件</p><p><code class="language-plaintext highlighter-rouge">sudo apt-get install vim-gtk</code>：系统自带vim不支持复制到系统剪切板，需要重装vim</p><p>可以安装vim-airline这款主题美化插件 NERDTree目录树，在vim normal模式键入<code class="language-plaintext highlighter-rouge">:NERDTree</code>即可打开目录树，<code class="language-plaintext highlighter-rouge">:q</code>关闭目录树</p><p>在<code class="language-plaintext highlighter-rouge">/etc/vim/vimrc</code>最后增加以使vim使用系统剪切板</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="s2">" WSL yank support
let s:clip = '/mnt/c/Windows/System32/clip.exe'  "</span> change this path according to your mount point
<span class="k">if </span>executable<span class="o">(</span>s:clip<span class="o">)</span>
    augroup WSLYank
        autocmd!
        autocmd TextYankPost <span class="k">*</span> <span class="k">if </span>v:event.operator <span class="o">==</span><span class="c"># 'y' | call system(s:clip, @0) | endif</span>
    augroup END
endif
</pre></table></code></div></div><h1 id="lecture-4-data-wrangling">Lecture 4 Data Wrangling</h1><h2 id="regex">RegEx</h2><ul><li><code class="language-plaintext highlighter-rouge">+</code>表示前面的字符必须出现一次或者多次<li><code class="language-plaintext highlighter-rouge">*</code>表示前面的字符可以出现0次、1次或者多次<li><code class="language-plaintext highlighter-rouge">?</code>表示前面的字符可以出现0次或1次，加在<code class="language-plaintext highlighter-rouge">+</code>和<code class="language-plaintext highlighter-rouge">*</code>后面以实现非贪婪匹配<li><code class="language-plaintext highlighter-rouge">[abc]</code>表示匹配其中的所有<code class="language-plaintext highlighter-rouge">abc</code>三个字符<li><code class="language-plaintext highlighter-rouge">[^abc]</code>表示匹配除了a、b、c之外的其他所有字符<li><code class="language-plaintext highlighter-rouge">[A-Z]</code>表示一个区间，匹配所有大写字母<li><code class="language-plaintext highlighter-rouge">[\s]</code>匹配所有空白符 <code class="language-plaintext highlighter-rouge">[\S]</code>匹配所有非空白符，<code class="language-plaintext highlighter-rouge">[\s\S]</code>匹配所有字符<li><code class="language-plaintext highlighter-rouge">[\d]</code>，digit，匹配[0-9]的数字，<code class="language-plaintext highlighter-rouge">[\D]</code>匹配所有非数字<li><code class="language-plaintext highlighter-rouge">.</code>匹配除了换行符<code class="language-plaintext highlighter-rouge">\n</code>之外的所有字符<li><p><code class="language-plaintext highlighter-rouge">[\w]</code>word，匹配字母、数字、下划线，等价于<code class="language-plaintext highlighter-rouge">[a-zA-Z0-9_]</code></p><li><code class="language-plaintext highlighter-rouge">()</code>标记一个子表达式的开始和结束位置，子表达式可以获取供以后使用<li>非捕获元：<code class="language-plaintext highlighter-rouge">?:</code>放在<code class="language-plaintext highlighter-rouge">()</code>中可以避免匹配被缓存，<code class="language-plaintext highlighter-rouge">exp1(?=exp2)</code>正向肯定预查，查找exp2前的exp1，<code class="language-plaintext highlighter-rouge">(?&lt;=exp2)exp1</code>查找exp2后的exp1，<code class="language-plaintext highlighter-rouge">exp1(?!exp2)</code>查找后面不是exp2的exp1，<code class="language-plaintext highlighter-rouge">(?&lt;!exp2)exp1</code>查找前面不是exp2的exp1 只有<code class="language-plaintext highlighter-rouge">grep -P</code>才支持<li><code class="language-plaintext highlighter-rouge">{}</code>限定符表达式，用来表示匹配的长度，比如<code class="language-plaintext highlighter-rouge">s{1,3}</code>表示匹配1-3个空格，<code class="language-plaintext highlighter-rouge">o{1,}</code>表示匹配1个以上的o<li><code class="language-plaintext highlighter-rouge">^</code>：定位符，匹配输入字符串开始位置，不要和中括号表达式中的^混淆。<code class="language-plaintext highlighter-rouge">$</code>：定位符，匹配输入字符串结束位置<li><p><code class="language-plaintext highlighter-rouge">\b</code>：定位符，匹配单词边界 <code class="language-plaintext highlighter-rouge">\B</code>：定位符，匹配非单词边界</p><li><p>修饰符：写在正则表达式之外，用于指定额外的匹配策略<code class="language-plaintext highlighter-rouge">\pattern\flags</code></p><p><code class="language-plaintext highlighter-rouge">i</code>-ignore，不区分大小写 <code class="language-plaintext highlighter-rouge">g</code>-global，查找所有的匹配项 <code class="language-plaintext highlighter-rouge">m</code>-multiline，多行匹配，使<code class="language-plaintext highlighter-rouge">^</code>和<code class="language-plaintext highlighter-rouge">$</code>匹配一段文本中每行的开始和结束位置</p></ul><h2 id="use-case">use case</h2><ul><li><p>获取尝试连接远程服务器的用户名</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>ssh myserver <span class="s1">'journalctl | grep sshd | grep "Disconnected from"'</span> | less <span class="c"># journalctl是日志管理工具 journalctl和from之间的''quoting是为了直接在服务器来查找这些内容，再把筛选好的内容传送到本地</span>
</pre></table></code></div></div><li><p><code class="language-plaintext highlighter-rouge">sed</code>: stream editor流编辑器，利用命令行对文件进行修改</p><p><code class="language-plaintext highlighter-rouge">s</code>命令：substitution，用法：<code class="language-plaintext highlighter-rouge">s/REGEX/SUBSTITUTION</code>比如</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>ssh myserver journalctl
| <span class="nb">grep </span>ssh
| <span class="nb">grep</span> <span class="s2">"Disconnected from"</span>
| <span class="nb">sed</span> <span class="s1">'s/.*Disconnected from //'</span>  <span class="c"># 删除所有'Disconnected from'</span>
</pre></table></code></div></div><li><p>提取用户名</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>| <span class="nb">sed</span> <span class="nt">-E</span> <span class="s1">'s/.*?Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'</span>
</pre></table></code></div></div><li><p>排列用户名，列出用户名出现重复的次数</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>ssh myserver journalctl
 | <span class="nb">grep </span>sshd
 | <span class="nb">grep</span> <span class="s2">"Disconnected from"</span>
 | <span class="nb">sed</span> <span class="nt">-E</span> <span class="s1">'s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'</span>
 | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span>
</pre></table></code></div></div><p>其中<code class="language-plaintext highlighter-rouge">sort</code>可以对输入的字符串组进行排序，<code class="language-plaintext highlighter-rouge">uniq -c</code>将所有重复的条目去掉，对每个条目只保留一次，并且将每个条目重复的次数打印</p><li><p>对这个重复的次数进行排序，并打印出重复次数最多的前10个条目</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>| <span class="nb">sort</span> <span class="nt">-nk1</span>,1 | <span class="nb">tail</span> <span class="nt">-n10</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">sort -n</code>将会对数字进行排列，<code class="language-plaintext highlighter-rouge">-k1,1</code>表明只对以空白键分割的第一列进行排序</p><li><p>将以上筛选出的用户名以逗号分隔，打印成一行输出</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>| <span class="nb">awk</span> <span class="s1">'{print $2}'</span> | <span class="nb">paste</span> <span class="nt">-sd</span>,
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">paste -s</code>可以将多行合并为一行，<code class="language-plaintext highlighter-rouge">-d,</code>表明分隔符delimiter是<code class="language-plaintext highlighter-rouge">,</code>。</p><p><code class="language-plaintext highlighter-rouge">awk</code>是一种文字流处理编程语言，与<code class="language-plaintext highlighter-rouge">sed</code>、<code class="language-plaintext highlighter-rouge">grep</code>合并成为Linux三剑客，<code class="language-plaintext highlighter-rouge">sed</code>擅长对一行进行处理以及进行替换，<code class="language-plaintext highlighter-rouge">grep</code>擅长查找，<code class="language-plaintext highlighter-rouge">awk</code>擅长对列进行处理</p><li><p>筛选出所有只出现过一次的名称以c开头e结尾的用户名并统计数量</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>| <span class="nb">awk</span> <span class="s1">'$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ {print $2}'</span> | <span class="nb">wc</span> <span class="nt">-l</span>
</pre></table></code></div></div><li><p><code class="language-plaintext highlighter-rouge">xargs</code>：将找到的文本作为命令行的参数</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>rustup toolchain list | <span class="nb">grep </span>nightly | <span class="nb">grep</span> <span class="nt">-vE</span> <span class="s2">"nightly-x86"</span> | <span class="nb">sed</span> <span class="s1">'s/-x86.*//'</span> | xargs rustup toolchain uninstall
</pre></table></code></div></div><p>有的命令可以接受标准输入作为参数，比如<code class="language-plaintext highlighter-rouge">grep</code>，这样就可以使用管道命令<code class="language-plaintext highlighter-rouge">|</code>，比如<code class="language-plaintext highlighter-rouge">cat /etc/passwd | grep root</code>相当于<code class="language-plaintext highlighter-rouge">grep root /etc/passwd</code>，但是大多数命令不接受标准输入作为参数，只能直接在命令行输入参数，比如<code class="language-plaintext highlighter-rouge">echo</code>，因此<code class="language-plaintext highlighter-rouge">xargs</code>就是将标准输入转为命令行参数，比如</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"hello world"</span> | xargs <span class="nb">echo
</span>hello world
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">xargs</code>的默认命令是<code class="language-plaintext highlighter-rouge">echo</code>，即<code class="language-plaintext highlighter-rouge">xargs</code>=<code class="language-plaintext highlighter-rouge">xargs echo</code></p><p>http://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html</p><li><p>对二进制的wrangling</p><p>用ffmpeg来从摄像头捕获图像，转化为灰度图，压缩，通过ssh发送到远程服务器并在远程服务器上解压，复制并展示</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>ffmpeg <span class="nt">-loglevel</span> panic <span class="nt">-i</span> /dev/video0 <span class="nt">-frames</span> 1 <span class="nt">-f</span> image2 - | convert - <span class="nt">-colorspace</span> gray - | <span class="nb">gzip</span>
| ssh mymachine <span class="s1">'gzip -d | tee copy.jpg | env DISPLAY=:0 feh -'</span>
</pre></table></code></div></div></ul><h2 id="exercise">Exercise</h2><ul><li><p>查找<code class="language-plaintext highlighter-rouge">/usr/share/dict/words</code>下含有至少3个a并且不以’s结尾的单词的个数</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">grep</span> <span class="nt">-P</span> <span class="s2">"(.*a){3,}.*(?&lt;!'s)$"</span> /usr/share/dict/words | <span class="nb">wc</span> <span class="nt">-l</span>
</pre></table></code></div></div><p>其中<code class="language-plaintext highlighter-rouge">grep -P</code>是以perl语法输入正则表达式，以开启<code class="language-plaintext highlighter-rouge">?&lt;!</code></p><p>结尾出现频率最高的两个字母是什么？ 找出前三名</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">grep</span> <span class="nt">-P</span> <span class="s2">"(.*a){3,}.*(?&lt;!'s)$"</span> /usr/share/dict/words | <span class="nb">sed</span> <span class="nt">-E</span> <span class="s1">'s/.*(\w\w)/\1/g'</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nk1</span>,1 | <span class="nb">tail</span> <span class="nt">-n3</span>
</pre></table></code></div></div></ul><h1 id="lecture-5-command-line-environment">Lecture 5 Command Line Environment</h1><h2 id="job-control">Job control</h2><p>UNIX使用<code class="language-plaintext highlighter-rouge">signal</code>来和进程进行通信，<code class="language-plaintext highlighter-rouge">signal</code>起到中断作用</p><p><code class="language-plaintext highlighter-rouge">^C</code>向进程发出<code class="language-plaintext highlighter-rouge">SIGINT</code>指令，<code class="language-plaintext highlighter-rouge">^\</code>向进程发出<code class="language-plaintext highlighter-rouge">SIGQUIT</code>指令。程序会产生core文件，相当于程序错误，<code class="language-plaintext highlighter-rouge">kill -TERM &lt;PID&gt;</code>向进程发出<code class="language-plaintext highlighter-rouge">SIGTERM</code>指令，该信号可以被阻塞和处理，通常用来要求程序自己正常退出，<code class="language-plaintext highlighter-rouge">SIGSTOP</code>是暂停进程</p><p>下述python指令将忽略<code class="language-plaintext highlighter-rouge">^C</code>的<code class="language-plaintext highlighter-rouge">SIGINT</code>指令</p><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">#!/usr/bin/env python
</span><span class="kn">import</span> <span class="nn">signal</span><span class="p">,</span> <span class="n">time</span>

<span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">I got a SIGINT, but I am not stopping"</span><span class="p">)</span>

<span class="n">signal</span><span class="p">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="p">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span> <span class="c1"># attach SIGINT to handler
</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(.</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\r</span><span class="s">{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s">""</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">^Z</code>向shell发出一个<code class="language-plaintext highlighter-rouge">SIGTSTP</code>来暂停一个进程，使用<code class="language-plaintext highlighter-rouge">fg</code>或<code class="language-plaintext highlighter-rouge">bg</code>命令来把暂停的进程放在前台或者后台运行，比如<code class="language-plaintext highlighter-rouge">bg %1</code></p><p><code class="language-plaintext highlighter-rouge">jobs</code>用来列出所有当前终端对话尚未完成的任务，可以使用<code class="language-plaintext highlighter-rouge">pgrep</code>来获取这些任务的PID，也可以使用<code class="language-plaintext highlighter-rouge">%1</code>、<code class="language-plaintext highlighter-rouge">%2</code>等获取对这些任务的引用</p><p>可以在所有任务的最后增加一个<code class="language-plaintext highlighter-rouge">&amp;</code>后缀来使命令跑在后台</p><p>直接<code class="language-plaintext highlighter-rouge">kill %1</code>来终止第1个任务</p><h2 id="terminal-multiplexers">Terminal Multiplexers</h2><p><code class="language-plaintext highlighter-rouge">tmux</code>可以在一个终端窗口下使用多个pane和tab</p><p>keybinding: 默认情况下是<code class="language-plaintext highlighter-rouge">^b</code>。</p><ul><li>Session：独立的工作区，<ul><li><code class="language-plaintext highlighter-rouge">tmux</code>：来启动一个新的session<li><code class="language-plaintext highlighter-rouge">tmux new -s NAME</code>：启动一个指定了名称的session<li><code class="language-plaintext highlighter-rouge">tmux ls</code>：列出现在的所有session<li>在<code class="language-plaintext highlighter-rouge">tmux</code>里按下<code class="language-plaintext highlighter-rouge">^b d</code>来从当前的session中detach<li><code class="language-plaintext highlighter-rouge">tmux a</code>来attach到上一个session</ul><li>Windows：相当于浏览器中的tab，属于同一个session<ul><li><code class="language-plaintext highlighter-rouge">^b c</code>create一个新的窗口，通过<code class="language-plaintext highlighter-rouge">^d</code>来关闭这个窗口<li><code class="language-plaintext highlighter-rouge">^b N</code>前往第N个窗口，N为数字<li><code class="language-plaintext highlighter-rouge">^b p</code>前往前一个窗口<li><code class="language-plaintext highlighter-rouge">^b n</code>前往下一个窗口</ul><li>Panes：相当于vim中的split界面<ul><li><code class="language-plaintext highlighter-rouge">^b "</code>水平分割窗口，<code class="language-plaintext highlighter-rouge">^d</code>退出当前窗口<li><code class="language-plaintext highlighter-rouge">^b %</code>垂直分割窗口<li><code class="language-plaintext highlighter-rouge">^b &lt;arrow&gt;</code>跳转窗口<li><code class="language-plaintext highlighter-rouge">^b &lt;space&gt;</code>在不同的窗口设计中选择</ul></ul><h2 id="aliases">Aliases</h2><p>命令的代换(aliasing)</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">alias </span><span class="nv">alias_name</span><span class="o">=</span><span class="s2">"command_to_alias arg1 arg2"</span>
</pre></table></code></div></div><p>注意<code class="language-plaintext highlighter-rouge">=</code>左右两边没有空格</p><p>e.g.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>alisa <span class="nv">ll</span><span class="o">=</span><span class="s2">"ls -lh"</span>
<span class="nb">alias </span><span class="nv">gs</span><span class="o">=</span><span class="s2">"git status"</span>
<span class="nb">alias </span><span class="nv">gc</span><span class="o">=</span><span class="s2">"git commit"</span>
<span class="nb">alias </span><span class="nv">v</span><span class="o">=</span><span class="s2">"vim"</span>
</pre></table></code></div></div><p>上述alias命令在shell关闭之后会自动重设，可以在<code class="language-plaintext highlighter-rouge">.bashrc</code>或者<code class="language-plaintext highlighter-rouge">.zshrc</code>中写入相关的alias来使设置永久有效</p><h2 id="dotfiles">Dotfiles</h2><p>很多程序使用纯文本文件dotfile来对程序进行配置，比如<code class="language-plaintext highlighter-rouge">.vimrc</code>，这些文件默认隐藏在目录中。对bash程序来说，<code class="language-plaintext highlighter-rouge">.bashrc</code>或<code class="language-plaintext highlighter-rouge">.bash_profile</code>是默认配置bash设置的文件。在很多程序中要求dotfile指定一个二进制可执行文件的路径</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PATH</span><span class="s2">:/path/to/program/bin"</span>
</pre></table></code></div></div><p>可以将所有的dotfile放在一个文件夹下，进行版本控制，并且symlink它们，这样可以方便在不同的机器上将自定义的设置进行迁移</p><p>可以参考github上一些比较受欢迎的dotfile repo，例如https://github.com/mathiasbynens/dotfiles</p><p>为了提高dotfile的可移植性，可以在dotfile中增加一些条件判断语句，例如</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">uname</span><span class="si">)</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"Linux"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> <span class="o">{</span>do_something<span class="o">}</span><span class="p">;</span> <span class="k">fi</span>

<span class="c"># Check before using shell-specific features</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$SHELL</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"zsh"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> <span class="o">{</span>do_something<span class="o">}</span><span class="p">;</span> <span class="k">fi</span>

<span class="c"># You can also make it machine-specific</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">hostname</span><span class="si">)</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"myServer"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> <span class="o">{</span>do_something<span class="o">}</span><span class="p">;</span> <span class="k">fi</span>
</pre></table></code></div></div><p>如果想让zsh和bash使用同一个alias配置，可以在<code class="language-plaintext highlighter-rouge">.bashrc</code>和<code class="language-plaintext highlighter-rouge">.zshrc</code>文件中加入相同的</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">[</span> <span class="nt">-f</span> ~/.aliases <span class="o">]</span><span class="p">;</span> <span class="k">then
	</span><span class="nb">source</span> ~/.aliases
<span class="k">fi</span>
</pre></table></code></div></div><ul><li>p.s. <code class="language-plaintext highlighter-rouge">source &lt;filename&gt;</code>和<code class="language-plaintext highlighter-rouge">./&lt;filename</code>的区别在于<code class="language-plaintext highlighter-rouge">source</code>是直接在当前SHELL session中执行的，而<code class="language-plaintext highlighter-rouge">./</code>是新起了一个session</ul><h2 id="remote-machines">Remote machines</h2><ul><li><p>SSH(secure shell)</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>ssh user@ip_address|url_of_server <span class="o">[</span><span class="nb">command</span><span class="o">]</span> <span class="c"># [command]表示在远程服务器中执行这个命令，然后返回到本地服务器</span>
</pre></table></code></div></div><li><p>SSH config: 客户端SSH配置文件<code class="language-plaintext highlighter-rouge">/etc/ssh/ssh_config</code>。服务端SSH配置文件<code class="language-plaintext highlighter-rouge">/etc/ssh/sshd_config</code></p><li><p>SSH keys：SSH服务器持有公钥，客户端持有私钥，这样就不需要每次SSH到服务器时重新键入密码了。SSH key passphrase是为了防止别人持有你的私钥采用的加密措施</p><li><p>通过SSH来复制文件</p><ul><li><p>最简单的方法是：<code class="language-plaintext highlighter-rouge">ssh+tee</code>，e.g. <code class="language-plaintext highlighter-rouge">cat localfile | ssh remote_server tee serverfile</code> <code class="language-plaintext highlighter-rouge">tee</code>和<code class="language-plaintext highlighter-rouge">cat</code>正好相反，<code class="language-plaintext highlighter-rouge">tee</code>用于读取标准输入，将其内容输出成文件，而<code class="language-plaintext highlighter-rouge">cat</code>用于读取文件，将其输出成标准输出</p><li>secure copy <code class="language-plaintext highlighter-rouge">scp</code>：可以recurse over path，<code class="language-plaintext highlighter-rouge">scp path/to/local_file remote_host:path/to/remote_file</code><li><code class="language-plaintext highlighter-rouge">rsync</code>是<code class="language-plaintext highlighter-rouge">scp</code>基础上的提升，可以检测到本地和远程文件的相同文件，并不对它们进行重复复制。<code class="language-plaintext highlighter-rouge">rsync</code>的语法和<code class="language-plaintext highlighter-rouge">scp</code>类似</ul><li><p>SSH port forwarding端口转发</p><p>如果在本地的应用向某个被绑定的端口发送数据，则这些数据将自动通过SSH被转发到远程服务器的另一个被绑定端口并做本地调用</p><ul><li><p>Dynamic Tunneling (SOCKS proxy)</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>ssh <span class="nt">-D</span> 8080 remote_server
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://img2018.cnblogs.com/blog/737565/201906/737565-20190626160953099-1803945874.png" alt="img" /></p><p>在192.168.56.101的浏览器中输入http://localhost时，这个http request会被发送到8080端口，但是由于SOCKS Proxy在8080端口监听，并把这个HTTP request转发给了SSH Client，SSH Client通过SSH将这个HTTP request发送给了102的SSH服务器，102在本地解析运行这个HTTP请求，由于HTTP默认使用80端口，如果102有apache绑定在其80端口上提供服务的话，那么apache服务器将接受这个对localhost的访问请求，返回相应的web服务页面</p><li><p>local port forwarding</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>ssh <span class="nt">-L</span> &lt;<span class="nb">local </span>port&gt;:&lt;remote <span class="nb">hostname</span><span class="o">&gt;</span>:&lt;remote service port&gt; user@remoteserver
</pre></table></code></div></div><p>比如</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>ssh <span class="nt">-L</span> 8000:localhost:80 ramki@192.168.56.102
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://img2018.cnblogs.com/blog/737565/201906/737565-20190626163533740-1419568633.png" alt="img" /></p><p>client端绑定了8000端口，任何发送到8000端口的数据都将通过SSH客户端通过22端口发送到SSH服务端，由于绑定了远程服务器的80端口，因此远程服务端将把22端口的数据转发到80端口上。在dynamic tunneling模式中，服务器会检查packet并自动决定该packet发往哪个端口，比如HTTP request发往80端口，SMTP发往25端口，但是local port forwarding将发往指定的端口</p><li><p>remote port forwarding</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>ssh <span class="nt">-R</span> &lt;remote port&gt;:&lt;<span class="nb">local hostname</span><span class="o">&gt;</span>:&lt;<span class="nb">local </span>port&gt; user@remoteserver
</pre></table></code></div></div><p>把所有尝试发送到远程服务器指定端口的数据从&lt;local hostname&gt;的&lt;local port&gt;发送</p></ul><li><p>Exercise</p><p>写一个脚本，以实现<code class="language-plaintext highlighter-rouge">wait [PID]</code>的功能</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c">#!/bin/bash</span>
<span class="k">while</span> :
<span class="k">do
	</span><span class="nb">kill</span> <span class="nt">-0</span> <span class="nv">$1</span>  <span class="c"># $1 为脚本后面跟的第一个参数，也就是PID。kill -0是尝试杀这个进程，如果这个进程不存在就会返回1，否则返回0，但是不会实际去杀掉这个进程</span>
	<span class="k">if</span> <span class="o">[[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]]</span>
	<span class="k">then
		</span><span class="nb">break
	</span><span class="k">fi
	</span><span class="nb">sleep </span>1
<span class="k">done
</span><span class="nb">ls</span> <span class="nt">-al</span>
</pre></table></code></div></div></ul><h1 id="lecture-6-version-control">Lecture 6 Version Control</h1><h2 id="git-data-model">Git data model</h2><ul><li><p>文件：blob，本质是<code class="language-plaintext highlighter-rouge">array&lt;byte&gt;</code></p><li><p>目录：tree，本质是<code class="language-plaintext highlighter-rouge">map&lt;string, blob | tree&gt;</code></p><li><p>快照(snapshot)：也被称为commits，本质是被追踪的最高一级tree (root)。commits无法被改变</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>type commit = struct {
	parent: array&lt;commit&gt;
	author: string  // metadata
	message: string // metadata
	snapshot: tree
}
</pre></table></code></div></div><li><p>历史：DAG(directed acyclic graph) of snapshots，每个历史中的snapshot都指向它们的父节点，父节点可以不止一个，因为当merge的时候就会出现两个父节点</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>o &lt;-- o &lt;-- o &lt;-- o &lt;---- o
            ^            /
             \          v
              --- o &lt;-- o
</pre></table></code></div></div><li><p>对象(object)：<code class="language-plaintext highlighter-rouge">type object = blob | tree | commit</code></p><p>所有对象都用SHA-1 hash来引用</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>objects = map&lt;string, object&gt;
  
def store(object):
	id = sha1(object)
	objects[id] = object
  	
def load(id):
	return objects[id]
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">git cat-file &lt;SHA1&gt;</code>就相当于上面的<code class="language-plaintext highlighter-rouge">load(id)</code>函数</p><li><p>引用(reference)：对commit的指针(比如master)，由于commit是SHA-hash码，人类难以记住，因此使用reference这种人类可读的字符串来指向commit，reference是可以改变的，即可以更改指向的commit。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>references = map&lt;string, string&gt;
  
def update_reference(name, id):
	references[name] = id
  
def read_reference(name):
	return reference[name]
  
def load_reference(name_or_id):
	if name_or_id in references:  // is name
		return load(references[name_or_id])
    else:  // is id
    	return load(name_or_id)
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">HEAD</code>：一个特殊的reference，用于指向我们目前看的commit</p><li><p>仓库(repository)：objects和references的集合</p><p>所有的<code class="language-plaintext highlighter-rouge">git</code>命令都是通过加入object和加入/更新references来对DAG进行操作</p></ul><h2 id="git-command-line-interface">Git command-line interface</h2><p>基础命令</p><ul><li><p><code class="language-plaintext highlighter-rouge">git init</code>：创建一个新的git仓库，数据存储在<code class="language-plaintext highlighter-rouge">.git</code>文件夹中</p><li><p><code class="language-plaintext highlighter-rouge">git status</code>：查看目前git的状态</p><li><p><code class="language-plaintext highlighter-rouge">git add &lt;filename&gt;</code>：将文件添加到staging area</p><li><p><code class="language-plaintext highlighter-rouge">git commit</code>：增加一个新的commit</p><p><code class="language-plaintext highlighter-rouge">git commit -a</code>表示automatically将所有之前已经追踪过的文件进行<code class="language-plaintext highlighter-rouge">git add</code>，从而省去<code class="language-plaintext highlighter-rouge">git add</code>的步骤</p><li><p><code class="language-plaintext highlighter-rouge">git log --all --graph --decorate</code>：将git历史以DAG展现出来</p><p><code class="language-plaintext highlighter-rouge">git log -p -2</code>显示历史中的最后2个commit的差异(patch)</p><p><code class="language-plaintext highlighter-rouge">git log --pretty=oneline</code>：将每个commit的信息用一行显示</p><p>过滤输出：<code class="language-plaintext highlighter-rouge">git log --since=2.weeks</code>：仅打印过去2周到现在的所有commit历史 <code class="language-plaintext highlighter-rouge">--grep</code>可以在commit信息中查找关键词进行输出过滤</p><p><code class="language-plaintext highlighter-rouge">git log -S function_name</code>：只显示最后一个修改了某个特定函数的commit</p><p><code class="language-plaintext highlighter-rouge">git log -- path/to/file</code>：显示修改了这个文件的commit</p><li><p><code class="language-plaintext highlighter-rouge">git diff &lt;filename&gt;</code>：显示某个working directory中的文件和staging area中的差异</p><p><code class="language-plaintext highlighter-rouge">git diff --staged</code>：显示在staging area中的文件和上次commit中的文件的差异</p><p><code class="language-plaintext highlighter-rouge">git diff &lt;version&gt; &lt;filename&gt;</code>：显示某个文件不同commit中的差异</p><li><p><code class="language-plaintext highlighter-rouge">git checkout &lt;version&gt;</code>：将HEAD移动到这个版本的commit</p><li><p><code class="language-plaintext highlighter-rouge">git rm &lt;filename&gt;</code>：相当于删除某个文件，并从staging area中将其删除(但是还没有commit)</p><p>如果想要在工作区中<font color="red">保留</font>这个文件，但是从staging area中将其删除，使用<code class="language-plaintext highlighter-rouge">git rm --cached &lt;filename&gt;</code>，比如<code class="language-plaintext highlighter-rouge">git rm log/\*.log</code>可以删除所有log/目录下的.log后缀的文件，注意要在*前加一个\号</p><li><p><code class="language-plaintext highlighter-rouge">git tag</code>：显示所有标签，<code class="language-plaintext highlighter-rouge">git tag -l "v1.8.6*"</code>显示所有1.8.6版本系列的标签</p><p>为某一个commit创建一个新的annotated tag（一次正式的发布，包含了创建日期、名称和邮箱、GPG签名等信息）：<code class="language-plaintext highlighter-rouge">git tag -a v1.4 -m "my version 1.4" &lt;shachecksum&gt;</code></p><p>创建一个新的lightweight tag（仅仅是为一个commit对象起了一个别名，不包含任何其他信息）：<code class="language-plaintext highlighter-rouge">git tag &lt;tag name&gt;</code></p><p>默认情况下<code class="language-plaintext highlighter-rouge">git push</code>时不会将tag推送到远程，可以采用<code class="language-plaintext highlighter-rouge">git push origin --tags</code>来将tag推送</p><p><code class="language-plaintext highlighter-rouge">git tag -d &lt;tag name&gt;</code>删除某个标签</p></ul><p>分支和合并命令</p><ul><li><p><code class="language-plaintext highlighter-rouge">git branch</code>：显示目前所有的分支</p><li><p><code class="language-plaintext highlighter-rouge">git branch &lt;name&gt;</code>：创建一个新的分支</p><li><p><code class="language-plaintext highlighter-rouge">git branch -d &lt;name&gt;</code>：删除某个分支</p><li><p><code class="language-plaintext highlighter-rouge">git checkout -b &lt;name&gt;</code>：创建一个新的分支并且切换到这个分支，相当于<code class="language-plaintext highlighter-rouge">git branch &lt;name&gt;; git checkout &lt;name&gt;</code>，可以用<code class="language-plaintext highlighter-rouge">git switch -c &lt;name&gt;</code>代替</p><li><p><code class="language-plaintext highlighter-rouge">git merge &lt;revision&gt;</code>：将&lt;revision&gt;合并到当前分支</p><li><p><code class="language-plaintext highlighter-rouge">git mergetool</code>：使用合并工具来帮助处理合并冲突</p><li><p><code class="language-plaintext highlighter-rouge">git rebase</code>：也可以达到合并分支的效果，但是和merge不同的是分叉会被取消</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6_null_notes/MIT_6_null_notes.assets\image-20210108205905552.png" alt="image-20210108205905552" /></p></ul><p><code class="language-plaintext highlighter-rouge">git merge</code>：origin和mywork产生了分叉</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6_null_notes/MIT_6_null_notes.assets\image-20210108205951126.png" alt="image-20210108205951126" /></p><p><code class="language-plaintext highlighter-rouge">git rebase</code>：没有分叉，Commit5’和6‘以补丁的形式存在，放在./git/rebase目录中</p><p>远程命令</p><p>origin是默认的被克隆的远程名称（不是分支名，origin的master分支为origin/master)，被track的上游远程分支可以以<code class="language-plaintext highlighter-rouge">@{upstream}</code>或<code class="language-plaintext highlighter-rouge">@{u}</code>指代</p><ul><li><p><code class="language-plaintext highlighter-rouge">git remote</code>：显示所有已知的远程，增加一个<code class="language-plaintext highlighter-rouge">-v</code>flag来显示远程仓库的URL，或者<code class="language-plaintext highlighter-rouge">git remote show &lt;remote&gt;</code>来显示更多信息</p><li><code class="language-plaintext highlighter-rouge">git remote add &lt;name&gt; &lt;url&gt;</code>：增加一个新的远程<li><code class="language-plaintext highlighter-rouge">git remote rm &lt;name&gt;</code>：删除某个远程<li><code class="language-plaintext highlighter-rouge">git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>：将objects发送到远程分支，并且更新远程分支的reference<li><code class="language-plaintext highlighter-rouge">git push &lt;remote&gt; --delete &lt;remote branch&gt;</code>：删除远程分支<li><code class="language-plaintext highlighter-rouge">git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>：设置本地branch和远程branch的连接关系，从而可以直接进行<code class="language-plaintext highlighter-rouge">git push</code>而不需要指定远程branch<li><code class="language-plaintext highlighter-rouge">git branch -vv</code>查看目前正在追踪的远程分支<li><code class="language-plaintext highlighter-rouge">git fetch</code>：从远程项目拉取所有的objects/reference，但是并不merge到working directory中，对working directory没有任何影响<li><code class="language-plaintext highlighter-rouge">git pull</code>：相当于<code class="language-plaintext highlighter-rouge">git fetch; git merge</code><li><code class="language-plaintext highlighter-rouge">git clone</code>：从远程分支下载repo，将本地的<code class="language-plaintext highlighter-rouge">master</code>分支追踪远程的<code class="language-plaintext highlighter-rouge">master</code>分支(本地分支和远程分支存在连接关系，运行<code class="language-plaintext highlighter-rouge">git push</code>时本地分支将知道push到哪个远程分支)<li><code class="language-plaintext highlighter-rouge">git rebase</code>：将一个分支rebase到另一个分支上，这样可以使分叉的commit变成线性的</ul><p>撤销命令</p><p>所有的commit大概率是可以被恢复的，但是没有被commit的snapshot很难被恢复</p><ul><li><p><code class="language-plaintext highlighter-rouge">git commit --amend</code>：修改commit的内容</p><p>比如</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>git commit -m 'Initial commit'
git add forgotton_file
git commit --amend
</pre></table></code></div></div><p>最终只有一个initial commit，里面包括了forgotton_file</p><li><p><code class="language-plaintext highlighter-rouge">git reset HEAD &lt;file&gt;</code>：把文件从staging area撤出，但是不会修改文件</p><p>也可以使用<code class="language-plaintext highlighter-rouge">git restore --staged &lt;file&gt;</code></p><p><code class="language-plaintext highlighter-rouge">git restore &lt;file&gt;</code>则是将还未stage的文件恢复到上一次commit时的状态</p><li><p><code class="language-plaintext highlighter-rouge">git checkout -- &lt;file&gt;</code>：把文件在工作区的修改全部撤销，撤销到最近一次<code class="language-plaintext highlighter-rouge">git commit</code>或<code class="language-plaintext highlighter-rouge">git add</code>的状态。当文件自修改后还没有放到暂存区时，使用本命令将回到和版本库相同的状态（但git还是知道修改的），当文件已经添加到暂存区，并且又做了修改之后，则回到添加到暂存区时的状态。</p></ul><p>高级命令</p><ul><li><p><code class="language-plaintext highlighter-rouge">git config</code>：配置git，分成三个层面的配置，包括系统级别、用户级别、仓库级别</p><p><code class="language-plaintext highlighter-rouge">git config --system -l</code>查看系统配置，配置文件存储于<code class="language-plaintext highlighter-rouge">[path]/etc.gitconfig</code></p><p><code class="language-plaintext highlighter-rouge">git config --global -l</code>查看用户配置，配置文件存储于<code class="language-plaintext highlighter-rouge">~/.gitconfig</code>或<code class="language-plaintext highlighter-rouge">~/.config/git/config</code>文件</p><p><code class="language-plaintext highlighter-rouge">git config --local -l</code>查看仓库配置，配置文件存储于<code class="language-plaintext highlighter-rouge">[repo]/.git/config</code></p><p>优先级：仓库配置&gt;用户配置&gt;系统配置</p><p>设置<code class="language-plaintext highlighter-rouge">main</code>为默认的分支名：<code class="language-plaintext highlighter-rouge">git config --global init.defaultBranch main</code></p><li><p><code class="language-plaintext highlighter-rouge">git clone --depth=1</code>：浅克隆，将忽略之前所有的版本历史</p><li><p><code class="language-plaintext highlighter-rouge">git add -p</code>：交互式添加到暂存区，能够方便地将一个文件中的部分内容添加到暂存区</p><li><p><code class="language-plaintext highlighter-rouge">git rebase -i</code>：interactive rebasing</p><li><p><code class="language-plaintext highlighter-rouge">git blame</code>：显示哪个用户编辑了哪一条</p><li><p><code class="language-plaintext highlighter-rouge">git stash</code>：将目前还不想提交但是已经修改的内容（包括工作区和暂存区）保存到堆栈中，后续可以在某个分支上恢复出堆栈的内容。<code class="language-plaintext highlighter-rouge">git stash pop</code>将堆栈中的内容弹出到当前分支上，堆栈内容被删除，而<code class="language-plaintext highlighter-rouge">git stash apply</code>则将堆栈中的内容应用到当前分支上，和<code class="language-plaintext highlighter-rouge">git stash pop</code>不同的是堆栈中的内容并不会被删除，适用于应用到多个分支的情况</p><li><p><code class="language-plaintext highlighter-rouge">.gitignore</code>：指定不需要track的文件</p></ul><h2 id="git-workflow">Git workflow</h2><p>https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow</p><p>软件开发的workflow，规定了分支的类型和怎样合并分支</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://wac-cdn.atlassian.com/dam/jcr:2bef0bef-22bc-4485-94b9-a9422f70f11c/02%20(2).svg?cdnVersion=1398" alt="Git flow workflow - Historical Branches" /></p><p><code class="language-plaintext highlighter-rouge">master</code>分支：软件的release版本分支</p><p><code class="language-plaintext highlighter-rouge">develop</code>分支：开发分支</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://wac-cdn.atlassian.com/dam/jcr:b5259cce-6245-49f2-b89b-9871f9ee3fa4/03%20(2).svg?cdnVersion=1398" alt="Git flow workflow - Feature Branches" /></p><p><code class="language-plaintext highlighter-rouge">feature</code>分支：每个单独的feature作为一个分支，以<code class="language-plaintext highlighter-rouge">develop</code>作为父分支</p><ul><li>推荐阅读：<a href="https://git-scm.com/book/en/v2">pro git</a></ul><h1 id="lecture-7-debugging-and-profiling">Lecture 7 Debugging and Profiling</h1><h2 id="logging">Logging</h2><ul><li><p>Linux终端显示不同的颜色，使用ANSI escape颜色码</p><p><code class="language-plaintext highlighter-rouge">echo -e "\e[1;31mThis is red\e[0m"</code> 显示红色的This is red</p><p><code class="language-plaintext highlighter-rouge">echo -e "\e[1;42mGreen Background\e[0m"</code>显示绿色背景的Green Background</p><li><p>大多数程序将日志文件存放在<code class="language-plaintext highlighter-rouge">/var/log</code>目录下，<code class="language-plaintext highlighter-rouge">systemd</code>是一个system的daemon程序，将所有系统日志存放在<code class="language-plaintext highlighter-rouge">var/log/journal</code>下，可以用<code class="language-plaintext highlighter-rouge">journalctl</code>来查看</p><li><p><code class="language-plaintext highlighter-rouge">logger "logging info"</code>可以将log记录到<code class="language-plaintext highlighter-rouge">journal</code>中</p></ul><h2 id="debugging">Debugging</h2><p><code class="language-plaintext highlighter-rouge">pdb</code>：python debugger</p><ul><li>s(tep)：单步执行，相当于step into<li>n(ext)：单步执行，相当于step over<li>l(ist)：列出执行到的那行代码的前后十一行<li>c(ontinue)：继续执行，直到遇到下一条断点<li>b(reakpoint)：设置断点<li>cl(ear)：清除断点<li>r(eturn)：执行当前运行函数直到结束<li>p(rint) &lt;expression&gt;：输出expression的值<li>q(uit)：退出debugger<li>restart：重新debug</ul><p>使用<code class="language-plaintext highlighter-rouge">python -m pdb &lt;filename.py&gt;</code>来进行pdb调试，其中<code class="language-plaintext highlighter-rouge">-m</code>表示将模块(module)当作脚本运行，也就是将pdb当作脚本运行</p><p><code class="language-plaintext highlighter-rouge">gdb</code>(GNU debugger)：C/C++ debugger，也支持Go和Rust调试，用法和pdb类似</p><p>静态代码分析：无需用编译器编译运行即可扫描出代码错误</p><p><code class="language-plaintext highlighter-rouge">pyflakes</code>是python的静态扫描工具，<code class="language-plaintext highlighter-rouge">shellcheck</code>可以对shell scripts进行扫描</p><p>code linting：在编译前即标出警告和错误的位置</p><p>一些linter推荐：</p><p>https://github.com/caramelomartins/awesome-linters#cc</p><h2 id="profiling">Profiling</h2><p>获取程序运行的资源占用以及时间信息</p><h3 id="timing">Timing</h3><ul><li>Real time: 真实时间，包括了被其他进程占用的时间和等待I/O以及网络的时间<li>User time: 用户时间，即CPU运行用户代码所花费的时间<li>Sys time: 系统时间，即CPU运行kernal代码所花费的时间</ul><p><code class="language-plaintext highlighter-rouge">time &lt;command&gt;</code>可以计算上述三个时间</p><h3 id="cpu-profiler">CPU profiler</h3><p>最常见的profiler，两种类型：</p><ul><li>tracing profiler: 记录每个函数调用<li>sampling profiler：周期性地对程序采样，记录程序的堆栈</ul><p>对于python程序，使用<code class="language-plaintext highlighter-rouge">cProfile</code>来作为profiler</p><p><code class="language-plaintext highlighter-rouge">python -m cProfile -s tottime &lt;filename.py&gt;</code></p><p>但是由于<code class="language-plaintext highlighter-rouge">cProfiler</code>将所有内部调用函数的开销都统计在内，很难看出真正把时间都花在了哪里，因此可以使用<code class="language-plaintext highlighter-rouge">line_profiler</code>来统计每一行代码所花费的时间，这样更加直观，需要添加一个decorator <code class="language-plaintext highlighter-rouge">@profile</code>来声明需要进行profiling的函数</p><p>可以使用<code class="language-plaintext highlighter-rouge">flame graph</code>来将CPU profiling可视化</p><h3 id="memory-profiler">memory profiler</h3><p>内存泄漏：即使在不需要用到这些内存的时候也不将其释放，在没有垃圾收集的语言，比如C/C++中可以使用<code class="language-plaintext highlighter-rouge">valgrind</code>来显示内存泄漏，python可以使用<code class="language-plaintext highlighter-rouge">memory_profiler</code>来进行memory profiling</p><ul><li>函数调用图：python中可以选择<code class="language-plaintext highlighter-rouge">pycallgraph</code>来显示哪个函数调用了哪个</ul><h3 id="resource-monitoring">resource monitoring</h3><p><code class="language-plaintext highlighter-rouge">htop</code>：<code class="language-plaintext highlighter-rouge">top</code>的升级版，来观察系统资源使用情况</p><p><code class="language-plaintext highlighter-rouge">free</code>：观察系统可用内存使用情况</p><p><code class="language-plaintext highlighter-rouge">df</code>：当前文件夹中磁盘使用情况</p><p><code class="language-plaintext highlighter-rouge">nethogs</code>/<code class="language-plaintext highlighter-rouge">iftop</code>/<code class="language-plaintext highlighter-rouge">ss</code>：网络使用情况</p><p><code class="language-plaintext highlighter-rouge">hyperfine</code>：对程序进行快速benchmark，例如比较<code class="language-plaintext highlighter-rouge">fd</code>和<code class="language-plaintext highlighter-rouge">find</code>的速度</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>hyperfine --warmup 3 'fd -e jpg' 'find . -iname "*.jpg"'
</pre></table></code></div></div><h1 id="lecture-8-metaprogramming">Lecture 8 Metaprogramming</h1><h2 id="build-systems">Build systems</h2><p>将依赖编译构建为二进制文件的流程需要用到build systems，比如<code class="language-plaintext highlighter-rouge">make</code></p><p>定义：</p><ul><li>依赖(dependency)<li>目标(target)<li>构建规则(rule)</ul><p>在某个目录下执行<code class="language-plaintext highlighter-rouge">make</code>时，<code class="language-plaintext highlighter-rouge">make</code>将会查找该目录下的<code class="language-plaintext highlighter-rouge">Makefile</code>，示例如下所示</p><div class="language-makefile highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c"># this is comment
</span><span class="err">@</span><span class="c"># @ is to turn off the echoing of comment
# .ONESHELL:
</span><span class="nl">paper.pdf</span><span class="o">:</span> <span class="nf">paper.tex plot-data.png</span>
	pdflatex paper.tex plot-data.png

<span class="nl">plot-%.png</span><span class="o">:</span> <span class="nf">%.dat plot.py</span>
	./plot.py <span class="nt">-i</span> <span class="nv">$*</span>.dat <span class="nt">-o</span> <span class="nv">$@</span>
</pre></table></code></div></div><p>冒号左边是需要构建的目标文件，冒号右边是依赖文件，下面一行是构建规则,，注意每行命令在单独的shell中执行，这些shell之间没有继承关系，除非将几行命令写在一行中，中间用分号分割，或者加上<code class="language-plaintext highlighter-rouge">.ONESHELL:</code>命令，每一个这样的组合构成了一个directive <code class="language-plaintext highlighter-rouge">%</code>是一个样式，匹配任意字符串，如果需要构建的是<code class="language-plaintext highlighter-rouge">plot-data.png</code>，那么就会去寻找<code class="language-plaintext highlighter-rouge">data.dat</code>这个依赖文件</p><p><code class="language-plaintext highlighter-rouge">$@</code>是目前的target</p><p>目标文件如果已经构建成功，而依赖文件没有作任何更新，那么再执行<code class="language-plaintext highlighter-rouge">make</code>将不会有任何动作，如果某个依赖文件更新，那么只对和该依赖文件有关的编译动作进行重新编译。</p><p>除了文件名，目标还可以是某个操作的名字，称为伪目标，比如<code class="language-plaintext highlighter-rouge">make clean</code>不是make一个叫做clean的文件，而是删除对象文件，因此要把<code class="language-plaintext highlighter-rouge">clean</code>声明为伪目标</p><div class="language-makefile highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">.PHONY</span><span class="o">:</span> <span class="nf">clean</span>
<span class="nl">clean</span><span class="o">:</span>
	<span class="nb">rm</span> <span class="k">*</span>.o temp
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">make install</code>将可执行文件复制到正确的路径，即被复制到某个<code class="language-plaintext highlighter-rouge">PATH</code>包含的路径</p><h2 id="dependency-management">Dependency management</h2><p>有多种不同的依赖：</p><ul><li><p>依赖程序：例如<code class="language-plaintext highlighter-rouge">python</code></p><li><p>依赖系统包(system packages)：例如<code class="language-plaintext highlighter-rouge">openssl</code></p><li><p>编程语言中的库(library)：例如<code class="language-plaintext highlighter-rouge">matplotlib</code></p><p>仓库：管理各种依赖的地方，比如ubuntu中的<code class="language-plaintext highlighter-rouge">apt</code>、Ruby中的<code class="language-plaintext highlighter-rouge">gem</code>、Python中的<code class="language-plaintext highlighter-rouge">pip</code>以及nodejs中的<code class="language-plaintext highlighter-rouge">npm</code></p></ul><p><b>versioning</b>：对软件版本控制</p><p>semantic versioning: major.minor.patch</p><ul><li>patch：新的版本不改变API，增加patch#<li>minor：如果对API的改变是向后兼容的，增加minor#<li>major：如果对API的改变不向后兼容，增加major#</ul><p>lock file：列出所有依赖的版本信息的文件，需要手动对依赖库中的软件进行升级</p><p>vendoring：将所有依赖的源代码复制到项目中，来获得对依赖的完全控制权</p><h2 id="continuous-integration-system-ci">Continuous Integration System (CI)</h2><p>持续集成，即一旦进行了源代码的commit，即进行自动编译测试，将代码集成到主干，从而尽快发现错误，防止分支大幅偏离主干</p><p>比较多的CI工具包括Travis CI、Azure Pipelines和Github Actions</p><p>CI是事件触发，一旦被触发，CI将起一个虚拟机，在其中运行用户规定的recipe所需要执行的命令。GitHub Pages就是一个CI系统，每次md文件被commit到repo后<code class="language-plaintext highlighter-rouge">jekyll</code>就会将其编译为HTML并deploy到服务器上</p><p>git本身就是一个简单的CI系统，在<code class="language-plaintext highlighter-rouge">.git/hooks</code>下有一些事件触发的脚本，比如<code class="language-plaintext highlighter-rouge">pre-commit.sample</code>,在commit时被触发</p><p><b>测试</b></p><ul><li>test suite：所有测试的集合<li>unit test：单元测试，对某一个feature进行单独测试<li>integration test：集成测试，对各个单元继续联合测试<li>regression test：回归测试，对之前所有产生bug的条件进行测试从而保证相同的bug不再出现<li>mocking：用一个假的Implementation来代替一个功能模块来实现对其他依赖于此模块的其他模块进行测试</ul><h1 id="lecture-9-security-and-cryptography">Lecture 9 Security and Cryptography</h1><h2 id="hash-functions">Hash functions</h2><p>将一个任意长度的bytes array映射到一个固定长度的byte</p><p>其中一种Hash function是SHA1，生成160位输出(40个16进制字符)</p><p>可以使用<code class="language-plaintext highlighter-rouge">sha1sum</code>命令来输出一个文件的SHA1哈希值</p><p>哈希函数有以下的特性：</p><ul><li>deterministic：相同的输入总是生成相同输出<li>non-invertible：已知输出，很难得到输入<li>collision resistant：两个不同的输入很难得到相同的输出</ul><h2 id="key-derivation-functions-kdf">Key Derivation Functions (KDF)</h2><p>本质上属于Hash函数</p><p>给一个passphrase(相当于用户的password)，生成一个固定长度的key，通常KDF相当缓慢，为了防止brute force破解密码</p><p>KDF可以用于存储网站密码，比如生成一个随机的salt，然后存储salt以及KDF(password+salt)，用重新生成KDF(password+salt)来验证每次的登陆尝试</p><h2 id="symmetric-cryptography">Symmetric cryptography</h2><p>对称加密的过程：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>keygen() -&gt; key # 随机生成一个key，通信双方交换这个key，key需要保密
encrypt(plaintext, key) -&gt; ciphertext
decrypt(ciphertext, key) -&gt; plaintext
</pre></table></code></div></div><p>对称加密的特性：</p><ul><li>即便拥有ciphertext，没有key的情况下也无法得到plain text<li>显然正确性，即<code class="language-plaintext highlighter-rouge">decrypt(encrypt(message, key), key) = message</code></ul><p>比较著名的对称加密算法：AES</p><h2 id="asymmetric-cryptography">Asymmetric cryptography</h2><p>非对称加密，有一个公钥，不需要保密，还有一个私钥，自己保存，需要保密。这样可以解决对称加密中需要交换密钥的问题</p><p>非对称加密的过程：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>keygen() -&gt; (public key, private key)
encrypt(plaintext, public key) -&gt; ciphertext
decrypt(ciphertext, private key) -&gt; plaintext
</pre></table></code></div></div><p>非对称加密可以用于签名/验证过程：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>sign(message, private key) -&gt; signature
verify(signature, message, public key) -&gt; &lt;bool&gt;is_signature
</pre></table></code></div></div><p>非对称加密的应用：</p><ul><li>PGP邮件加密<li>私人通信频道</ul><p>公钥分发：如何确认别人得到的公钥确实是我们给他们的公钥？</p><p>著名的非对称算法：RSA算法</p><p>GPG(GNU Private Guard)是一个使用RSA算法对文件进行加密的软件</p><p>使用方法：https://www.digitalocean.com/community/tutorials/how-to-use-gpg-to-encrypt-and-sign-messages</p><h2 id="case-study">case study</h2><ul><li>Two-Factor Authentication (2FA)：用一个passphrase和某个authenticator(授权文件或物理设备，如YubiKey)来防止passphrase的泄露<li><p>磁盘加密：使用对称加密，需要passphrase，Linux上可以使用cryptsetup+LUKS，Windows上可以使用BitLocker</p><li>SSH：<code class="language-plaintext highlighter-rouge">ssh-keygen</code>是非对称加密，生成一个公钥和密钥，密钥采用KDF进行对称加密，因此需要一个passphrase。服务器需要知道公钥，私钥保存在本地。服务器先选一个随机的信息发送给client，要求client对该信息进行签名，client将该信息签名之后发送给server，server通过公钥验证该签名</ul><h1 id="lecture-10-miscellaneous">Lecture 10 Miscellaneous</h1><ul><li><p>Daemons</p><p>守护进程，开机自动运行在后台的进程，这些进程一般后缀都有一个d，比如<code class="language-plaintext highlighter-rouge">sshd</code>就是SSH的守护进程，负责监听SSH请求。<code class="language-plaintext highlighter-rouge">systemd</code>是linux的系统守护进程，负责运行和设置守护进程，可以运行<code class="language-plaintext highlighter-rouge">systemctl status</code>来列出当前正在运行的daemon。可以使用<code class="language-plaintext highlighter-rouge">cron</code>来定时运行守护进程</p><li><p>FUSE (Filesystem in User SpacE)</p><p>用户空间文件系统，即用户可以通过FUSE在用户空间定制实现自己的文件系统而不必在内核态</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://pic4.zhimg.com/80/v2-3af27c5bb1198a15a9f2951b2fe20817_1440w.jpg" alt="img" /></p><p>fuse_user是开发的用户态的文件系统程序，该程序启动的时候会将自己开发的接口注册到fuse中，<strong>比如读写文件的接口，遍历目录的接口</strong>等等。 同时，通过该程序在系统某个路径挂载fuse文件系统，比如/tmp/file_on_fuse_fs。此时如果在该目录中有相关操作时，请求会经过VFS到fuse的内核模块（上图中的步骤1），fuse内核模块根据请求类型，调用用户态应用注册的函数（上图中步骤2），然后将处理结果通过VFS返回给系统调用（步骤3）。</p><p><code class="language-plaintext highlighter-rouge">SSHFS</code>就是一个FUSE文件系统，可以通过SSH链接在本地打开远程服务器的文件/文件夹</p><li><p>API</p><p>大多数的线上服务有可以让你通过编程获取一定形式的API，这些API都有固定结构的URL，经常是以<code class="language-plaintext highlighter-rouge">api.service.com</code>为root</p><p>很多API会要求一个token来获取服务，可以通过<code class="language-plaintext highlighter-rouge">OAuth</code>这个协议来获取token</p><p>token和密码是不同的，token是短期的，到期自动失效，也可以被数据所有者撤销，且有权限范围</p><li><p>Command Line flags/patterns</p><p>大多数命令行有类似的flag，比如：</p><ul><li>dry run：只会打印出如果不在dry run模式下的结果，但实际上什么修改都不会进行<li><code class="language-plaintext highlighter-rouge">--verbose</code>或<code class="language-plaintext highlighter-rouge">-v</code>：打印详细内容，<code class="language-plaintext highlighter-rouge">-vvv</code>打印更详细的内容，<code class="language-plaintext highlighter-rouge">--quiet</code>打印简短的内容<li><code class="language-plaintext highlighter-rouge">-</code>代替文件名表示标准输入输出<li><code class="language-plaintext highlighter-rouge">--</code>表示停止将后面的字符以flag对待，比如<code class="language-plaintext highlighter-rouge">rm -- -r</code>就是删除<code class="language-plaintext highlighter-rouge">-r</code>这个文件而不是进行递归删除</ul><li><p>tiling window manager</p><p>瓦片窗口管理器，窗口永远平铺，很多使用Lua进行编程</p><li><p>Linux快捷键</p><p><kbd>^l</kbd>：清屏</p><p><kbd>^u</kbd>：删除光标前的全部指令</p><li><p>Linux安装必需的包：</p><ul><li><p>gcc</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt-get <span class="nb">install </span>build-essential
</pre></table></code></div></div></ul></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/lecture-notes/'>lecture notes</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/others/" class="post-tag no-text-decoration" >Others</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=MIT 6.null Lecture Notes - Xiao Fan (樊潇)&url=https://tommyfan34.github.io/posts/MIT-6-null-notes/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=MIT 6.null Lecture Notes - Xiao Fan (樊潇)&u=https://tommyfan34.github.io/posts/MIT-6-null-notes/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=MIT 6.null Lecture Notes - Xiao Fan (樊潇)&url=https://tommyfan34.github.io/posts/MIT-6-null-notes/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/GAMES101/">GAMES101 Lecture Notes</a><li><a href="/posts/leetcode-notes/">Leetcode Notes</a><li><a href="/posts/LIS-Problem/">LIS Problem</a><li><a href="/posts/Monotone-Stack-Problem/">Monotone Stack Problem</a><li><a href="/posts/CS61B-notes/">UCB CS61B Lecture Notes</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/others/">Others</a> <a class="post-tag" href="/tags/computer-graphics/">Computer Graphics</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/CS61A-notes/"><div class="card-body"> <span class="timeago small" > Mar 17, 2021 <i class="unloaded">2021-03-17T18:11:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>UCB CS61A Lecture Notes</h3><div class="text-muted small"><p> 1 Introduction 本课程基于Structure and Interpretation of Computer Programs (SICP)。课程网址: https://inst.eecs.berkeley.edu/~cs61a/fa20/ 1.1 Python features doctests 在python的def关键词下的一行用"""包裹的文字是叫做docstri...</p></div></div></a></div><div class="card"> <a href="/posts/CS61B-notes/"><div class="card-body"> <span class="timeago small" > Apr 16, 2021 <i class="unloaded">2021-04-16T17:09:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>UCB CS61B Lecture Notes</h3><div class="text-muted small"><p> 1 Introduction CS61B Spring 2018课程网址: https://sp18.datastructur.es/ 推荐的Java参考书：Head First Java 1.1 Java Intro Java是一门静态类型编译型的语言，源文件类型为.java，经过javac编译器将其编译为.class文件，此时.class文件是已经经过类型检查的，再用java解释...</p></div></div></a></div><div class="card"> <a href="/posts/MIT-6S081-notes/"><div class="card-body"> <span class="timeago small" > Mar 2, 2021 <i class="unloaded">2021-03-02T17:44:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MIT 6.S081 Lecture Notes</h3><div class="text-muted small"><p> 课程网址：https://pdos.csail.mit.edu/6.S081/2020/index.html 我的lab实现的github repo：https://github.com/tommyfan34/MIT_6S081 Lecture 1 Introduction 操作系统应该提供的功能：1. 多进程支持 2. 进程间隔离 3. 受控制的进程间通信 xv6：...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <span class="btn btn-outline-primary disabled"><p>-</p></span> <a href="/posts/MIT-6S081-notes/" class="btn btn-outline-primary"><p>MIT 6.S081 Lecture Notes</p></a></div><div id="comments"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script> <script src='//lib.baomitu.com/valine/latest/Valine.min.js'></script> <script> new Valine({ av: AV, el: '#comments', app_id: 'wp6tzj2sW35FoU9QTAMVl64h-gzGzoHsz', app_key: 'rEv50Y8WsRaFC3Um1ccmOBHD', placeholder: '对FX说些什么吧...', notify: 'true', verify: 'true', avatar: 'mp', recordIP: 'true', enableQQ: 'true', }) </script> </br></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/tommyfan34">Xiao Fan</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/others/">Others</a> <a class="post-tag" href="/tags/computer-graphics/">Computer Graphics</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://tommyfan34.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
