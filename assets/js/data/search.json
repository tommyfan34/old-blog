[ { "title": "GAMES101 Lecture Notes", "url": "/posts/GAMES101/", "categories": "lecture notes", "tags": "Computer Graphics", "date": "2023-03-07 00:00:00 +0800", "snippet": "GAMES101现代计算机图形学入门课程笔记第二章 线性代数叉乘叉乘对于右手系来说使用右手螺旋定则。笛卡尔坐标系下：\\[\\vec{a} \\times \\vec{b} = \\begin{pmatrix} y_az_b-y_bz_a \\\\z_ax_b - z_bx_a \\\\ x_ay_b - y_ax_b \\end{pmatrix}\\]矩阵写法：\\[\\vec{a} \\times \\vec{b} = A * b = \\begin{pmatrix}0 &amp;amp; -z_a &amp;amp; y_a \\\\ z_a &amp;amp; 0 &amp;amp; -x_a \\\\ -y_a &a..." }, { "title": "Fenwick Tree", "url": "/posts/Fenwick-Tree/", "categories": "leetcode notes", "tags": "leetcode", "date": "2022-07-23 23:59:00 +0800", "snippet": "树状数组, 英文Fenwick Tree或Binary Index Tree, 是一种用来在$O(\\log N)$时间复杂度内进行前缀和更新和查找的数据结构Leetcode 307. Range Sum Query - Mutable问题Given an integer array nums, handle multiple queries of the following types: Update the value of an element in nums. Calculate the sum of the elements of nums between indices ..." }, { "title": "Monotone Stack Problem", "url": "/posts/Monotone-Stack-Problem/", "categories": "leetcode notes", "tags": "leetcode", "date": "2021-08-13 22:09:00 +0800", "snippet": "单调栈，顾名思义就是栈中的元素满足单调递增或者单调递减的性质，单调栈的典型应用场景是在一维数组中以\\(O(N)\\)​的时间寻找第一个满足某种条件的数。比如要在一列人中寻找排在自己前面第一个比自己矮的人，对于站在自己前面比自己高的人higher_peoples，这些人不是自己的目标，而对于下一个要寻找排在他们面前第一个比他们矮的人来说，higher_peoples同样不是他们的目标，因为前面那个人一定比higher_peoples要矮，我宁愿选择前面那个人也不可能选择higher_peoples，因此这些higher_peoples将对结果无法产生任何影响，可以被排除考虑。因此我们可以维护..." }, { "title": "Graph Problem", "url": "/posts/Graph-Problem/", "categories": "leetcode notes", "tags": "leetcode", "date": "2021-08-05 09:52:00 +0800", "snippet": "图问题是一种经典的问题Leetcode. 802 找到最终的安全状态问题在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是安全的。返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按升序排列。该有向图有n个节点，按0到n - 1编号，其中n是graph的节点数。图以下述形式给出: graph[i]是编号j节点的一个列表，满足(i, j)是图的一条有向边。示例示例 1：输入..." }, { "title": "Trie Problem", "url": "/posts/Trie-Problem/", "categories": "leetcode notes", "tags": "leetcode", "date": "2021-07-30 21:26:00 +0800", "snippet": "本文讨论可以使用前缀树Trie来解决的一些问题。Leetcode 1948. 删除系统中的重复文件夹问题由于一个漏洞，文件系统中存在许多重复文件夹。给你一个二维数组paths，其中paths[i]是一个表示文件系统中第i个文件夹的绝对路径的数组。 例如，[“one”, “two”, “three”] 表示路径 “/one/two/three” 。如果两个文件夹（不需要在同一层级）包含 非空且相同的 子文件夹 集合 并具有相同的子文件夹结构，则认为这两个文件夹是相同文件夹。相同文件夹的根层级 不 需要相同。如果存在两个（或两个以上）相同 文件夹，则需要将这些文件夹和所有它们的子文件夹 标..." }, { "title": "LCS &amp; LPS Problem", "url": "/posts/LCS-Problem/", "categories": "leetcode notes", "tags": "leetcode", "date": "2021-07-27 11:12:00 +0800", "snippet": "上文提到了LIS问题及其变式，本文讨论LCS问题和LPS问题。LCS问题即最长公共子序列问题（Longest Common Subsequence），求两个字符串对最长公共子序列。LPS问题即最长回文子序列问题（Longest Palindrome Subsequence），求字符串中可以形成回文串的最长子序列。由于最长回文子序列可以用LCS来解决，因此放在一起进行讨论。Leetcode 1143. 最长公共子序列问题给定两个字符串text1和text2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列 ，返回 0 。一个字符串的子序列是指这样一个新的字符串：它是由原字符串在..." }, { "title": "LIS Problem", "url": "/posts/LIS-Problem/", "categories": "leetcode notes", "tags": "leetcode", "date": "2021-07-26 12:52:00 +0800", "snippet": "LIS问题，即最长递增子序列问题（Longest Increasing Subsequence问题），是一道经典的字符串问题，即计算一个整数序列中最长的严格递增的子字符串的长度。本文通过几道Leetcode问题来介绍LIS问题及其变式，下面是LIS问题的原题。Leetcode 300. 最长递增子序列问题给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。示例示例 1：输入：nums = [10,9,2,5,3,7,10..." }, { "title": "Leetcode Notes", "url": "/posts/leetcode-notes/", "categories": "leetcode notes", "tags": "leetcode", "date": "2021-06-30 15:42:00 +0800", "snippet": "1. 动态规划 将原问题拆分为子问题 确认状态dp[i]代表什么 确认边界状态（初始条件） 状态转移方程1.1 最长回文字串leetcode 第五题 medium问题：采用动态规划的方法首先可以发现，s.substring(i, j)是否为回文串取决于s.substring(i + 1, j - 1)与s.charAt(i)与s.charAt(j)是否相等，可以列出状态转移方程isPalindrome(s.substring(i, j)) = isPalindrome(s.substring(i + 1, j - 1)) &amp;amp;&amp;amp; (s.charAt(..." }, { "title": "UCB CS61B Lecture Notes", "url": "/posts/CS61B-notes/", "categories": "lecture notes", "tags": "Others", "date": "2021-04-16 17:09:00 +0800", "snippet": "1 IntroductionCS61B Spring 2018课程网址: https://sp18.datastructur.es/推荐的Java参考书：Head First Java1.1 Java IntroJava是一门静态类型编译型的语言，源文件类型为.java，经过javac编译器将其编译为.class文件，此时.class文件是已经经过类型检查的，再用java解释器去执行这个.class文件Java是纯面向对象语言，所有的函数都在一个class中。示例：/* Dog.java */public class Dog { public int weightInPounds;..." }, { "title": "UCB CS61A Lecture Notes", "url": "/posts/CS61A-notes/", "categories": "lecture notes", "tags": "Others", "date": "2021-03-17 18:11:00 +0800", "snippet": "1 Introduction本课程基于Structure and Interpretation of Computer Programs (SICP)。课程网址: https://inst.eecs.berkeley.edu/~cs61a/fa20/1.1 Python featuresdoctests在python的def关键词下的一行用&quot;&quot;&quot;包裹的文字是叫做docstring，用来解释这个函数所做的事情。在docstring中如果加入了&amp;gt;&amp;gt;&amp;gt;，这就是doctest，用来测试函数的正确性，比如# ex.pyfrom..." }, { "title": "MIT 6.S081 Lecture Notes", "url": "/posts/MIT-6S081-notes/", "categories": "lecture notes", "tags": "Others", "date": "2021-03-02 17:44:00 +0800", "snippet": "课程网址：https://pdos.csail.mit.edu/6.S081/2020/index.html我的lab实现的github repo：https://github.com/tommyfan34/MIT_6S081Lecture 1 Introduction操作系统应该提供的功能：1. 多进程支持 2. 进程间隔离 3. 受控制的进程间通信 xv6：一种在本课程中使用的类UNIX的教学操作系统，运行在RISC-V指令集处理器上，本课程中将使用QEMU模拟器代替 kernel(内核)：为运行的程序提供服务的一种特殊程序。每个运行着的程序叫做进程，每个进程..." }, { "title": "MIT 6.null Lecture Notes", "url": "/posts/MIT-6-null-notes/", "categories": "lecture notes", "tags": "Others", "date": "2021-01-14 18:32:00 +0800", "snippet": "Lecture 1 Shell bash中如果想提供一个包含空格的参数，可以用‘或”“把它们引起来，或者用转义字符\\，比如My\\ Photos来将空格转义 $PATH是环境变量，即在本地文件夹下没有找到对应可以执行的程序时会自动在环境变量的路径中寻找相应的程序。which提示了能够运行本指令的程序路径，比如 ~$ which echo/bin/echo ls -l表示以详细方式列出当前文件夹下的文件 missing:~$ ls -l /homedrwxr-xr-x 1 missing users 4096 Jun 15 20..." } ]
