<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.7.2"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="MIT 6.S081 Lecture Notes" /><meta name="author" content="Xiao Fan" /><meta property="og:locale" content="en_US" /><meta name="description" content="课程网址：https://pdos.csail.mit.edu/6.S081/2020/index.html" /><meta property="og:description" content="课程网址：https://pdos.csail.mit.edu/6.S081/2020/index.html" /><link rel="canonical" href="https://tommyfan34.github.io/posts/MIT-6S081-notes/" /><meta property="og:url" content="https://tommyfan34.github.io/posts/MIT-6S081-notes/" /><meta property="og:site_name" content="Xiao Fan (樊潇)" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-02T17:44:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="MIT 6.S081 Lecture Notes" /><meta name="twitter:site" content="@tommyfan34" /><meta name="twitter:creator" content="@Xiao Fan" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Xiao Fan"},"description":"课程网址：https://pdos.csail.mit.edu/6.S081/2020/index.html","headline":"MIT 6.S081 Lecture Notes","url":"https://tommyfan34.github.io/posts/MIT-6S081-notes/","@type":"BlogPosting","dateModified":"2021-03-02T17:44:00+08:00","datePublished":"2021-03-02T17:44:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://tommyfan34.github.io/posts/MIT-6S081-notes/"},"@context":"https://schema.org"}</script><title>MIT 6.S081 Lecture Notes | Xiao Fan (樊潇)</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" href="/assets/css/post.css" as="style"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-FTKB0LQYH6"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-FTKB0LQYH6'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/sample/me.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Xiao Fan (樊潇)</a></div><div class="site-subtitle font-italic">Lots of hair | 低质量人类男性，新一线城市做题家，屎山代码制造机</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tabs/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tabs/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/tabs/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tabs/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/tommyfan34" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/tommyfan34" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['tommyfanzju','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="https://www.linkedin.com/in/xiao-fan-6a21b7171" aria-label="linkedin" class="order-6" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://www.facebook.com/tommyfanzju" aria-label="facebook" class="order-7" target="_blank" rel="noopener"> <i class="fab fa-facebook"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>MIT 6.S081 Lecture Notes</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>MIT 6.S081 Lecture Notes</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Mar 2, 2021, 5:44 PM +0800" > Mar 2, 2021 <i class="unloaded">2021-03-02T17:44:00+08:00</i> </span> by <span class="author"> Xiao Fan </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="44688 words">248 min</span></div></div><div class="post-content"><p>课程网址：<a href="https://pdos.csail.mit.edu/6.S081/2020/index.html">https://pdos.csail.mit.edu/6.S081/2020/index.html</a></p><p>我的lab实现的github repo：<a href="https://github.com/tommyfan34/MIT_6S081">https://github.com/tommyfan34/MIT_6S081</a></p><h1 id="lecture-1-introduction">Lecture 1 Introduction</h1><p>操作系统应该提供的功能：1. 多进程支持 2. 进程间隔离 3. 受控制的进程间通信</p><ul><li><p><em>xv6</em>：一种在本课程中使用的类UNIX的教学操作系统，运行在RISC-V指令集处理器上，本课程中将使用<em>QEMU</em>模拟器代替</p><li><p><em>kernel</em>(内核)：为运行的程序提供服务的一种特殊程序。每个运行着的程序叫做进程，每个进程的内存中存储指令、数据和堆栈。一个计算机可以拥有多个进程，但是只能有一个内核</p><p>每当进程需要调用内核时，它会触发一个<em>system call</em>（系统调用），system call进入内核执行相应的服务然后返回。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210116095611198.png" alt="image-20210116095611198" /></p><li><p><em>shell</em>：一个普通的程序，其功能是让用户输入命令并执行它们，shell<b>不是</b>内核的一部分</p></ul><h2 id="11-processes-and-memory">1.1 Processes and memory</h2><p>每个进程拥有自己的用户空间内存以及内核空间状态，当进程不再执行时xv6将存储和这些进程相关的CPU寄存器直到下一次运行这些进程。kernel将每一个进程用一个PID(process identifier)指代。</p><p><strong>常用syscall</strong></p><ul><li><p><code class="language-plaintext highlighter-rouge">fork</code>：形式：<code class="language-plaintext highlighter-rouge">int fork()</code>。其作用是让一个进程生成另外一个和这个进程的内存内容相同的子进程。在父进程中，<code class="language-plaintext highlighter-rouge">fork</code>的返回值是这个子进程的PID，在子进程中，返回值是0</p><li><p><code class="language-plaintext highlighter-rouge">exit</code>：形式：<code class="language-plaintext highlighter-rouge">int exit(int status)</code>。让调用它的进程停止执行并且将内存等占用的资源全部释放。需要一个整数形式的状态参数，0代表以正常状态退出，1代表以非正常状态退出</p><li><p><code class="language-plaintext highlighter-rouge">wait</code>：形式：<code class="language-plaintext highlighter-rouge">int wait(int *status)</code>。等待子进程退出，返回子进程PID，子进程的退出状态存储到<code class="language-plaintext highlighter-rouge">int *status</code>这个地址中。如果调用者没有子进程，<code class="language-plaintext highlighter-rouge">wait</code>将返回-1</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"parent: child=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">wait</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"child %d is done</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"child: exiting</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"fork error</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>前两行输出可能是</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>parent: child=1234
child: exiting
</pre></table></code></div></div><p>也可能是</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>child: exiting
parent: child=1234
</pre></table></code></div></div><p>这是因为在fork了之后，父进程和子进程将同时开始判断PID的值，在父进程中，PID为1234，而在子进程中，PID为0。看哪个进程先判断好PID的值，以上输出顺序才会被决定。</p><p>最后一行输出为</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>parent: child 1234 is done
</pre></table></code></div></div><p>子进程在判断完<code class="language-plaintext highlighter-rouge">pid == 0</code>之后将<code class="language-plaintext highlighter-rouge">exit</code>，父进程发现子进程<code class="language-plaintext highlighter-rouge">exit</code>之后，<code class="language-plaintext highlighter-rouge">wait</code>执行完毕，打印输出</p><p>尽管<code class="language-plaintext highlighter-rouge">fork</code>了之后子进程和父进程有相同的内存内容，但是内存地址和寄存器是不一样的，也就是说在一个进程中改变变量并不会影响另一个进程。</p><li><p><code class="language-plaintext highlighter-rouge">exec</code>：形式：<code class="language-plaintext highlighter-rouge">int exec(char *file, char *argv[])</code>。加载一个文件，获取执行它的参数，执行。如果执行错误返回-1，执行成功则不会返回，而是开始从文件入口位置开始执行命令。文件必须是ELF格式。</p><p>xv6 shell使用以上四个system call来为用户执行程序。在shell进程的<code class="language-plaintext highlighter-rouge">main</code>中主循环先通过<code class="language-plaintext highlighter-rouge">getcmd</code>来从用户获取命令，然后调用<code class="language-plaintext highlighter-rouge">fork</code>来运行一个和当前shell进程完全相同的子进程。父进程调用<code class="language-plaintext highlighter-rouge">wait</code>等待子进程<code class="language-plaintext highlighter-rouge">exec</code>执行完（在<code class="language-plaintext highlighter-rouge">runcmd</code>中调用<code class="language-plaintext highlighter-rouge">exec</code>）</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="cm">/* sh.c */</span>
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
  
  <span class="c1">// Ensure that three file descriptors are open.</span>
  <span class="k">while</span><span class="p">((</span><span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"console"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">){</span>
      <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="c1">// Read and run input commands.</span>
  <span class="k">while</span><span class="p">(</span><span class="n">getcmd</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'c'</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'d'</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">' '</span><span class="p">){</span>
      <span class="c1">// Chdir must be called by the parent, not the child.</span>
      <span class="n">buf</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// chop \n</span>
      <span class="k">if</span><span class="p">(</span><span class="n">chdir</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"cannot cd %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fork1</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">runcmd</span><span class="p">(</span><span class="n">parsecmd</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
    <span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div></ul><h2 id="12-io-and-file-descriptors">1.2 I/O and File descriptors</h2><ul><li><p><em>file descriptor</em>：文件描述符，用来表示一个被内核管理的、可以被进程读/写的对象的一个整数，表现形式类似于字节流，通过打开文件、目录、设备等方式获得。一个文件被打开得越早，文件描述符就越小。</p><p>每个进程都拥有自己独立的文件描述符列表，其中0是标准输入，1是标准输出，2是标准错误。shell将保证总是有3个文件描述符是可用的</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">while</span><span class="p">((</span><span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"console"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">){</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p><code class="language-plaintext highlighter-rouge">read</code>和<code class="language-plaintext highlighter-rouge">write</code>：形式<code class="language-plaintext highlighter-rouge">int write(int fd, char *buf, int n)</code>和<code class="language-plaintext highlighter-rouge">int read(int fd, char *bf, int n)</code>。从/向文件描述符<code class="language-plaintext highlighter-rouge">fd</code>读/写n字节<code class="language-plaintext highlighter-rouge">bf</code>的内容，返回值是成功读取/写入的字节数。每个文件描述符有一个offset，<code class="language-plaintext highlighter-rouge">read</code>会从这个offset开始读取内容，读完n个字节之后将这个offset后移n个字节，下一个<code class="language-plaintext highlighter-rouge">read</code>将从新的offset开始读取字节。<code class="language-plaintext highlighter-rouge">write</code>也有类似的offset</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cm">/* essence of cat program */</span>
<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
  
<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"read errot</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">){</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"write error</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p><code class="language-plaintext highlighter-rouge">close</code>。形式是<code class="language-plaintext highlighter-rouge">int close(int fd)</code>，将打开的文件<code class="language-plaintext highlighter-rouge">fd</code>释放，使该文件描述符可以被后面的<code class="language-plaintext highlighter-rouge">open</code>、<code class="language-plaintext highlighter-rouge">pipe</code>等其他system call使用。</p><p>使用<code class="language-plaintext highlighter-rouge">close</code>来修改file descriptor table能够实现I/O重定向</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cm">/* implementation of I/O redirection,
 * more specifically, cat &lt; input.txt
 */</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"cat"</span><span class="p">;</span>
<span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
<span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// in the child process</span>
    <span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// this step is to release the stdin file descriptor</span>
    <span class="n">open</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span> <span class="c1">// the newly allocated fd for input.txt is 0, since the previous fd 0 is released</span>
    <span class="n">exec</span><span class="p">(</span><span class="s">"cat"</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span> <span class="c1">// execute the cat program, by default takes in the fd 0 as input, which is input.txt</span>
<span class="p">}</span>
</pre></table></code></div></div><p>父进程的fd table将不会被子进程fd table的变化影响，但是文件中的offset将被共享。</p><li><p><code class="language-plaintext highlighter-rouge">dup</code>。形式是<code class="language-plaintext highlighter-rouge">int dup(int fd)</code>，复制一个新的<code class="language-plaintext highlighter-rouge">fd</code>指向的I/O对象，返回这个新fd值，两个I/O对象(文件)的offset相同</p><p>e.g.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">fd</span> <span class="o">=</span> <span class="n">dup</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"hello "</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s">"world</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="c1">// outputs hello world</span>
</pre></table></code></div></div><p>除了<code class="language-plaintext highlighter-rouge">dup</code>和<code class="language-plaintext highlighter-rouge">fork</code>之外，其他方式<strong>不能</strong>使两个I/O对象的offset相同，比如同时<code class="language-plaintext highlighter-rouge">open</code>相同的文件</p></ul><h2 id="13-pipes">1.3 Pipes</h2><ul><li><p><em>pipe</em>：管道，暴露给进程的一对文件描述符，一个文件描述符用来读，另一个文件描述符用来写，将数据从管道的一端写入，将使其能够被从管道的另一端读出</p><p><code class="language-plaintext highlighter-rouge">pipe</code>是一个system call，形式为<code class="language-plaintext highlighter-rouge">int pipe(int p[])</code>，<code class="language-plaintext highlighter-rouge">p[0]</code>为读取的文件描述符，<code class="language-plaintext highlighter-rouge">p[1]</code>为写入的文件描述符</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="cm">/* run the program wc with stdin connected to the read end of pipe, parent process able to communicate with child process */</span>
<span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  
<span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"wc"</span><span class="p">;</span>
<span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
<span class="n">pipe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// read fd put into p[0], write fd put into p[1]</span>
<span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">dup</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// make the fd 0 refer to the read end of pipe</span>
    <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// original read end of pipe is closed</span>
    <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// fd p[1] is closed in child process, but not closed in the parent process. 注意这里关闭p[1]非常重要，因为如果不关闭p[1]，管道的读取端会一直等待读取，wc就永远也无法等到EOF</span>
    <span class="n">exec</span><span class="p">(</span><span class="s">"/bin/wc"</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span> <span class="c1">// by default wc will take fd 0 as the input, which is the read end of pipe in this case</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// close the read end of pipe in parent process will not affect child process</span>
    <span class="n">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"hello world</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span> 
    <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// write end of pipe closed, the pipe shuts down</span>
<span class="p">}</span>
</pre></table></code></div></div><p>xv6中的实现和上述的类似</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="k">case</span> <span class="n">PIPE</span><span class="p">:</span>
<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pipecmd</span><span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"pipe"</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">fork1</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
    <span class="c1">// in child process</span>
    <span class="n">close</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// close stdout</span>
    <span class="n">dup</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// make the fd 1 as the write end of pipe</span>
    <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">runcmd</span><span class="p">(</span><span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span> <span class="c1">// run command in the left side of pipe |, output redirected to the write end of pipe</span>
<span class="p">}</span>
<span class="k">if</span><span class="p">(</span><span class="n">fork1</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
    <span class="c1">// in child process</span>
    <span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// close stdin</span>
    <span class="n">dup</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// make the fd 0 as the read end of pipe</span>
    <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">runcmd</span><span class="p">(</span><span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span> <span class="c1">//  run command in the right side of pipe |, input redirected to the read end of pipe</span>
<span class="p">}</span>
<span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// wait for child process to finish</span>
<span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// wait for child process to finish</span>
<span class="k">break</span><span class="p">;</span>
</pre></table></code></div></div></ul><h2 id="14-file-system">1.4 File system</h2><p>xv6文件系统包含了<em>文件</em>(byte arrays)和<em>目录</em>(对其他文件和目录的引用)。目录生成了一个树，树从根目录<code class="language-plaintext highlighter-rouge">/</code>开始。对于不以<code class="language-plaintext highlighter-rouge">/</code>开头的路径，认为是是相对路径</p><ul><li><p><code class="language-plaintext highlighter-rouge">mknod</code>：创建设备文件，一个设备文件有一个major device #和一个minor device #用来唯一确定这个设备。当一个进程打开了这个设备文件时，内核会将<code class="language-plaintext highlighter-rouge">read</code>和<code class="language-plaintext highlighter-rouge">write</code>的system call重新定向到设备上。</p><li>一个文件的名称和文件本身是不一样的，文件本身，也叫<em>inode</em>，可以有多个名字，也叫<em>link</em>，每个link包括了一个文件名和一个对inode的引用。一个inode存储了文件的元数据，包括该文件的类型(file, directory or device)、大小、文件在硬盘中的存储位置以及指向这个inode的link的个数<li><code class="language-plaintext highlighter-rouge">fstat</code>。一个system call，形式为<code class="language-plaintext highlighter-rouge">int fstat(int fd, struct stat *st)</code>，将inode中的相关信息存储到<code class="language-plaintext highlighter-rouge">st</code>中。<li><code class="language-plaintext highlighter-rouge">link</code>。一个system call，将创建一个指向同一个inode的文件名。<code class="language-plaintext highlighter-rouge">unlink</code>则是将一个文件名从文件系统中移除，只有当指向这个inode的文件名的数量为0时这个inode以及其存储的文件内容才会被从硬盘上移除</ul><p>注意：Unix提供了许多在<strong>用户层面</strong>的程序来执行文件系统相关的操作，比如<code class="language-plaintext highlighter-rouge">mkdir</code>、<code class="language-plaintext highlighter-rouge">ln</code>、<code class="language-plaintext highlighter-rouge">rm</code>等，而不是将其放在shell或kernel内，这样可以使用户比较方便地在这些程序上进行扩展。但是<code class="language-plaintext highlighter-rouge">cd</code>是一个例外，它是在shell程序内构建的，因为它必须要改变这个calling shell本身指向的路径位置，如果是一个和shell平行的程序，那么它必须要调用一个子进程，在子进程里起一个新的shell，再进行<code class="language-plaintext highlighter-rouge">cd</code>，这是不符合常理的。</p><h2 id="15-xv6环境构建">1.5 xv6环境构建</h2><p>按照https://pdos.csail.mit.edu/6.828/2020/tools.html编译</p><p>注意需要follow other linux distributions的教程，因为直接使用ubuntu/debian的教程在调试的时候使用linux自带的gdb会无法远程连接到xv6，必须使用<code class="language-plaintext highlighter-rouge">riscv64-unknown-elf-gdb</code>，因此需要自己编译工具链。</p><p>debugging步骤：</p><p>可参考https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html</p><ol><li>在xv6文件夹下<code class="language-plaintext highlighter-rouge">make qemu-gdb</code><li>另外开一个终端，在相同的xv6文件夹下<code class="language-plaintext highlighter-rouge">riscv64-unknown-elf-gdb</code>。进入gdb后输入<code class="language-plaintext highlighter-rouge">file user/_[execname]</code>加载可执行文件<li>通过<code class="language-plaintext highlighter-rouge">b [linenum]</code>设置断点 <code class="language-plaintext highlighter-rouge">c</code>继续<li>在<code class="language-plaintext highlighter-rouge">make qemu-gdb</code>的终端中执行该可执行文件，进入debugging</ol><p>可以输入<code class="language-plaintext highlighter-rouge">tui enable</code>来边debug边显示source code</p><p>可以输入<code class="language-plaintext highlighter-rouge">layout asm</code>显示汇编程序，输入<code class="language-plaintext highlighter-rouge">layout reg</code>显示寄存器</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210127164935846.png" alt="image-20210127164935846" /></p><p><code class="language-plaintext highlighter-rouge">info breakpoints</code>来显示关于断点的信息</p><p>也可以使用VSCode来进行debug，参考https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html</p><h2 id="16-lab-1-unix-utilities">1.6 Lab 1: Unix Utilities</h2><ol><li><p>Sleep</p><p>调用system call <code class="language-plaintext highlighter-rouge">sleep</code>来实现休眠一定时间，注意如果没有传入参数，程序需要打印错误信息</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cp">#include "kernel/types.h"
#include "user/user.h"
</span>   
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"ERROR: sleep time required</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">sleep</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span> <span class="c1">// atoi把字符串转化为int</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>pingpong</p><p>Write a program that uses UNIX system calls to ‘‘ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping", where<pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print "<pid>: received pong", and exit. Your solution should be in the file `user/pingpong.c`.</pid></pid></pid></p><p>解决思路：开两个pipe，一个pipe负责子进程写父进程读，另一个pipe负责父进程写子进程读。注意最后要把所有的pipe fd关闭掉。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="cp">#include "kernel/types.h"
#include "user/user.h"
</span>   
<span class="cp">#define READEND 0
#define WRITEEND 1
</span>   
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
	<span class="kt">int</span> <span class="n">p1</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">p2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
   
	<span class="n">pipe</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
	<span class="n">pipe</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
   	
	<span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
   
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// child process</span>
		<span class="n">close</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="n">WRITEEND</span><span class="p">]);</span>
		<span class="n">close</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="n">READEND</span><span class="p">]);</span>
		<span class="n">read</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="n">READEND</span><span class="p">],</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%d: received ping</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
		<span class="n">write</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="n">WRITEEND</span><span class="p">],</span> <span class="s">" "</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">close</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="n">READEND</span><span class="p">]);</span>
		<span class="n">close</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="n">WRITEEND</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="c1">// parent process</span>
		<span class="n">close</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="n">READEND</span><span class="p">]);</span>
		<span class="n">close</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="n">WRITEEND</span><span class="p">]);</span>
		<span class="n">write</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="n">WRITEEND</span><span class="p">],</span> <span class="s">" "</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">read</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="n">READEND</span><span class="p">],</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%d: received pong</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
		<span class="n">close</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="n">WRITEEND</span><span class="p">]);</span>
		<span class="n">close</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="n">READEND</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>primes</p><p>素数筛法：将一组数feed到一个进程里，先print出最小的一个数，这是一个素数，然后用其他剩下的数依次尝试整除这个素数，如果可以整除，则将其drop，不能整除则将其feed到下一个进程中，直到最后打印出所有的素数。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210118093050894.png" alt="image-20210118093050894" /></p><p>注意最开始的父进程要等待所有子进程exit才能exit</p><p>解决思路：采用递归，每次先尝试从左pipe中读取一个数，如果读不到说明已经到达终点，exit，否则再创建一个右pipe并fork一个子进程，将筛选后的数feed进这个右pipe。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="cp">#include "kernel/types.h"
#include "user/user.h"
#define PRIME_NUM 35
#define READEND 0
#define WRITEEND 1
</span>   
<span class="kt">void</span> <span class="nf">child</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">pl</span><span class="p">);</span>
   
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">pipe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">child</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>	
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">READEND</span><span class="p">]);</span>
		<span class="c1">// feed the int array</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">PRIME_NUM</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">WRITEEND</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">WRITEEND</span><span class="p">]);</span>
		<span class="n">wait</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
   
<span class="kt">void</span> <span class="nf">child</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">pl</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">pr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
   
	<span class="n">close</span><span class="p">(</span><span class="n">pl</span><span class="p">[</span><span class="n">WRITEEND</span><span class="p">]);</span>
	<span class="c1">// tries to read the first number</span>
	<span class="kt">int</span> <span class="n">read_result</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">pl</span><span class="p">[</span><span class="n">READEND</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="c1">// right side pipe</span>
	<span class="n">pipe</span><span class="p">(</span><span class="n">pr</span><span class="p">);</span>
   
	<span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">child</span><span class="p">(</span><span class="n">pr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">close</span><span class="p">(</span><span class="n">pr</span><span class="p">[</span><span class="n">READEND</span><span class="p">]);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"prime %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">prime</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">pl</span><span class="p">[</span><span class="n">READEND</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">prime</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">write</span><span class="p">(</span><span class="n">pr</span><span class="p">[</span><span class="n">WRITEEND</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">close</span><span class="p">(</span><span class="n">pr</span><span class="p">[</span><span class="n">WRITEEND</span><span class="p">]);</span>
		<span class="n">wait</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>find</p><p>要求用递归方式找到指定的文件夹下符合某个名字的文件，参考<code class="language-plaintext highlighter-rouge">user/ls.c</code>的实现方法</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</pre><td class="rouge-code"><pre><span class="cp">#include "kernel/types.h"
#include "user/user.h"
#include "kernel/fs.h"
#include "kernel/stat.h"
#include "kernel/fcntl.h"
</span>   
<span class="kt">void</span> <span class="nf">find</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">target_file</span><span class="p">);</span>
   
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"ERROR: You need pass in only 2 arguments</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">target_path</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">target_file</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">find</span><span class="p">(</span><span class="n">target_path</span><span class="p">,</span> <span class="n">target_file</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
   
<span class="kt">void</span> <span class="nf">find</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">target_file</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dirent</span> <span class="n">de</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">512</span><span class="p">],</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
   
	<span class="k">if</span> <span class="p">((</span><span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"ERROR: cannot open %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
   	
	<span class="k">if</span> <span class="p">(</span><span class="n">fstat</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"ERROR: cannot stat %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
   
	<span class="c1">// read the name of each file/folder under the folder specified by fd, which is $path, name is de.name</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">de</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">))</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">buf</span><span class="o">+</span><span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">'/'</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">de</span><span class="p">.</span><span class="n">inum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
        <span class="c1">// get the full path name of the current file/directory selected</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">de</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">DIRSIZ</span><span class="p">);</span>
		<span class="n">p</span><span class="p">[</span><span class="n">DIRSIZ</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   
		<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"ERROR: cannot stat %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
   
		<span class="k">switch</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">T_FILE</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">target_file</span><span class="p">,</span> <span class="n">de</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">T_DIR</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">strcmp</span><span class="p">(</span><span class="n">de</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">"."</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">de</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">".."</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">find</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">target_file</span><span class="p">);</span>
<span class="p">}</span>
		<span class="p">}</span>	
	<span class="p">}</span>
	<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>xargs</p><p>实现将标准输入作为参数一起输入到<code class="language-plaintext highlighter-rouge">xargs</code>后面跟的命令中，比如</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">echo </span>hello too | xargs <span class="nb">echo </span>bye
bye hello too
</pre></table></code></div></div><p>如果标准输入有多行，那么也要执行多次命令</p><p>使用<code class="language-plaintext highlighter-rouge">fork</code>起一个子进程，在子进程中用<code class="language-plaintext highlighter-rouge">exec</code>执行相应的命令。父进程<code class="language-plaintext highlighter-rouge">wait</code>。对标准输入每次读一个char，若读到<code class="language-plaintext highlighter-rouge">\n</code>需要执行命令。<font color="red">注意</font>在执行<code class="language-plaintext highlighter-rouge">xargs</code>这个命令行的时候，最后肯定要按一个回车，这时标准输入最后会有一个回车，所以在EOF前是会有一个回车的！！！</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre>     
<span class="cp">#include "kernel/types.h"
#include "user/user.h"
#include "kernel/param.h"
#define MAX_LEN 100
</span>   
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">bf</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">paramv</span><span class="p">[</span><span class="n">MAXARG</span><span class="p">][</span><span class="n">MAX_LEN</span><span class="p">];</span> <span class="c1">// arguments</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="n">MAXARG</span><span class="p">];</span>
   
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">argc</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// # of current arguments</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">paramv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAXARG</span> <span class="o">*</span> <span class="n">MAX_LEN</span><span class="p">);</span>
		<span class="c1">// copy the parameter of command</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">strcpy</span><span class="p">(</span><span class="n">paramv</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
   
		<span class="kt">int</span> <span class="n">cursor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// cursor pointing the char position in single_arg</span>
		<span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// flag indicating whether thers is argument preceding space</span>
		<span class="kt">int</span> <span class="n">read_result</span><span class="p">;</span>
   
		<span class="k">while</span> <span class="p">(((</span><span class="n">read_result</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">bf</span> <span class="o">!=</span> <span class="sc">'\n'</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bf</span> <span class="o">==</span> <span class="sc">' '</span> <span class="o">&amp;&amp;</span> <span class="n">flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
				<span class="c1">// reset flag and p</span>
				<span class="n">cursor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bf</span> <span class="o">!=</span> <span class="sc">' '</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">paramv</span><span class="p">[</span><span class="n">count</span><span class="p">][</span><span class="n">cursor</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">bf</span><span class="p">;</span>
				<span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="c1">// encounters EOF of input or \n</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_result</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">MAXARG</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">paramv</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">m</span><span class="p">[</span><span class="n">MAXARG</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">exec</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
			<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">wait</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div></ol><h1 id="lecture-2-operating-system-organization">Lecture 2 Operating System Organization</h1><h2 id="20-c-pointer">2.0 C pointer</h2><p>补充资料： K&amp;R《C Programming》</p><p>指针：a group of cells (bytes, often two or four) that can hold an address</p><p>指针的声明： <code class="language-plaintext highlighter-rouge">int *p</code>， 意思是<code class="language-plaintext highlighter-rouge">*p</code>是一个<code class="language-plaintext highlighter-rouge">int</code></p><p><code class="language-plaintext highlighter-rouge">double *dp, atof(char *)</code>意为声明一个dp，是指向double类型的指针，声明一个函数atof，需要一个指向char变量的指针作为参数，返回值类型为double</p><p><code class="language-plaintext highlighter-rouge">*ip += 1</code>是将<code class="language-plaintext highlighter-rouge">ip</code>指向的变量加1，相当于<code class="language-plaintext highlighter-rouge">++*ip</code>或<code class="language-plaintext highlighter-rouge">(*ip)++</code>。注意：一元操作符从右向左结合，所以<code class="language-plaintext highlighter-rouge">*ip++</code>相当于<code class="language-plaintext highlighter-rouge">*(ip++)</code></p><p>指针和数组名的区别：指针是变量，而数组名不是变量，因此<code class="language-plaintext highlighter-rouge">pointer = arrayname</code>是合法的，而<code class="language-plaintext highlighter-rouge">arrayname = pointer</code>或者<code class="language-plaintext highlighter-rouge">arrayname++;</code>是不合法的</p><p>指针的大小比较：只有在两个指针指向同一个数组的元素时比较才合法。指针只有相减是合法的</p><p><code class="language-plaintext highlighter-rouge">char*</code>和<code class="language-plaintext highlighter-rouge">char []</code>的区别：前者是指针，并不会管到字符串，后者是数组，需要一个足够大的容量来容纳整个字符串</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">char</span> <span class="n">amessage</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"now is the time"</span><span class="p">;</span> <span class="cm">/* an array */</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">message</span> <span class="o">=</span> <span class="s">"now is the time"</span><span class="p">;</span> <span class="cm">/* a pointer, points to the string constant, could not modify the string content */</span>
</pre></table></code></div></div><p>C程序的内存分配：</p><ol><li>堆(heap)：由程序员通过<code class="language-plaintext highlighter-rouge">malloc()</code>和<code class="language-plaintext highlighter-rouge">free()</code>使用和释放，如果忘记释放可能造成内存泄漏。地址从低到高增长<li>栈(stack)：编译器自动分配释放，存放函数的参数值、局部变量的值等。在退出函数后自动释放销毁。地址从高到低增长<li>全局区(static)：通过<code class="language-plaintext highlighter-rouge">static</code>声明，全局都可以访问，不会在函数退出后释放</ol><h2 id="21-user-mode-and-supervisor-mode">2.1 User mode and supervisor mode</h2><p>为了实现进程隔离，RISC-V CPU在硬件上提供3种执行命令的模式：<em>machine mode</em>, <em>supervisor mode</em>, <em>user mode</em>。</p><ol><li><p>machine mode的权限最高，CPU以machine mode启动，machine mode的主要目的是为了配置电脑，之后立即切换到supervisor mode。</p><li>supervisor mode运行CPU执行<em>privileged instructions</em>，比如中断管理、对存储页表地址的寄存器进行读写操作、执行system call。运行在supervisor mode也称为在<em>kernel space</em>中运行。<li>应用程序只能执行user mode指令，比如改变变量、执行util function。运行在user mode也称为在<em>user space</em>中运行。要想让CPU从user mode切换到supervisor mode，RISC-V提供了一个特殊的<code class="language-plaintext highlighter-rouge">ecall</code>指令，要想从supervisor mode切换到user mode，调用<code class="language-plaintext highlighter-rouge">sret</code>指令</ol><h2 id="22-kernel-organization">2.2 Kernel organization</h2><p><em>monolithic kernel</em>：整个操作系统在kernel中，所有system call都在supervisor mode下运行。xv6是一个monolithic kernel</p><p><em>micro kernel</em>：将需要运行在supervisor mode下的操作系统代码压到最小，保证kernel内系统的安全性，将大部分的操作系统代码执行在user mode下。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210121175322692.png" alt="image-20210121175322692" /></p><p>如2.1所示，文件系统是一个user-level的进程，为其他进程提供服务，因此也叫做server</p><p>xv6 kernel source file如下所示</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210121185952327.png" alt="image-20210121185952327" /></p><h2 id="23-process">2.3 Process</h2><p>隔离的单元叫做进程，一个进程不能够破坏或者监听另外一个进程的内存、CPU、文件描述符，也不能破坏kernel本身。</p><p>为了实现进程隔离，xv6提供了一种机制让程序认为自己拥有一个独立的机器。一个进程为一个程序提供了一个私有的内存系统，或<em>address space</em>，其他的进程不能够读/写这个内存。xv6使用<em>page table</em>(页表)来给每个进程分配自己的address space，页表再将这些address space，也就是进程自己认为的虚拟地址(<em>virtual address</em>)映射到RISC-V实际操作的物理地址(<em>physical address</em>)</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210121190517403.png" alt="image-20210121190517403" /></p><p>虚拟地址从0开始，往上依次是指令、全局变量、栈、堆。RISC-V上的指针是64位的，xv6使用低38位，因此最大的地址是$2^{38}-1$=0x3fffffffff=MAXVA</p><p>进程最重要的内核状态：1. 页表 <code class="language-plaintext highlighter-rouge">p-&gt;pagetable</code> 2. 内核堆栈<code class="language-plaintext highlighter-rouge">p-&gt;kstack</code> 3. 运行状态<code class="language-plaintext highlighter-rouge">p-&gt;state</code>，显示进程是否已经被分配、准备运行/正在运行/等待IO或退出</p><p>每个进程中都有线程(<em>thread</em>)，是执行进程命令的最小单元，可以被暂停和继续</p><p>每个进程有两个堆栈：用户堆栈(<em>user stack</em>)和内核堆栈(<em>kernel stack</em>)。当进程在user space中进行时只使用用户堆栈，当进程进入了内核(比如进行了system call)使用内核堆栈</p><h2 id="24-starting-the-first-process">2.4 Starting the first process</h2><p>RISC-V启动时，先运行一个存储于ROM中的bootloader程序<code class="language-plaintext highlighter-rouge">kernel.ld</code>来加载xv6 kernel到内存中，然后在machine模式下从<code class="language-plaintext highlighter-rouge">_entry</code>开始运行xv6。bootloader将xv6 kernel加载到0x80000000的物理地址中，因为前面的地址中有I/O设备</p><p>在<code class="language-plaintext highlighter-rouge">_entry</code>中设置了一个初始stack，<code class="language-plaintext highlighter-rouge">stack0</code>来让xv6执行<code class="language-plaintext highlighter-rouge">kernel/start.c</code>。在<code class="language-plaintext highlighter-rouge">start</code>函数先在machine模式下做一些配置，然后通过RISC-V提供的<code class="language-plaintext highlighter-rouge">mret</code>指令切换到supervisor mode，使program counter切换到<code class="language-plaintext highlighter-rouge">kernel/main.c</code></p><p><code class="language-plaintext highlighter-rouge">main</code>先对一些设备和子系统进行初始化，然后调用<code class="language-plaintext highlighter-rouge">kernel/proc.c</code>中定义的<code class="language-plaintext highlighter-rouge">userinit</code>来创建第一个用户进程。这个进程执行了一个<code class="language-plaintext highlighter-rouge">initcode.S</code>的汇编程序，这个汇编程序调用了<code class="language-plaintext highlighter-rouge">exec</code>这个system call来执行<code class="language-plaintext highlighter-rouge">/init</code>，重新进入kernel。<code class="language-plaintext highlighter-rouge">exec</code>将当前进程的内存和寄存器替换为一个新的程序(<code class="language-plaintext highlighter-rouge">/init</code>)，当kernel执行完毕<code class="language-plaintext highlighter-rouge">exec</code>指定的程序后，回到<code class="language-plaintext highlighter-rouge">/init</code>进程。<code class="language-plaintext highlighter-rouge">/init</code>(<code class="language-plaintext highlighter-rouge">user/init.c</code>)创建了一个新的console device以文件描述符0,1,2打开，然后在console device中开启了一个shell进程，至此整个系统启动了</p><h2 id="25-lab-2-system-calls">2.5 Lab 2: System calls</h2><ol><li><p>System call tracing</p><p>要求：<code class="language-plaintext highlighter-rouge">trace [tracing_mask] [command]</code> 要求当调用了给定的tracing mask所对应的system call时，打印输出调用该system call的进程PID、system call的名称、system call的返回值。已经给出了user space下的user/trace.c，需要注册并实现<code class="language-plaintext highlighter-rouge">trace</code>这一system call</p><p>在<code class="language-plaintext highlighter-rouge">user/user.h</code>中先注册<code class="language-plaintext highlighter-rouge">trace</code>这一user function：<code class="language-plaintext highlighter-rouge">int trace(int)</code></p><p>在<code class="language-plaintext highlighter-rouge">user/usys.pl</code>注册一个ecall到kernel的kernel态的trace的入口：<code class="language-plaintext highlighter-rouge">entry("trace");</code></p><p>在<code class="language-plaintext highlighter-rouge">kernel/sys_trace.c</code>中实现一个<code class="language-plaintext highlighter-rouge">sys_trace()</code>，将system call的传入参数，也就是tracing mask保存到<code class="language-plaintext highlighter-rouge">kernel/proc.h</code>中的<code class="language-plaintext highlighter-rouge">proc</code>结构体中新注册的int变量中，tracing mask的获取方式为<code class="language-plaintext highlighter-rouge">argint(int, int *)</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">// trace the sys call from the user space</span>
<span class="n">uint64</span>
<span class="nf">sys_trace</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// n is the tracing mask</span>
   
  <span class="k">if</span><span class="p">(</span><span class="n">argint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1">// get the tracing mask</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">syscallnum</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>  <span class="c1">// put the tracing mask into structure</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
<span class="p">}</span>
</pre></table></code></div></div><p>修改<code class="language-plaintext highlighter-rouge">kernel/proc.c</code>中的<code class="language-plaintext highlighter-rouge">fork()</code>来把trace mask从父进程复制到子进程</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">np</span><span class="o">-&gt;</span><span class="n">syscallnum</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">syscallnum</span><span class="p">;</span>
</pre></table></code></div></div><p>修改<code class="language-plaintext highlighter-rouge">kernel/syscall.c</code>中的<code class="language-plaintext highlighter-rouge">syscall()</code>来打印输出，注意需要注册一个<code class="language-plaintext highlighter-rouge">extern uint 64 sys_trace(void)</code>和<code class="language-plaintext highlighter-rouge">[SYS_ trace] sys_trace</code>。注意sys call的返回值是保存在进程的trapframe中的a0寄存器的</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">syscall</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">syscall_name</span><span class="p">[</span><span class="mi">22</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"fork"</span><span class="p">,</span> <span class="s">"exit"</span><span class="p">,</span> <span class="s">"wait"</span><span class="p">,</span> <span class="s">"pipe"</span><span class="p">,</span> <span class="s">"read"</span><span class="p">,</span> <span class="s">"kill"</span><span class="p">,</span> <span class="s">"exec"</span><span class="p">,</span> <span class="s">"fstat"</span><span class="p">,</span> <span class="s">"chdir"</span><span class="p">,</span> <span class="s">"dup"</span><span class="p">,</span> <span class="s">"getpid"</span><span class="p">,</span> <span class="s">"sbrk"</span><span class="p">,</span> <span class="s">"sleep"</span><span class="p">,</span> <span class="s">"uptime"</span><span class="p">,</span> <span class="s">"open"</span><span class="p">,</span> <span class="s">"write"</span><span class="p">,</span> <span class="s">"mknod"</span><span class="p">,</span> <span class="s">"unlink"</span><span class="p">,</span> <span class="s">"link"</span><span class="p">,</span> <span class="s">"mkdir"</span><span class="p">,</span> <span class="s">"close"</span><span class="p">,</span> <span class="s">"trace"</span><span class="p">};</span>
   
  <span class="n">num</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a7</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="n">NELEM</span><span class="p">(</span><span class="n">syscalls</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">syscalls</span><span class="p">[</span><span class="n">num</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span> <span class="o">=</span> <span class="n">syscalls</span><span class="p">[</span><span class="n">num</span><span class="p">]();</span>
    <span class="k">if</span><span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">num</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">syscallnum</span><span class="p">))</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"%d: syscall %s -&gt; %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">syscall_name</span><span class="p">[</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d %s: unknown sys call %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>Sysinfo</p><p>要求：写一个<code class="language-plaintext highlighter-rouge">sysinfo</code>这个system call，需要获取当前空闲的内存大小填入<code class="language-plaintext highlighter-rouge">struct sysinfo.freemem</code>中，获取当前所有不是<code class="language-plaintext highlighter-rouge">UNUSED</code>的进程数量填入<code class="language-plaintext highlighter-rouge">struct sysinfo.nproc</code>中</p><p>和前面一样先要在<code class="language-plaintext highlighter-rouge">user/user.h</code>中声明system call<code class="language-plaintext highlighter-rouge">int sysinfo(struct sysinfo *)</code>以及<code class="language-plaintext highlighter-rouge">struct sysinfo</code>，在<code class="language-plaintext highlighter-rouge">user/usys.pl</code>中注册entry，在<code class="language-plaintext highlighter-rouge">kernel/syscall.h</code>中注册一个syscall number，在<code class="language-plaintext highlighter-rouge">kernel/sysproc.c</code>中对<code class="language-plaintext highlighter-rouge">uint64 sys_sysinfo(void)</code>进行实现，注意要在<code class="language-plaintext highlighter-rouge">sysproc.c</code>中添加头文件<code class="language-plaintext highlighter-rouge">sysinfo.h</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">uint64</span>
<span class="nf">sys_sysinfo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">uint64</span> <span class="n">sysinfop</span><span class="p">;</span> <span class="c1">// address of the sys info structure pointer</span>
  <span class="k">struct</span> <span class="n">sysinfo</span> <span class="n">si</span><span class="p">;</span>
   
  <span class="k">if</span><span class="p">(</span><span class="n">argaddr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sysinfop</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">si</span><span class="p">.</span><span class="n">freemem</span> <span class="o">=</span> <span class="n">freememsize</span><span class="p">();</span> <span class="c1">// collect the free memory size</span>
  <span class="n">si</span><span class="p">.</span><span class="n">nproc</span> <span class="o">=</span> <span class="n">nproc_active</span><span class="p">();</span> <span class="c1">// collect the number of processes not in use</span>
  <span class="k">if</span><span class="p">(</span><span class="n">copyout</span><span class="p">(</span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">sysinfop</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">si</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// copy out the sysinfo struct si from kernel space to user space</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">kernel/kalloc.c</code>中实现<code class="language-plaintext highlighter-rouge">freememsize()</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">// get the size of free memory size</span>
<span class="n">uint64</span>
<span class="nf">freememsize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">uint64</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">r</span><span class="p">){</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">PGSIZE</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">kernel/proc.c</code>中实现<code class="language-plaintext highlighter-rouge">nproc_active()</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">int</span>
<span class="nf">nproc_active</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">NPROC</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">proc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">state</span> <span class="o">!=</span> <span class="n">UNUSED</span><span class="p">)</span>
      <span class="n">num</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div></ol><h1 id="lecture-3-page-tables">Lecture 3 Page Tables</h1><p>页表让每个进程都拥有自己独立的虚拟内存地址，从而实现内存隔离。</p><h2 id="31-paging-hardware">3.1 Paging Hardware</h2><p>xv6运行于Sv39 RISC-V，即在64位地址中只有最下面的39位被使用作为虚拟地址，其中底12位是页内偏移，高27位是页表索引，即4096字节($2^{12}$)作为一个page，一个进程的虚拟内存可以有 $2^{27}$个page，对应到页表中就是$2^{27}$个page table entry (PTE)。每个PTE有一个44位的physical page number (PPN)用来映射到物理地址上和10位flag，总共需要54位，也就是一个PTE需要8字节存储。即每个物理地址的高44位是页表中存储的PPN，低12位是页内偏移，一个物理地址总共由56位构成。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210123111515788.png" alt="image-20210123111515788" /></p><p>在实际中，页表并不是作为一个包含了$2^{27}$个PTE的大列表存储在物理内存中的，而是采用了三级树状的形式进行存储，这样可以让页表分散存储。每个页表就是一页。第一级页表是一个4096字节的页，包含了512个PTE（因为每个PTE需要8字节），每个PTE存储了下级页表的页物理地址，第二级列表由512个页构成，第三级列表由512*512个页构成。因为每个进程虚拟地址的高27位用来确定PTE，对应到3级页表就是最高的9位确定一级页表PTE的位置，中间9位确定二级页表PTE的位置，最低9位确定三级页表PTE的位置。如下图所示。第一级根页表的物理页地址存储在<code class="language-plaintext highlighter-rouge">satp</code>寄存器中，每个CPU拥有自己独立的<code class="language-plaintext highlighter-rouge">satp</code></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210123130906787.png" alt="image-20210123130906787" /></p><p>PTE flag可以告诉硬件这些相应的虚拟地址怎样被使用，比如<code class="language-plaintext highlighter-rouge">PTE_V</code>表明这个PTE是否存在，<code class="language-plaintext highlighter-rouge">PTE_R</code>、<code class="language-plaintext highlighter-rouge">PTE_W</code>、<code class="language-plaintext highlighter-rouge">PTE_X</code>控制这个页是否允许被读取、写入和执行，<code class="language-plaintext highlighter-rouge">PTE_U</code>控制user mode是否有权访问这个页，如果<code class="language-plaintext highlighter-rouge">PTE_U</code>=0，则只有supervisor mode有权访问这个页。</p><h2 id="32-kernel-address-space">3.2 Kernel address space</h2><p>每个进程有一个页表，用于描述进程的用户地址空间，还有一个内核地址空间（所有进程共享这一个描述内核地址空间的页表）。为了让内核使用物理内存和硬件资源，内核需要按照一定的规则排布内核地址空间，以能够确定哪个虚拟地址对应自己需要的硬件资源地址。用户地址空间不需要也不能够知道这个规则，因为用户空间不允许直接访问这些硬件资源。</p><p>QEMU会模拟一个从0x80000000开始的RAM，一直到0x86400000。QEMU会将设备接口以控制寄存器的形式暴露给内核，这些控制寄存器在0x80000000以下。kernel对这些设备接口控制寄存器的访问是直接和这些设备而不是RAM进行交互的。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210123171523476.png" alt="image-20210123171523476" /></p><p>左边和右边分别是kernel virtual address和physical address的映射关系。在虚拟地址和物理地址中，kernel都位于<code class="language-plaintext highlighter-rouge">KERNBASE=0x80000000</code>的位置，这叫做直接映射。</p><p>用户空间的地址分配在free memory中</p><p>有一些不是直接映射的内核虚拟地址：</p><ul><li>trampoline page（和user pagetable在同一个虚拟地址，以便在user space和kernel space之间跳转时切换进程仍然能够使用相同的映射，真实的物理地址位于kernel text中的<code class="language-plaintext highlighter-rouge">trampoline.S</code>）<li>kernel stack page：每个进程有一个自己的内核栈kstack，每个kstack下面有一个没有被映射的guard page，guard page的作用是防止kstack溢出影响其他kstack。当进程运行在内核态时使用内核栈，运行在用户态时使用用户栈。<strong>注意</strong>：还有一个内核线程，这个线程只运行在内核态，不会使用其他进程的kstack，内核线程没有独立的地址空间。</ul><h2 id="33-code-creating-an-address-space">3.3 Code: creating an address space</h2><p>xv6中和页表相关的代码在<code class="language-plaintext highlighter-rouge">kernel/vm.c</code>中。最主要的结构体是<code class="language-plaintext highlighter-rouge">pagetable_t</code>，这是一个指向页表的指针。<code class="language-plaintext highlighter-rouge">kvm</code>开头的函数都是和kernel virtual address相关的，<code class="language-plaintext highlighter-rouge">uvm</code>开头的函数都是和user virtual address相关的，其他的函数可以用于这两者</p><p>几个比较重要的函数：</p><ul><li><code class="language-plaintext highlighter-rouge">walk</code>：给定一个虚拟地址和一个页表，返回一个PTE指针<li><p><code class="language-plaintext highlighter-rouge">mappages</code>：给定一个页表、一个虚拟地址和物理地址，创建一个PTE以实现相应的映射</p><li><code class="language-plaintext highlighter-rouge">kvminit</code>用于创建kernel的页表，使用<code class="language-plaintext highlighter-rouge">kvmmap</code>来设置映射<li><code class="language-plaintext highlighter-rouge">kvminithart</code>将kernel的页表的物理地址写入CPU的寄存器<code class="language-plaintext highlighter-rouge">satp</code>中，然后CPU就可以用这个kernel页表来翻译地址了<li><code class="language-plaintext highlighter-rouge">procinit</code>(kernel/proc.c)为每一个进程分配(<code class="language-plaintext highlighter-rouge">kalloc</code>)kstack。<code class="language-plaintext highlighter-rouge">KSTACK</code>会为每个进程生成一个虚拟地址（同时也预留了guard pages)，<code class="language-plaintext highlighter-rouge">kvmmap</code>将这些虚拟地址对应的PTE映射到物理地址中，然后调用<code class="language-plaintext highlighter-rouge">kvminithart</code>来重新把kernel页表加载到<code class="language-plaintext highlighter-rouge">satp</code>中去。</ul><p>每个RISC-V <strong>CPU</strong>会把PTE缓存到<em>Translation Look-aside Buffer (TLB)</em>中，当xv6更改了页表时，必须通知CPU来取消掉当前的TLB，取消当前TLB的函数是<code class="language-plaintext highlighter-rouge">sfence.vma()</code>，在<code class="language-plaintext highlighter-rouge">kvminithart</code>中被调用</p><h2 id="34-physical-memory-allocation-for-kernel">3.4 Physical memory allocation for kernel</h2><p>xv6对kernel space和PHYSTOP之间的物理空间在运行时进行分配，分配以页(4096 bytes)为单位。分配和释放是通过对空闲页链表进行追踪完成的，分配空间就是将一个页从链表中移除，释放空间就是将一页增加到链表中</p><p>kernel的物理空间的分配函数在<code class="language-plaintext highlighter-rouge">kernel/kalloc.c</code>中，每个页在链表中的元素是<code class="language-plaintext highlighter-rouge">struct run</code>，每个<code class="language-plaintext highlighter-rouge">run</code>存储在空闲页本身中。这个空闲页的链表<code class="language-plaintext highlighter-rouge">freelist</code>由spin lock保护，包装在<code class="language-plaintext highlighter-rouge">struct kmem</code>中。</p><ul><li><code class="language-plaintext highlighter-rouge">kinit()</code>：对分配函数进行初始化，将kernel结尾到PHYSTOP之间的所有空闲空间都添加到kmem链表中，这是通过调用<code class="language-plaintext highlighter-rouge">freerange(end, PHYSTOP)</code>实现的<li><code class="language-plaintext highlighter-rouge">freerange()</code>对这个范围内所有页都调用一次<code class="language-plaintext highlighter-rouge">kfree</code>来将这个范围内的页添加到<code class="language-plaintext highlighter-rouge">freelist</code>链表中</ul><h2 id="35-user-space-memory">3.5 User space memory</h2><p>每个进程有自己的用户空间下的虚拟地址，这些虚拟地址由每个进程自己的页表维护，用户空间下的虚拟地址从0到MAXVA</p><p>当进程向xv6索要更多用户内存时，xv6先用<code class="language-plaintext highlighter-rouge">kalloc</code>来分配物理页，然后向这个进程的页表增加指向这个新的物理页的PTE，同时设置这些PTE的flag</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210123220911443.png" alt="image-20210123220911443" /></p><p>图3.4是一个进程在刚刚被<code class="language-plaintext highlighter-rouge">exec</code>调用时的用户空间下的内存地址，stack只有一页，包含了<code class="language-plaintext highlighter-rouge">exec</code>调用的命令的参数从而使<code class="language-plaintext highlighter-rouge">main(argc, argv)</code>可以被执行。stack下方是一个guard page来检测stack溢出，一旦溢出将会产生一个page fault exception</p><p><code class="language-plaintext highlighter-rouge">sbrk</code>是一个可以让进程增加或者缩小用户空间内存的system call。<code class="language-plaintext highlighter-rouge">sbrk</code>调用了<code class="language-plaintext highlighter-rouge">growproc</code>(kernel/proc.c)来改变<code class="language-plaintext highlighter-rouge">p-&gt;sz</code>从而改变<strong>heap</strong>中的program break，<code class="language-plaintext highlighter-rouge">growproc</code>调用了<code class="language-plaintext highlighter-rouge">uvmalloc</code>和<code class="language-plaintext highlighter-rouge">uvmdealloc</code>，前者调用了<code class="language-plaintext highlighter-rouge">kalloc</code>来分配物理内存并且通过<code class="language-plaintext highlighter-rouge">mappages</code>向用户页表添加PTE，后者调用了<code class="language-plaintext highlighter-rouge">kfree</code>来释放物理内存</p><h2 id="36-code-exec">3.6 Code: exec</h2><p><code class="language-plaintext highlighter-rouge">exec</code>是一个system call，为以ELF格式定义的文件系统中的可执行文件创建用户空间。</p><p><code class="language-plaintext highlighter-rouge">exec</code>先检查头文件中是否有ELF_MAGIC来判断这个文件是否是一个ELF格式定义的二进制文件，用<code class="language-plaintext highlighter-rouge">proc_pagetable</code>来为当前进程创建一个还没有映射的页表，然后用<code class="language-plaintext highlighter-rouge">uvmalloc</code>来为每个ELF segment分配物理空间并在页表中建立映射，然后用<code class="language-plaintext highlighter-rouge">loadseg</code>来把ELF segment加载到物理空间当中。注意<code class="language-plaintext highlighter-rouge">uvmalloc</code>分配的物理内存空间可以比文件本身要大。</p><p>接下来<code class="language-plaintext highlighter-rouge">exec</code>分配user stack，它仅仅分配一页给stack，通过<code class="language-plaintext highlighter-rouge">copyout</code>将传入参数的string放在stack的顶端，在ustack的下方分配一个guard page</p><p>如果<code class="language-plaintext highlighter-rouge">exec</code>检测到错误，将跳转到<code class="language-plaintext highlighter-rouge">bad</code>标签，释放新创建的<code class="language-plaintext highlighter-rouge">pagetable</code>并返回-1。<code class="language-plaintext highlighter-rouge">exec</code>必须确定新的执行能够成功才会释放进程旧的页表(<code class="language-plaintext highlighter-rouge">proc_freepagetable(oldpagetable, oldsz)</code>)，否则如果system call不成功，就无法向旧的页表返回-1</p><h2 id="37-real-world">3.7 Real world</h2><p>xv6将kernel加载到0x8000000这一RAM物理地址中，但是实际上很多RAM的物理地址都是随机的，并不一定存在0x8000000这个地址</p><p>实际的处理器并不一定以4096bytes为一页，而可能使用各种不同大小的页</p><h2 id="38-lab-3-pgtbl">3.8 Lab 3: pgtbl</h2><ol><li><p>print a page table</p><p>实验要求：在程序刚刚启动(pid==1)时打印输出当前进程的pagetable。在<code class="language-plaintext highlighter-rouge">exec.c</code>中添加</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="n">vmprint</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">);</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">vmprint()</code>函数放在<code class="language-plaintext highlighter-rouge">kernel/vm.c</code>中</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">_helper_vmprint</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">pagetable</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span> <span class="o">|</span> <span class="n">PTE_X</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// this pte points to a valid lower level page table</span>
      <span class="n">uint64</span> <span class="n">child</span> <span class="o">=</span> <span class="n">PTE2PA</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">level</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">".."</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">" "</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"%d: pte %p pa %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
      <span class="n">_helper_vmprint</span><span class="p">((</span><span class="n">pagetable_t</span><span class="p">)</span><span class="n">child</span><span class="p">,</span> <span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">uint64</span> <span class="n">child</span> <span class="o">=</span> <span class="n">PTE2PA</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
      <span class="c1">// the lowest valid page table</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">".. .. ..%d: pte %p pa %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
   
<span class="c1">// print the page table</span>
<span class="kt">void</span> <span class="nf">vmprint</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"page table %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pagetable</span><span class="p">);</span>
  <span class="n">_helper_vmprint</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>A kernel page table per process</p><p>实验要求：为每个进程添加一个kernel pagetable来取代之前的global page table</p><p>在<code class="language-plaintext highlighter-rouge">kernel/proc.h</code>中的<code class="language-plaintext highlighter-rouge">struct proc</code>添加一个每个进程的kernel pagetable</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">pagetable_t</span> <span class="n">kernelpt</span><span class="p">;</span>        <span class="c1">// per process kernel pagetable</span>
</pre></table></code></div></div><p>仿照<code class="language-plaintext highlighter-rouge">kvminit</code>，在<code class="language-plaintext highlighter-rouge">vm.c</code>中实现一个<code class="language-plaintext highlighter-rouge">proc_kpt_init()</code>函数来为每个进程初始化kernel page table，其中<code class="language-plaintext highlighter-rouge">uvmmap</code>类似于<code class="language-plaintext highlighter-rouge">kvmmap</code>，只不过<code class="language-plaintext highlighter-rouge">kvmmap</code>是直接对全局的<code class="language-plaintext highlighter-rouge">kernel_pagetable</code>进行<code class="language-plaintext highlighter-rouge">mappage</code>，而<code class="language-plaintext highlighter-rouge">uvmmap</code>并没有指定page table</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="n">pagetable_t</span>
<span class="nf">proc_kpt_init</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">pagetable_t</span> <span class="n">kpt</span><span class="p">;</span>
  <span class="n">kpt</span> <span class="o">=</span> <span class="n">uvmcreate</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">kpt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">uvmmap</span><span class="p">(</span><span class="n">kpt</span><span class="p">,</span> <span class="n">UART0</span><span class="p">,</span> <span class="n">UART0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
  <span class="n">uvmmap</span><span class="p">(</span><span class="n">kpt</span><span class="p">,</span> <span class="n">VIRTIO0</span><span class="p">,</span> <span class="n">VIRTIO0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
  <span class="n">uvmmap</span><span class="p">(</span><span class="n">kpt</span><span class="p">,</span> <span class="n">CLINT</span><span class="p">,</span> <span class="n">CLINT</span><span class="p">,</span> <span class="mh">0x10000</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
  <span class="n">uvmmap</span><span class="p">(</span><span class="n">kpt</span><span class="p">,</span> <span class="n">PLIC</span><span class="p">,</span> <span class="n">PLIC</span><span class="p">,</span> <span class="mh">0x400000</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
  <span class="n">uvmmap</span><span class="p">(</span><span class="n">kpt</span><span class="p">,</span> <span class="n">KERNBASE</span><span class="p">,</span> <span class="n">KERNBASE</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="o">-</span><span class="n">KERNBASE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_X</span><span class="p">);</span>
  <span class="n">uvmmap</span><span class="p">(</span><span class="n">kpt</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="p">,</span> <span class="n">PHYSTOP</span><span class="o">-</span><span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
  <span class="n">uvmmap</span><span class="p">(</span><span class="n">kpt</span><span class="p">,</span> <span class="n">TRAMPOLINE</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">trampoline</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_X</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">kpt</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> 
<span class="nf">uvmmap</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">va</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">pa</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">sz</span><span class="p">,</span> <span class="kt">int</span> <span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">mappages</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"kvmmap"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">allocproc()</code>中调用初始化进程内核页表的函数</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">p</span><span class="o">-&gt;</span><span class="n">kernelpt</span> <span class="o">=</span> <span class="n">proc_kpt_init</span><span class="p">();</span>
</pre></table></code></div></div><p>注意要让每个procees kernel pagetable拥有这个进程的kernel stack，因此在<code class="language-plaintext highlighter-rouge">allocproc</code>中分配kstack并将其map到<code class="language-plaintext highlighter-rouge">p-&gt;kernelpt</code>上</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// Allocate a page for the process's kernel stack.</span>
<span class="c1">// Map it high in memory, followed by an invalid</span>
<span class="c1">// guard page.</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="n">kalloc</span><span class="p">();</span>
<span class="k">if</span><span class="p">(</span><span class="n">pa</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"kalloc"</span><span class="p">);</span>
<span class="n">uint64</span> <span class="n">va</span> <span class="o">=</span> <span class="n">KSTACK</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">proc</span><span class="p">));</span>
<span class="n">uvmmap</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kernelpt</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">kstack</span> <span class="o">=</span> <span class="n">va</span><span class="p">;</span>
</pre></table></code></div></div><p>修改<code class="language-plaintext highlighter-rouge">scheduler()</code>以将进程的kernel page table加载到<code class="language-plaintext highlighter-rouge">satp</code>寄存器中，如果CPU空闲，就使用global kernel page table</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>        <span class="n">w_satp</span><span class="p">(</span><span class="n">MAKE_SATP</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kernelpt</span><span class="p">));</span>
        <span class="n">sfence_vma</span><span class="p">();</span>
   
        <span class="n">swtch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
   
        <span class="c1">// Process is done running for now.</span>
        <span class="c1">// It should have changed its p-&gt;state before coming back.</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">proc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   
      	<span class="n">w_satp</span><span class="p">(</span><span class="n">MAKE_SATP</span><span class="p">(</span><span class="n">kernel_pagetable</span><span class="p">));</span>
      	<span class="n">sfence_vma</span><span class="p">();</span>
        <span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="err">}</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">freeproc</code>中释放掉process kernel page table，注意对于KERNBASE以下的部分，这个process kernel page table只能unmap这些PTE，而不能真的释放这些物理资源，因为KERNBASE以下的部分其他进程是共享的，因此要先释放掉进程的kstack物理资源，然后用<code class="language-plaintext highlighter-rouge">freewalk_kproc</code>这个函数将pagetable unmap和释放的同时也保留叶节点指向的物理资源</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="c1">// free the kernel stack in the RAM</span>
<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kstack</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pte_t</span><span class="o">*</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kernelpt</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">kstack</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pte</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">panic</span><span class="p">(</span><span class="s">"freeproc: walk"</span><span class="p">);</span>
    <span class="n">kfree</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">PTE2PA</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">kstack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   
<span class="c1">// ...</span>
<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kernelpt</span><span class="p">)</span>
    <span class="n">freewalk_kproc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kernelpt</span><span class="p">);</span>
<span class="c1">// ...</span>
   
<span class="c1">// Recursively free page-table pages</span>
<span class="c1">// but retain leaf physical addresses</span>
<span class="kt">void</span>
<span class="nf">freewalk_kproc</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">pagetable</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">if</span><span class="p">((</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)){</span>
      <span class="n">pagetable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PTE_R</span><span class="o">|</span><span class="n">PTE_W</span><span class="o">|</span><span class="n">PTE_X</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">uint64</span> <span class="n">child</span> <span class="o">=</span> <span class="n">PTE2PA</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
        <span class="n">freewalk_kproc</span><span class="p">((</span><span class="n">pagetable_t</span><span class="p">)</span><span class="n">child</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">kfree</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pagetable</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>Simplify copyin/copyinstr</p><p>实验要求：将每个进程的user page table复制到进程kernel page table上，从而让每个进程在<code class="language-plaintext highlighter-rouge">copyin</code>的时候不需要再利用process user page table来翻译传入的参数指针，而可以直接利用process kernel page table来dereference</p><p>先实现一个复制page table的函数<code class="language-plaintext highlighter-rouge">u2kvmcopy</code>来将user page table复制到process kernel page table，注意在复制的过程中需要清除原先PTE中的PTE_U标志位，否则kernel无法访问</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// copy the user page table to kernel page table</span>
<span class="kt">void</span>
<span class="nf">u2kvmcopy</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="n">pagetable_t</span> <span class="n">kpagetable</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">oldsz</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">newsz</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte_from</span><span class="p">,</span> <span class="o">*</span><span class="n">pte_to</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">a</span><span class="p">,</span> <span class="n">pa</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">flags</span><span class="p">;</span>
   
  <span class="k">if</span> <span class="p">(</span><span class="n">newsz</span> <span class="o">&lt;</span> <span class="n">oldsz</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="n">oldsz</span> <span class="o">=</span> <span class="n">PGROUNDUP</span><span class="p">(</span><span class="n">oldsz</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="n">oldsz</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">newsz</span><span class="p">;</span> <span class="n">a</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">pte_from</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">panic</span><span class="p">(</span><span class="s">"u2kvmcopy: pte should exist"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">pte_to</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">kpagetable</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1">// copy the pte to the same address at kernel page table</span>
      <span class="n">panic</span><span class="p">(</span><span class="s">"u2kvmcopy: walk fails"</span><span class="p">);</span>
    <span class="n">pa</span> <span class="o">=</span> <span class="n">PTE2PA</span><span class="p">(</span><span class="o">*</span><span class="n">pte_from</span><span class="p">);</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTE_FLAGS</span><span class="p">(</span><span class="o">*</span><span class="n">pte_from</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">PTE_U</span><span class="p">));</span>
    <span class="o">*</span><span class="n">pte_to</span> <span class="o">=</span> <span class="n">PA2PTE</span><span class="p">(</span><span class="n">pa</span><span class="p">)</span> <span class="o">|</span> <span class="n">flags</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在每个改变了user page table的地方要调用<code class="language-plaintext highlighter-rouge">u2kvmcopy()</code>使得process kernel page table跟上这个变化。这些地方出现在<code class="language-plaintext highlighter-rouge">fork()</code>、<code class="language-plaintext highlighter-rouge">exec()</code>和<code class="language-plaintext highlighter-rouge">sbrk()</code>需要调用的<code class="language-plaintext highlighter-rouge">growproc()</code>。注意要防止user process过大导致virtual address超过PLIC</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre><span class="c1">// fork</span>
<span class="c1">// increment reference counts on open file descriptors.</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NOFILE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">np</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">filedup</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="n">np</span><span class="o">-&gt;</span><span class="n">cwd</span> <span class="o">=</span> <span class="n">idup</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cwd</span><span class="p">);</span>
   
<span class="n">u2kvmcopy</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">kernelpt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">);</span>
   
<span class="n">safestrcpy</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
   
<span class="c1">// exec</span>
<span class="c1">// call u2kvmvcopy after user stack is set up</span>
<span class="n">stackbase</span> <span class="o">=</span> <span class="n">sp</span> <span class="o">-</span> <span class="n">PGSIZE</span><span class="p">;</span>
   
<span class="n">u2kvmcopy</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">kernelpt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
<span class="c1">// Push argument strings, prepare rest of stack in ustack.</span>
<span class="k">for</span><span class="p">(</span><span class="n">argc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="p">];</span> <span class="n">argc</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       
<span class="c1">// growproc</span>
<span class="kt">int</span>
<span class="n">growproc</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">uint</span> <span class="n">sz</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>
   
  <span class="n">sz</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">;</span>
   
  <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
    <span class="c1">//   return -1;</span>
    <span class="k">if</span><span class="p">((</span><span class="n">sz</span> <span class="o">=</span> <span class="n">uvmalloc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">sz</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">u2kvmcopy</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">kernelpt</span><span class="p">,</span> <span class="n">sz</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="n">uvmdealloc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">sz</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span> <span class="o">=</span> <span class="n">sz</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
       
<span class="c1">// prevent virtual address exceeding PLIC</span>
<span class="c1">// in exec.c when loading the program</span>
<span class="n">uint64</span> <span class="n">sz1</span><span class="p">;</span>
<span class="k">if</span><span class="p">((</span><span class="n">sz1</span> <span class="o">=</span> <span class="n">uvmalloc</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">ph</span><span class="p">.</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">ph</span><span class="p">.</span><span class="n">memsz</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">sz1</span> <span class="o">&gt;=</span> <span class="n">PLIC</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
<span class="n">sz</span> <span class="o">=</span> <span class="n">sz1</span><span class="p">;</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">userinit</code>中复制process kernel page</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">uvminit</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">initcode</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">initcode</span><span class="p">));</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span> <span class="o">=</span> <span class="n">PGSIZE</span><span class="p">;</span>
<span class="n">u2kvmcopy</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">kernelpt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">);</span>
<span class="c1">// prepare for the very first "return" from kernel to user.</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">epc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// user program counter</span>
</pre></table></code></div></div><p>最后将<code class="language-plaintext highlighter-rouge">copyin()</code>和<code class="language-plaintext highlighter-rouge">copyinstr()</code>替换为<code class="language-plaintext highlighter-rouge">copyin_new()</code>和<code class="language-plaintext highlighter-rouge">copyinstr_new()</code></p></ol><h1 id="lecture-4-risc-v-calling-convention">Lecture 4 RISC-V calling convention</h1><h2 id="41-isa--assembly-language">4.1 ISA &amp; Assembly Language</h2><p>ISA: Instruction Set</p><p>C -&gt; Assembly(.S/.asm) -&gt; binary (object.o)</p><p>汇编语言没有明确的workflow，只是一行行指令</p><p>汇编语言是基于寄存器进行操作的，而不是基于内存操作</p><p>RISC-V vs x86：</p><ul><li>RISC-V：精简指令集，指令更少，更加简单，唯一开源的ISA。ARM也是RISC(Reduced Instruction Set Chip)<li>x86：复杂指令集，指令很多并且可以实现复杂功能</ul><p>RISC-V assembly常用指令:</p><p>https://web.eecs.utk.edu/~smarz1/courses/ece356/notes/assembly/</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://img-blog.csdnimg.cn/20200405201502953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5NzY4NzQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><ul><li><code class="language-plaintext highlighter-rouge">ld/lb/lw rd, 8(rs)</code>：将*(rs+8)的值写入到rd寄存器，<code class="language-plaintext highlighter-rouge">lb</code>=load byte, <code class="language-plaintext highlighter-rouge">ld</code>=load double word, <code class="language-plaintext highlighter-rouge">lw</code>=load word<li><code class="language-plaintext highlighter-rouge">sd/sb/sw rd, 8(rs)</code>：将*(rd)`的值写入到rs+8地址上<li><code class="language-plaintext highlighter-rouge">add rd, rs1, rs2</code>：*(rd) = *(rs1) + *(rs2)<li><code class="language-plaintext highlighter-rouge">addi rd, rs1, int</code>: *(rd) = *(rs1) + int</ul><h2 id="42-calling-convention">4.2 Calling convention</h2><p>调用约定(calling convention)是规定子过程如何获取参数以及如何返回的方案，调用约定一般规定了</p><ul><li><p>参数、返回值、返回地址等放置的位置（寄存器、栈或存储器）</p><p>RISC-V寄存器通过寄存器而非栈来传递函数参数，a0-a7是int参数，fa0-fa7是float参数</p><li><p>如何将调用子过程的准备工作与恢复现场的工作划分到调用者(caller)与被调用者(callee)身上</p></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210127123800904.png" alt="image-20210127123800904" /></p><p>小于一个指针字(RISCV64中是8字节，RISCV32是4字节)的参数传入时将参数放在寄存器的最低位，因为RISC-V是小端系统，当2个指针字的参数传入时，低位的1个指针字放在偶数寄存器，比如a0上，高位的1个指针字放在奇数寄存器，比如a1上。当高于2个指针字的参数传入时以引用的方式传入。<code class="language-plaintext highlighter-rouge">struct</code>参数没有传到寄存器的部分将以栈的方式传入，<code class="language-plaintext highlighter-rouge">sp</code>栈指针将指向第一个没有传入到寄存器的参数。</p><p>从函数返回的值，如果是整数将放在a0和a1中，如果是小数将放置在fa0和fa1寄存器中。对于更大的返回值，将放置在内存中，caller开辟这个内存，并且把指向这个内存的指针作为第一个参数传递给callee</p><p>由caller保存的寄存器不会在函数调用之间被保存，又名易失性寄存器，如果要在过程调用后恢复该值，则调用方有责任将这些寄存器压入堆栈或复制到其他位置，而callee保存的寄存器会被保存，称为非易失性寄存器，可以期望这些寄存器在被调用者返回后保持相同的值。比如函数A调用了函数B，所有函数A保存的寄存器在函数B被调用后可以被B重写覆盖</p><h2 id="43-stack">4.3 Stack</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210127195509729.png" alt="image-20210127195509729" /></p><p>栈从高地址向低地址增长，每个大的box叫一个stack frame（栈帧），栈帧由函数调用来分配，每个栈帧大小不一定一样，但是栈帧的最高处一定是return address</p><p>sp是stack pointer，用于指向栈顶（低地址），保存在寄存器中</p><p>fp是frame pointer，用于指向<font color="red">当前</font>帧底部（高地址），保存在寄存器中，同时每个函数栈帧中保存了调用当前函数的函数（父函数）的fp（保存在to prev frame那一栏中）</p><p>这些栈帧都是由编译器编译生成的汇编文件生成的</p><h1 id="lecture-5-traps">Lecture 5 Traps</h1><h2 id="50-trap">5.0 trap</h2><p>3种可能的情况使得CPU暂停对正常指令的执行：1. syscall，移交给kernel 2. exception，指令执行了非法操作 3. 设备中断。以上情况合并称为<em>trap</em>。</p><p>trap应该对于被打断的指令是透明的，也就是说被打断的指令不应该知道这个地方产生了trap，产生trap之后现场应该得以恢复并继续执行被打断的指令。</p><p>xv6对trap的处理分为四个阶段：1. RISC-V CPU的硬件的一些动作 2. 汇编文件为了kernel C文件进行的一些准备 3. 用C实现的trap handler 4. system call / device-driver service routine</p><p>通常对于user space的trap、kernel space的trap和计时器中断会有不同的trap handler</p><h2 id="51-risc-v-trap-machinery">5.1 RISC-V trap machinery</h2><p>RISC-V CPU有一系列的控制寄存器可以通知kernel发生了trap，也可以由kernel写入来告诉CPU怎样处理trap</p><ul><li><p><code class="language-plaintext highlighter-rouge">stvec</code>：trap handler的地址，由kernel写入</p><li><p><code class="language-plaintext highlighter-rouge">sepc</code>：保存trap发生时的现场program counter，因为接下来<code class="language-plaintext highlighter-rouge">pc</code>要被取代为<code class="language-plaintext highlighter-rouge">stvec</code>。<code class="language-plaintext highlighter-rouge">sret</code>是从trap回到现场的指令，将<code class="language-plaintext highlighter-rouge">sepc</code>写回到<code class="language-plaintext highlighter-rouge">pc</code></p><li><p><code class="language-plaintext highlighter-rouge">scause</code>：一个trap产生的原因代码，由CPU写入</p><li><p><code class="language-plaintext highlighter-rouge">sscratch</code>：放在trap handler的最开始处</p><li><p><code class="language-plaintext highlighter-rouge">sstatus</code>：控制设备中断是否被开启，如果<code class="language-plaintext highlighter-rouge">sstatus</code>中的SIE位被清除，则RISC-V将推迟设备中断。SPP位指示这个trap是在user space中产生的还是在kernel space产生的，并将控制<code class="language-plaintext highlighter-rouge">sret</code>回到什么模式</p><p>以上寄存器只在supervisor模式下发生的trap被使用</p></ul><p>当发生除了计时器中断以外的其他类型的trap时，RISC-V将执行以下步骤：</p><ol><li>如果trap是一个设备产生的中断，而SIE又被清除的情况下，不做下方的任何动作<li>清除SIE来disable一切中断<li>把<code class="language-plaintext highlighter-rouge">pc</code>复制到<code class="language-plaintext highlighter-rouge">sepc</code><li>把当前的模式(user / supervisor)保存到SPP<li>设置<code class="language-plaintext highlighter-rouge">scause</code>寄存器来指示产生trap的原因<li>将当前的模式设置为supervisor<li>将<code class="language-plaintext highlighter-rouge">stvec</code>的值复制到<code class="language-plaintext highlighter-rouge">pc</code><li>开始执行<code class="language-plaintext highlighter-rouge">pc</code>指向的trap handler的代码</ol><p>注意CPU并没有切换到kernel页表，也没有切换到kernel栈</p><h2 id="52-traps-from-user-space">5.2 Traps from user space</h2><p>当user space中发生trap时，会将<code class="language-plaintext highlighter-rouge">stvec</code>的值复制到<code class="language-plaintext highlighter-rouge">pc</code>，而此时<code class="language-plaintext highlighter-rouge">stvec</code>的值是<code class="language-plaintext highlighter-rouge">trampoline.S</code>中的<code class="language-plaintext highlighter-rouge">uservec</code>，因此跳转到<code class="language-plaintext highlighter-rouge">uservec</code>，先保存一些现场的寄存器，恢复kernel栈指针、kernel page table到<code class="language-plaintext highlighter-rouge">satp</code>寄存器，再跳转到<code class="language-plaintext highlighter-rouge">usertrap</code>(kernel/trap.c)trap handler，然后返回<code class="language-plaintext highlighter-rouge">usertrapret</code>(kernel/trap.c)，跳回到kernel/trampoline.S，最后用<code class="language-plaintext highlighter-rouge">userret</code>(kernel/trampoline.S)通过<code class="language-plaintext highlighter-rouge">sret</code>跳回到user space</p><p>RISC-V在trap中不会改变页表，因此user page table必须有对<code class="language-plaintext highlighter-rouge">uservec</code>的mapping，<code class="language-plaintext highlighter-rouge">uservec</code>是<code class="language-plaintext highlighter-rouge">stvec</code>指向的trap vector instruction。<code class="language-plaintext highlighter-rouge">uservec</code>要切换<code class="language-plaintext highlighter-rouge">satp</code>到kernel页表，同时kernel页表中也要有和user页表中对<code class="language-plaintext highlighter-rouge">uservec</code>相同的映射。RISC-V将<code class="language-plaintext highlighter-rouge">uservec</code>保存在<em>trampoline</em>页中，并将<code class="language-plaintext highlighter-rouge">TRAMPOLINE</code>放在kernel页表和user页表的相同位置处（MAXVA)</p><p>当<code class="language-plaintext highlighter-rouge">uservec</code>开始时所有的32个寄存器都是trap前代码的值，但是<code class="language-plaintext highlighter-rouge">uservec</code>需要对某些寄存器进行修改来设置<code class="language-plaintext highlighter-rouge">satp</code>，可以用<code class="language-plaintext highlighter-rouge">sscratch</code>和<code class="language-plaintext highlighter-rouge">a0</code>的值进行交换，交换之前的<code class="language-plaintext highlighter-rouge">sscratch</code>中是指向user process的<code class="language-plaintext highlighter-rouge">trapframe</code>的地址，<code class="language-plaintext highlighter-rouge">trapframe</code>中预留了保存所有32个寄存器的空间。<code class="language-plaintext highlighter-rouge">p-&gt;trapframe</code>保存了每个进程的<code class="language-plaintext highlighter-rouge">TRAPFRAME</code>的物理空间从而让kernel页表也可以访问该进程的trapframe</p><p>当交换完<code class="language-plaintext highlighter-rouge">a0</code>和<code class="language-plaintext highlighter-rouge">sscratch</code>之后，<code class="language-plaintext highlighter-rouge">uservec</code>可以通过<code class="language-plaintext highlighter-rouge">a0</code>把所有当前寄存器的值保存到trapframe中。由于当前进程的trapframe已经保存了当前进程的kernel stack、当前CPU的hartid、<code class="language-plaintext highlighter-rouge">usertrap</code>的地址、kernel page table的地址等，<code class="language-plaintext highlighter-rouge">uservec</code>需要获取这些值，然后切换到kernel pagetable，调用<code class="language-plaintext highlighter-rouge">usertrap</code></p><p><code class="language-plaintext highlighter-rouge">usertrap</code>主要是判断trap产生的原因并进行处理，然后返回。因为当前已经在kernel里了，所以这时候如果再发生trap，应该交给<code class="language-plaintext highlighter-rouge">kernelvec</code>处理，因此要把<code class="language-plaintext highlighter-rouge">stvec</code>切换为<code class="language-plaintext highlighter-rouge">kernelvec</code>。如果trap是一个system call，那么<code class="language-plaintext highlighter-rouge">syscall</code>将被调用，如果是设备中断，调用<code class="language-plaintext highlighter-rouge">devintr</code>，否则就是一个exception，kernel将杀死这个出现错误的进程</p><p>回到user space的第一步是调用<code class="language-plaintext highlighter-rouge">usertrapret()</code>，这个函数将把<code class="language-plaintext highlighter-rouge">stvec</code>指向<code class="language-plaintext highlighter-rouge">uservec</code>，从而当回到user space再出现trap的时候可以跳转到<code class="language-plaintext highlighter-rouge">uservec</code>，同时设置<code class="language-plaintext highlighter-rouge">p-&gt;trapframe</code>的一些值为下一次trap作准备，比如设置<code class="language-plaintext highlighter-rouge">p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE</code>。清除<code class="language-plaintext highlighter-rouge">SPP</code>为从而使得调用<code class="language-plaintext highlighter-rouge">sret</code>后能够回到user mode。设置回到user space后的program counter为<code class="language-plaintext highlighter-rouge">p-&gt;trapframe-&gt;epc</code>，最后调用跳转到TRAMPOLINE页上的<code class="language-plaintext highlighter-rouge">userret</code>回到trampoline.S，加载user page table。<code class="language-plaintext highlighter-rouge">userret</code>被<code class="language-plaintext highlighter-rouge">userrapret</code>调用返回时a0寄存器中保存了TRAPFRAME，因此可以通过这个TRAPFRAME地址来恢复之前所有寄存器的值(包括a0)，最后把TRAPFRAME保存在sscratch中，用<code class="language-plaintext highlighter-rouge">sret</code>回到user space</p><h2 id="53-calling-system-calls">5.3 Calling system calls</h2><p>user调用<code class="language-plaintext highlighter-rouge">exec</code>执行system call的过程：把给<code class="language-plaintext highlighter-rouge">exec</code>使用的参数放到a0和a1寄存器中，把system call的代码(SYS_exec)放到a7寄存器中，<code class="language-plaintext highlighter-rouge">ecall</code>指令将陷入内核中（通过usys.pl中的entry)。<code class="language-plaintext highlighter-rouge">ecall</code>的效果有三个，包括将CPU从user mode切换到supervisor mode、将<code class="language-plaintext highlighter-rouge">pc</code>保存到<code class="language-plaintext highlighter-rouge">epc</code>以供后续恢复、将<code class="language-plaintext highlighter-rouge">uservec</code>设置为<code class="language-plaintext highlighter-rouge">stvec</code>，并执行<code class="language-plaintext highlighter-rouge">uservec</code>、<code class="language-plaintext highlighter-rouge">usertrap</code>，然后执行<code class="language-plaintext highlighter-rouge">syscall</code>。kernel trap code将把寄存器的值保存在当前进程的trapframe中。syscall将把trapframe中的a7寄存器保存的值提取出来，索引到<code class="language-plaintext highlighter-rouge">syscalls</code>这个函数数列中查找对应的syscall种类，并进行调用，然后把返回值放置在<code class="language-plaintext highlighter-rouge">p-&gt;trapframe-&gt;a0</code>中，如果执行失败，就返回-1。</p><p>syscall的argument可以用<code class="language-plaintext highlighter-rouge">argint</code>、<code class="language-plaintext highlighter-rouge">argaddr</code>、<code class="language-plaintext highlighter-rouge">argfd</code>等函数从内存中取出</p><h2 id="54-traps-from-kernel-space">5.4 Traps from kernel space</h2><p>当执行kernel code发生CPU trap的时候，<code class="language-plaintext highlighter-rouge">stvec</code>是指向<code class="language-plaintext highlighter-rouge">kernelvec</code>的汇编代码的。<code class="language-plaintext highlighter-rouge">kernelvec</code>将寄存器的值保存在被中断的kernel thread的栈里而不是trapframe里，这样当trap需要切换kernel thread时，再切回来之后还可以从原先的thread栈里找到之前的寄存器值。</p><p>保存完寄存器之后，跳转到<code class="language-plaintext highlighter-rouge">kerneltrap</code>这个trap handler。<code class="language-plaintext highlighter-rouge">kerneltrap</code>可以对设备中断和exception这两种trap进行处理。如果是设备中断，调用<code class="language-plaintext highlighter-rouge">devintr</code>进行处理，如果是exception就panic，如果是因为计时器中断，就调用<code class="language-plaintext highlighter-rouge">yield</code>让其他kernel thread运行</p><p>最后返回到<code class="language-plaintext highlighter-rouge">kernelvec</code>中，<code class="language-plaintext highlighter-rouge">kernelvec</code>将保存的寄存器值从堆栈中弹出，执行<code class="language-plaintext highlighter-rouge">sret</code>，将<code class="language-plaintext highlighter-rouge">sepc</code>复制到<code class="language-plaintext highlighter-rouge">pc</code>来执行之前被打断的kernel code</p><h2 id="55-lab-4-traps">5.5 Lab 4: Traps</h2><ol><li><p>Backtrace</p><p>实验要求：当调用sys_sleep时打印出函数调用关系的backtrace，即递归地打印每一个函数以及调用这个函数及其父函数的return address，比如</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>backtrace:
0x0000000080002cda
0x0000000080002bb6
0x0000000080002898
</pre></table></code></div></div><p>gcc将当前执行的函数的frame pointer存储在s0寄存器中，可以在kernel/riscv.h中声明以下函数来获取s0</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="n">uint64</span>
<span class="nf">r_fp</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">uint64</span> <span class="n">x</span><span class="p">;</span>
  <span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">"mv %0, s0"</span> <span class="o">:</span> <span class="s">"=r"</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">);</span>
  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>当前函数的return address位于fp-8的位置，previous frame pointer位于fp-16的位置。</p><p>每个kernel stack都是一页，因此可以通过计算<code class="language-plaintext highlighter-rouge">PGROUNDDOWN(fp)</code>和<code class="language-plaintext highlighter-rouge">PGROUNDUP(fp)</code>来确定当前的fp地址是否还位于这一页内，从而可以是否已经完成了所有嵌套的函数调用的backtrace。</p><p>在kernel/printf.c中</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">backtrace</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">uint64</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"backtrace:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">fp</span> <span class="o">=</span> <span class="n">r_fp</span><span class="p">();</span>  <span class="c1">// frame pointer of currently executing function</span>
  <span class="n">top</span> <span class="o">=</span> <span class="n">PGROUNDUP</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="n">bottom</span> <span class="o">=</span> <span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">fp</span> <span class="o">&lt;</span> <span class="n">top</span> <span class="o">&amp;&amp;</span> <span class="n">fp</span> <span class="o">&gt;</span> <span class="n">bottom</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">ra</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">uint64</span> <span class="o">*</span><span class="p">)(</span><span class="n">fp</span><span class="o">-</span><span class="mi">8</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ra</span><span class="p">);</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">uint64</span> <span class="o">*</span><span class="p">)(</span><span class="n">fp</span><span class="o">-</span><span class="mi">16</span><span class="p">);</span> <span class="c1">// saved previous frame pointer</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>Alarm</p><p>实验要求：添加一个新的system call<code class="language-plaintext highlighter-rouge">sigalarm(interval, handler)</code>，<code class="language-plaintext highlighter-rouge">interval</code>是一个计时器的tick的间隔大小，<code class="language-plaintext highlighter-rouge">handler</code>是指向一个函数的指针，这个函数是当计时器tick到达<code class="language-plaintext highlighter-rouge">interval</code>时触发的函数。</p><p>首先修改Makefile使得alarmtest.c能够被编译，在user/user.h中添加函数声明</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">sigalarm</span><span class="p">(</span><span class="kt">int</span> <span class="n">ticks</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)());</span>
<span class="kt">int</span> <span class="nf">sigreturn</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></table></code></div></div><p>在user/user.pl、kernel/syscall.h、kernel/syscall.c等添加<code class="language-plaintext highlighter-rouge">sys_sigalarm</code>和<code class="language-plaintext highlighter-rouge">sys_sigreturn</code>这两个syscall的注册</p><p>在kernel/proc.h的proc结构体中添加几个成员。<code class="language-plaintext highlighter-rouge">int interval</code>是保存的定时器触发的周期，<code class="language-plaintext highlighter-rouge">void (*handler)()</code>是指向handler函数的指针，这两个成员变量在<code class="language-plaintext highlighter-rouge">sys_sigalarm</code>中被保存。<code class="language-plaintext highlighter-rouge">ticks</code>用来记录从上一次定时器被触发之后到目前的ticks，<code class="language-plaintext highlighter-rouge">in_handler</code>用来记录当前是否在handler函数中，用来防止在handler函数的过程中定时被触发再次进入handler函数。下面的所有寄存器都是用来保护和恢复现场的。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre>  <span class="kt">int</span> <span class="n">interval</span><span class="p">;</span>                <span class="c1">// interval of alarm</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)();</span>           <span class="c1">// pointer to the handler function</span>
  <span class="kt">int</span> <span class="n">ticks</span><span class="p">;</span>                   <span class="c1">// how many ticks have passed since last call</span>
  <span class="kt">int</span> <span class="n">in_handler</span><span class="p">;</span>              <span class="c1">// to prevent from reentering into handler when in handler</span>
  <span class="n">uint64</span> <span class="n">saved_epc</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_ra</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_sp</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_gp</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_tp</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_t0</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_t1</span><span class="p">;</span> 
  <span class="n">uint64</span> <span class="n">saved_t2</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_s0</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_s1</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_s2</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_s3</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_s4</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_s5</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_s6</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_s7</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_s8</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_s9</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_s10</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_s11</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_a0</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_a1</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_a2</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_a3</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_a4</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_a5</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_a6</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_a7</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_t3</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_t4</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_t5</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">saved_t6</span><span class="p">;</span>
</pre></table></code></div></div><p>在kernel/sysfile.c中分别添加<code class="language-plaintext highlighter-rouge">uint64 sys_sigreturn(void)</code>和<code class="language-plaintext highlighter-rouge">uint64 sys_sigalarm(void)</code>的实现</p><p>对于<code class="language-plaintext highlighter-rouge">sys_sigalarm</code>，需要将从userfunction传入的两个参数分别保存到<code class="language-plaintext highlighter-rouge">p</code>结构体相应的成员变量中</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">uint64</span>
<span class="nf">sys_sigalarm</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">ticks</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">funaddr</span><span class="p">;</span> <span class="c1">// pointer to function</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">argint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ticks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">argaddr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">funaddr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="n">ticks</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">funaddr</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>对于<code class="language-plaintext highlighter-rouge">sys_sigreturn</code>，这个函数会在handler函数完成之后被调用，它的主要工作是恢复现场的寄存器，并且将<code class="language-plaintext highlighter-rouge">in_handler</code>这个flag置0</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="n">uint64</span>
<span class="nf">sys_sigreturn</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">epc</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_epc</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">ra</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_ra</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_sp</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">gp</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_gp</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">tp</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_tp</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">t0</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_t0</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">t1</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_t1</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">t2</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_t2</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">t3</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_t3</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">t4</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_t4</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">t5</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_t5</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">t6</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_t6</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s0</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s0</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s1</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s1</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s2</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s2</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s3</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s3</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s4</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s4</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s5</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s5</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s6</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s6</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s7</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s7</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s8</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s8</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s9</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s9</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s10</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s10</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s11</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s11</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_a0</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a1</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_a1</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a2</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_a2</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a3</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_a3</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a4</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_a4</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a5</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_a5</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a6</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_a6</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a7</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_a7</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">in_handler</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>kernel/trap.c中的<code class="language-plaintext highlighter-rouge">usertrap()</code>是对陷入定时器中断的处理，需要判断<code class="language-plaintext highlighter-rouge">which_dev==2</code>才是定时器中断，当<code class="language-plaintext highlighter-rouge">p-&gt;ticks</code>到达预设值<code class="language-plaintext highlighter-rouge">p-&gt;interval</code>时，将调用<code class="language-plaintext highlighter-rouge">p-&gt;handler</code>，这是通过向<code class="language-plaintext highlighter-rouge">p-&gt;trapframe-&gt;epc</code>加载handler地址实现的，这样当从<code class="language-plaintext highlighter-rouge">usertrap()</code>中返回时，<code class="language-plaintext highlighter-rouge">pc</code>在恢复现场时会加载<code class="language-plaintext highlighter-rouge">p-&gt;trapframe-&gt;epc</code>，这样就会跳转到handler地址。在跳转到handler之前先要保存<code class="language-plaintext highlighter-rouge">p-&gt;trapframe</code>的寄存器，因为执行handler函数会导致这些寄存器被覆盖。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre> <span class="n">syscall</span><span class="p">();</span>
  <span class="err">}</span> <span class="k">else</span> <span class="nf">if</span><span class="p">((</span><span class="n">which_dev</span> <span class="o">=</span> <span class="n">devintr</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
    <span class="c1">// ok</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">which_dev</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">in_handler</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">p</span><span class="o">-&gt;</span><span class="n">ticks</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ticks</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">in_handler</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">ticks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_epc</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">epc</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_ra</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">ra</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_sp</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_gp</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">gp</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_tp</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">tp</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_t0</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">t0</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_t1</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">t1</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_t2</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">t2</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_t3</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">t3</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_t4</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">t4</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_t5</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">t5</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_t6</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">t6</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s0</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s0</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s1</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s1</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s2</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s2</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s3</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s4</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s4</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s5</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s5</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s6</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s6</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s7</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s7</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s8</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s8</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s9</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s9</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s10</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s10</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_s11</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">s11</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_a0</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_a1</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a1</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_a2</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a2</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_a3</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a3</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_a4</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a4</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_a5</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a5</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_a6</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a6</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">saved_a7</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a7</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">epc</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</pre></table></code></div></div></ol><h1 id="lecture-6-page-faults">Lecture 6 Page Faults</h1><p>当试图访问PTE_V为0的虚拟地址或user访问PTE_U为0/kernel访问PTE_U为1以及其他违反PTE_W/PTE_R等flag的情况下会出现page faults。Page faults是一个exception，总共有3种page faults：</p><ol><li>load page faults：当load instruction无法翻译虚拟地址时发生<li>store page faults：当store instruction无法翻译虚拟地址时发生<li>instruction page faults：当一个instruction的地址无法翻译时发生</ol><p>page faults种类的代码存放在<code class="language-plaintext highlighter-rouge">scause</code>寄存器中，无法翻译的地址存放在<code class="language-plaintext highlighter-rouge">stval</code>寄存器中。</p><p>在xv6中对于exception一律都会将这个进程kill掉，但是实际上可以结合page faults实现一些功能。</p><ol><li>可以实现<em>copy-on-write fork</em>。在<code class="language-plaintext highlighter-rouge">fork</code>时，一般都是将父进程的所有user memory复制到子进程中，但是<code class="language-plaintext highlighter-rouge">fork</code>之后一般会直接进行<code class="language-plaintext highlighter-rouge">exec</code>，这就会导致复制过来的user memory又被放弃掉。因此改进的思路是：子进程和父进程共享一个物理内存，但是mapping时将PTE_W置零，只有当子进程或者父进程的其中一个进程需要向这个地址写入时产生page fault，此时才会进行copy<li>可以实现<em>lazy allocation</em>。旧的<code class="language-plaintext highlighter-rouge">sbrk()</code>申请分配内存，但是申请的这些内存进程很可能不会全部用到，因此改进方案为：当进程调用<code class="language-plaintext highlighter-rouge">sbrk()</code>时，将修改<code class="language-plaintext highlighter-rouge">p-&gt;sz</code>，但是并不实际分配内存，并且将PTE_V置0。当在试图访问这些新的地址时发生page fault再进行物理内存的分配<li><em>paging from disk</em>：当内存没有足够的物理空间时，可以先将数据存储在其他的存储介质（比如硬盘）上，，将该地址的PTE设置为invalid，使其成为一个evicted page。当需要读或者写这个PTE时，产生Page fault，然后在内存上分配一个物理地址，将这个硬盘上的evicted page的内容写入到该内存上，设置PTE为valid并且引用到这个内存物理地址</ol><h2 id="61-lab-5-lazy-allocation">6.1 Lab 5: lazy allocation</h2><ol><li><p>实验要求：在<code class="language-plaintext highlighter-rouge">sbrk()</code>时只增长进程的<code class="language-plaintext highlighter-rouge">myproc()-&gt;sz</code>而不实际分配内存。在kernel/trap.c中修改从而在产生page fault时分配物理内存给相应的虚拟地址。相应的虚拟地址可以通过<code class="language-plaintext highlighter-rouge">r_stval()</code>获得。<code class="language-plaintext highlighter-rouge">r_scause()</code>为13或15表明trap的原因是page fault</p><p>kernel/sysproc.c中修改<code class="language-plaintext highlighter-rouge">sys_sbrk()</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">uint64</span>
<span class="nf">sys_sbrk</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">addr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">argint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">addr</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">;</span>
  <span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">sz</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
  <span class="c1">// if(growproc(n) &lt; 0)</span>
  <span class="c1">//   return -1;</span>
  <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>kernel/trap.c中，在<code class="language-plaintext highlighter-rouge">usertrap()</code>函数中</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre> <span class="err">}</span> <span class="k">else</span> <span class="nf">if</span><span class="p">((</span><span class="n">which_dev</span> <span class="o">=</span> <span class="n">devintr</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
    <span class="c1">// ok</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r_scause</span><span class="p">()</span> <span class="o">==</span> <span class="mi">13</span> <span class="o">||</span> <span class="n">r_scause</span><span class="p">()</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// page fault</span>
      <span class="n">uint64</span> <span class="n">va</span> <span class="o">=</span> <span class="n">r_stval</span><span class="p">();</span>
      <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>
      <span class="n">va</span> <span class="o">=</span> <span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">mem</span> <span class="o">=</span> <span class="n">kalloc</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">"cannot allocate for lazy alloc</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span> 
      <span class="k">if</span> <span class="p">(</span><span class="n">mappages</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">mem</span><span class="p">,</span> <span class="n">PTE_W</span><span class="o">|</span><span class="n">PTE_X</span><span class="o">|</span><span class="n">PTE_R</span><span class="o">|</span><span class="n">PTE_U</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">kfree</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">"cannot map for lazy alloc</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"usertrap(): unexpected scause %p pid=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">r_scause</span><span class="p">(),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"            sepc=%p stval=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">r_sepc</span><span class="p">(),</span> <span class="n">r_stval</span><span class="p">());</span>
      <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
   
</pre></table></code></div></div><p>修改kernel/vm.c中的<code class="language-plaintext highlighter-rouge">uvmunmap</code>，因为lazy allocation可能会造成<code class="language-plaintext highlighter-rouge">myproc()-sz</code>以下的内容没有被分配的情况，因此在unmap的过程中可能会出现panic，这是正常情况，需要<code class="language-plaintext highlighter-rouge">continue</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">if</span><span class="p">((</span><span class="n">pte</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="c1">// panic("uvmunmap: walk");</span>
<span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">continue</span><span class="p">;</span>	    
<span class="c1">// panic("uvmunmap: not mapped");</span>
<span class="k">if</span><span class="p">(</span><span class="n">PTE_FLAGS</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)</span> <span class="o">==</span> <span class="n">PTE_V</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"uvmunmap: not a leaf"</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">do_free</span><span class="p">){</span>
</pre></table></code></div></div><li><p>实验要求： 在第一部分的基础上，要求处理</p></ol><ul><li><p><code class="language-plaintext highlighter-rouge">sbrk()</code>的参数为负的情况，deallocate即可</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// deallocate the memory</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">sz</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">uvmdealloc</span><span class="p">(</span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">+</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">addr</span><span class="o">+</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p><code class="language-plaintext highlighter-rouge">fork()</code>中将父进程的内存复制给子进程的过程中用到了<code class="language-plaintext highlighter-rouge">uvmcopy</code>，<code class="language-plaintext highlighter-rouge">uvmcopy</code>原本在发现缺失相应的PTE等情况下会panic，这里也要<code class="language-plaintext highlighter-rouge">continue</code>掉。在kernel/proc.c的<code class="language-plaintext highlighter-rouge">uvmcopy</code>中</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">if</span><span class="p">((</span><span class="n">pte</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="c1">// panic("uvmcopy: pte should exist");</span>
<span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="c1">// panic("uvmcopy: page not present");</span>
</pre></table></code></div></div><li><p>当造成的page fault在进程的user stack以下（栈底）或者在<code class="language-plaintext highlighter-rouge">p-&gt;sz</code>以上（堆顶）时，kill这个进程。在kernel/trap.c的<code class="language-plaintext highlighter-rouge">usertrap</code>中增加以下判断条件</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">((</span><span class="n">va</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">va</span> <span class="o">&gt;</span> <span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">)))</span>
</pre></table></code></div></div><li><p>在<code class="language-plaintext highlighter-rouge">exec</code>中，<code class="language-plaintext highlighter-rouge">loadseg</code>调用了<code class="language-plaintext highlighter-rouge">walkaddr</code>，可能会找不到相应虚拟地址的PTE，此时需要分配物理地址。在kernel/vm.c中</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">if</span><span class="p">((</span><span class="n">pte</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">va</span> <span class="o">&gt;</span> <span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">sz</span> <span class="o">||</span> <span class="n">va</span> <span class="o">&lt;</span> <span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> 
    <span class="k">if</span> <span class="p">((</span><span class="n">mem</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">kalloc</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">va</span> <span class="o">=</span> <span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mappages</span><span class="p">(</span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">PTE_W</span><span class="o">|</span><span class="n">PTE_X</span><span class="o">|</span><span class="n">PTE_R</span><span class="o">|</span><span class="n">PTE_U</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">kfree</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">mem</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div></ul><h1 id="lecture-7-interrupts">Lecture 7 Interrupts</h1><p>设备会产生中断，xv6处理设备中断的代码位于kernel/trap.c中的<code class="language-plaintext highlighter-rouge">devintr</code>。</p><p>进程的内核态中执行<em>top half</em>，中断时间中执行<em>bottom half</em>。top half是通过<code class="language-plaintext highlighter-rouge">read</code>或<code class="language-plaintext highlighter-rouge">write</code>这样的system call来进行调用的，从而能让这个设备执行I/O操作。当设备执行完I/O操作之后，将产生一个设备中断，这个设备驱动的interrupt handler作为bottom half执行相应的操作。interrupt handler中没有任何用户进程的上下文，因此无法进行<code class="language-plaintext highlighter-rouge">copyin</code>或<code class="language-plaintext highlighter-rouge">copyout</code>，只有top half才能和用户进程进行交互。</p><ul><li><code class="language-plaintext highlighter-rouge">PLIC</code>: Platform-Level Interrupt Controller，负责对从外部设备产生的中断进行管理<li><code class="language-plaintext highlighter-rouge">CLINT</code>: Core-Local Interrupter，负责定时器相关的中断</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210201115733957.png" alt="image-20210201115733957" /></p><h2 id="71-console-input">7.1 Console input</h2><p>console driver(kernel/console.c)是一个设备驱动，通过UART串口接受输入的符号。用户进程通过<code class="language-plaintext highlighter-rouge">read</code> system call来从console中一行行读取输入</p><p>xv6中使用的UART是QEMU模拟的16550芯片。UART硬件对于进程来说是一组<em>memory-mapped</em>寄存器，即RISC-V上有一些物理地址是直接和UART设备相连的。UART的地址从0x10000000或<code class="language-plaintext highlighter-rouge">UART0</code>开始，每个UART控制寄存器的大小为1字节，其位置定义在kernel/uart.c中。</p><ul><li><code class="language-plaintext highlighter-rouge">LSR</code>寄存器：line status register，用来指示输入的字节是否准备好被用户进程读取<li><p><code class="language-plaintext highlighter-rouge">RHR</code>寄存器：receive holding register，用来放置可以被用户进程读取的字节。当RHR中的一个字节被读取时，UART硬件将其从内部的FIFO硬盘中删除，当FIFO中为空时，<code class="language-plaintext highlighter-rouge">LSR</code>寄存器被置0</p><li><code class="language-plaintext highlighter-rouge">THR</code>寄存器：transmit holding register，当用户进程向<code class="language-plaintext highlighter-rouge">THR</code>写入一个字节时，UART将传输这个字节</ul><p>xv6的<code class="language-plaintext highlighter-rouge">main</code>函数将调用<code class="language-plaintext highlighter-rouge">consoleinit</code>来初始化UART硬件，使得UART硬件在接收到字节或传输完成一个字节时发出中断</p><p>xv6 shell程序通过<code class="language-plaintext highlighter-rouge">user/init.c</code>开启的文件描述符来从console读取字节（在while循环中调用<code class="language-plaintext highlighter-rouge">getcmd</code>，在其中调用<code class="language-plaintext highlighter-rouge">gets</code>，再调用<code class="language-plaintext highlighter-rouge">read</code>system call）。在kernel中调用<code class="language-plaintext highlighter-rouge">consoleread</code>，等待输入完毕之后的中断，然后将输入缓存在<code class="language-plaintext highlighter-rouge">cons.buf</code>中，将输入<code class="language-plaintext highlighter-rouge">either_copyout</code>到user space后返回用户进程。如果用户没有输入完整的一行，则读取进程将在<code class="language-plaintext highlighter-rouge">sleep</code>system call中等待。</p><p>当用户输入了一个字符后，UART硬件将产生一个中断，这个终端将触发xv6进入trap。trap handler将调用<code class="language-plaintext highlighter-rouge">devintr</code>来通过<code class="language-plaintext highlighter-rouge">scause</code>寄存器判断是外部设备触发了这个中断，然后硬件将调用PLIC来判断是哪个外部设备触发的这个中断，如果是UART触发的，<code class="language-plaintext highlighter-rouge">devintr</code>将调用<code class="language-plaintext highlighter-rouge">uartintr</code>。<code class="language-plaintext highlighter-rouge">uartintr</code>将读取从UART硬件中写入的字符然后将其传送给<code class="language-plaintext highlighter-rouge">consoleintr</code>，<code class="language-plaintext highlighter-rouge">consoleintr</code>将积累这些字符直到整行都已经被读取，然后将唤醒仍在<code class="language-plaintext highlighter-rouge">sleep</code>的<code class="language-plaintext highlighter-rouge">consoleread</code>。当<code class="language-plaintext highlighter-rouge">consoleread</code>被唤醒后，将这一行命令复制给user space然后返回。</p><p>RISC-V对中断的支持：</p><p><code class="language-plaintext highlighter-rouge">SIE</code>(supervisor interrupt enable) 寄存器用来控制中断，其中有一位是控制外部设备的中断（SEIE），一位控制suffer interrupt(一个CPU向另外一个CPU发出中断)(SSIE)，一位控制定时器中断(STIE)</p><p><code class="language-plaintext highlighter-rouge">SSTATUS</code>(supervisor status)寄存器，对某一个特定的CPU核控制是否接收寄存器，在kernel/riscv.h中的<code class="language-plaintext highlighter-rouge">intr_on</code>被设置</p><p><code class="language-plaintext highlighter-rouge">SIP</code>(supervisor interrupt pending)寄存器，可以观察这个寄存器来判断有哪些中断在pending</p><p>case study:</p><p>用户在键盘上输入了一个字符l，这个l通过键盘被发送到UART，然后通过PLIC发送到CPU的一个核，这个核产生中断，跑到<code class="language-plaintext highlighter-rouge">devintr</code>，<code class="language-plaintext highlighter-rouge">devintr</code>发现是来自UART的，调用<code class="language-plaintext highlighter-rouge">uartintr</code>，调用<code class="language-plaintext highlighter-rouge">uartgetc()</code>通过<code class="language-plaintext highlighter-rouge">RHR</code>寄存器来获取这个字符，然后调用<code class="language-plaintext highlighter-rouge">consoleintr</code>，判断这个字符是否是特殊字符(backspace等)，如果不是则将这个字符通过<code class="language-plaintext highlighter-rouge">consputc(c)</code>echo回给user，然后将其存储在<code class="language-plaintext highlighter-rouge">cons.buf</code>中，当发现整行已经输入完成后(<code class="language-plaintext highlighter-rouge">c=='\n' || c ==C('D'))</code>)，唤醒<code class="language-plaintext highlighter-rouge">consoleread()</code></p><h2 id="72-console-output">7.2 Console output</h2><p>对console上的文件描述符进行<code class="language-plaintext highlighter-rouge">write</code>system call，最终到达kernel/uart.c的<code class="language-plaintext highlighter-rouge">uartputc</code>函数。输出的字节将缓存在<code class="language-plaintext highlighter-rouge">uart_tx_buf</code>中，这样写入进程就不需要等待UART硬件完成字节的发送，只要当这个缓存区满了的情况下<code class="language-plaintext highlighter-rouge">uartputc</code>才会等待。当UART完成了一个字符的发送之后，将产生一个中断，<code class="language-plaintext highlighter-rouge">uartintr</code>将调用<code class="language-plaintext highlighter-rouge">uartstart</code>来判断设备是否确实已经完成发送，然后将下一个需要发送的字符发送给UART。因此让UART传送多个字符时，第一个字符由<code class="language-plaintext highlighter-rouge">uartputc</code>对<code class="language-plaintext highlighter-rouge">uartstart</code>的调用传送，后面的字符由<code class="language-plaintext highlighter-rouge">uartintr</code>对<code class="language-plaintext highlighter-rouge">uartstart</code>的调用进行传送</p><p><em>I/O concurrency</em>：设备缓冲和中断的解耦，从而让设备能够在没有进程等待读入的时候也能让console driver处理输入，等后面有进程需要读入的时候可以不需要等待。同时进程也可以不需要等待设备而直接写入字符到缓冲区。</p><p>在<code class="language-plaintext highlighter-rouge">consoleread</code>和<code class="language-plaintext highlighter-rouge">consoleintr</code>中调用了<code class="language-plaintext highlighter-rouge">acquire</code>来获取一个锁，从而保护当前的console driver，防止同时期其他进程对其的访问造成的干扰。</p><h2 id="73-timer-interrupts">7.3 Timer interrupts</h2><p>xv6用计时器中断来在线程间切换，<code class="language-plaintext highlighter-rouge">usertrap</code>和<code class="language-plaintext highlighter-rouge">kerneltrap</code>中的<code class="language-plaintext highlighter-rouge">yield</code>也会导致这种进程切换。RISC-V要求定时器中断的handler放在machine mode而不是supervisor mode中，而machine mode下是没有paging的，同时有另外一套完全独立的控制寄存器，因此不能将计时器中断的handler放在trap机制中执行。</p><p><code class="language-plaintext highlighter-rouge">kernel/start.c</code>（在<code class="language-plaintext highlighter-rouge">main</code>之前）运行在machine mode下，<code class="language-plaintext highlighter-rouge">timerinit()</code>在<code class="language-plaintext highlighter-rouge">start.c</code>中被调用，用来配置CLINT(<em>core-local interruptor</em>)从而能够在一定延迟之后发送一个中断，并设置一个类似于trapframe的scratch area来帮助定时器中断handler将寄存器和CLINT寄存器的地址保存到里面，最终<code class="language-plaintext highlighter-rouge">start</code>设置<code class="language-plaintext highlighter-rouge">timervec</code>到<code class="language-plaintext highlighter-rouge">mtvec</code>(<em>machine-mode trap handler</em>)中使得在machine mode下发生中断后跳转到<code class="language-plaintext highlighter-rouge">timervec</code>然后enable定时器中断。</p><p>由于定时器中断可能在任意时间点发生，包括kernel在执行关键的操作时，无法强制关闭定时器中断，因此定时器中断的发生不能够影响这些被中断的操作。解决这个问题的方法是定时器中断handler让RISC-V CPU产生一个”software interrupt”然后立即返回，software interrupt以正常的trap机制被送到kernel中，可以被kernel禁用。</p><p><code class="language-plaintext highlighter-rouge">timervec</code>是一组汇编指令，将一些寄存器保存在scratch area中，告知CLINT产生下一次定时器中断的时间，让RISC-V产生一个software interrupt，恢复寄存器并返回到trap.c中，判断<code class="language-plaintext highlighter-rouge">which_dev==2</code>为定时器中断后调用<code class="language-plaintext highlighter-rouge">yield()</code></p><h2 id="74-real-world">7.4 Real world</h2><p>计时器中断将会通过调用<code class="language-plaintext highlighter-rouge">yield</code>进行强制的线程切换从而使CPU能够在各个内核线程之间均匀分配时间。</p><p>UART是通过对UART控制寄存器一个字节一个字节读取来获取数据的，这种方式叫做<em>programmed I/O</em>，因为是软件控制了数据的I/O，缺点是速度比较慢。DMA(<em>Directed Memory Access</em>)直接向RAM写入和读取数据，速度很快。现代的硬盘和网卡驱动使用DMA。</p><p>由于中断非常耗时，因此可以用一些技巧来减少中断。1. 用一个中断来处理很多一段时间内的事件。 2. 彻底禁止设备的中断，让CPU定时去检查这些设备是否有任务需要处理，这种技巧叫做<em>polling</em></p><h1 id="lecture-8-locking">Lecture 8 Locking</h1><p>多核CPU同时对某个共享的数据结构进行读写操作可能会发生冲突，因此需要<em>concurrency control</em>，即<em>锁</em>。锁提供了一种互斥机制，一段时间内只有一个CPU才能拥有这个锁，如果一个锁和一个被共享的数据结构联系起来，那么这个数据结构一次只能被一个CPU使用</p><h2 id="81-race-conditions">8.1 Race conditions</h2><p>kernel allocator中有一个<code class="language-plaintext highlighter-rouge">free</code>链表用来指示当前空闲待分配的内存，<code class="language-plaintext highlighter-rouge">kalloc()</code>将一页内存从<code class="language-plaintext highlighter-rouge">free</code>中弹出，<code class="language-plaintext highlighter-rouge">kfree()</code>将一页内存压入<code class="language-plaintext highlighter-rouge">free</code>。这个<code class="language-plaintext highlighter-rouge">free</code>链表被两个CPU的两个不同进程共享，如下图所示</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210201211120787.png" alt="image-20210201211120787" /></p><p><em>race condition</em>：一个内存地址同时被至少一个写入操作访问，会造成bug</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">element</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">lock</span> <span class="n">listlock</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">push</span> <span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">element</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">l</span><span class="p">);</span>
    <span class="n">l</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listlock</span><span class="p">);</span>
    <span class="c1">// critical section</span>
    <span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
    <span class="n">list</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
    <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listlock</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">acquire</code>和<code class="language-plaintext highlighter-rouge">release</code>之间的代码叫做<em>critical section</em>。</p><p>当两个进程同时要求一个相同的锁时，这两个进程发生冲突，xv6对进程锁冲突没有做预防举措，但是更复杂的其他的kernel对此有实现。</p><p>注意<code class="language-plaintext highlighter-rouge">acquire</code>和<code class="language-plaintext highlighter-rouge">release</code>的位置很重要，不要包围不必要的代码，否则会降低程序运行效率。</p><h2 id="82-code-locks">8.2 Code: Locks</h2><p>xv6有两种锁：spinlock和sleep-lock。spinlock的代码位于kernel/spinlock.h的<code class="language-plaintext highlighter-rouge">struct spinlock</code>中</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">spinlock</span> <span class="p">{</span>
  <span class="n">uint</span> <span class="n">locked</span><span class="p">;</span>       <span class="c1">// Is the lock held?</span>

  <span class="c1">// For debugging:</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>        <span class="c1">// Name of lock.</span>
  <span class="k">struct</span> <span class="n">cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">;</span>   <span class="c1">// The cpu holding the lock.</span>
<span class="p">};</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">locked</code>为0时说明这个锁是可以acquire的。</p><p><code class="language-plaintext highlighter-rouge">acquire</code>中需要让类似于</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></table></code></div></div><p>这样的逻辑原子化，否则当两个不同的进程同时执行到上面的判断条件时，可能会同时获取这个锁。RISC-V是通过<code class="language-plaintext highlighter-rouge">amoswap r, a</code>来实现的，它将<code class="language-plaintext highlighter-rouge">a</code>内存地址中的内容和<code class="language-plaintext highlighter-rouge">r</code>寄存器中的内容互换。在<code class="language-plaintext highlighter-rouge">acquire</code>中，通过一个对<code class="language-plaintext highlighter-rouge">amoswap</code>的包装函数<code class="language-plaintext highlighter-rouge">__sync_lock_test_and_set(&amp;lk-&gt;locked, 1)</code>来实现这个原子操作，这个函数的返回值是<code class="language-plaintext highlighter-rouge">lk-&gt;locked</code>的旧的值(被换下来的值)</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">while</span><span class="p">(</span><span class="n">__sync_lock_test_and_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">;</span>
</pre></table></code></div></div><p>通过while不断尝试将1和<code class="language-plaintext highlighter-rouge">&amp;lk-&gt;locked</code>互换(spinning)，当原先的<code class="language-plaintext highlighter-rouge">lk-&gt;locked</code>是0时跳出循环，这个锁被取得，否则当原先的<code class="language-plaintext highlighter-rouge">lk-&gt;locked</code>是1时不会跳出循环，并且<code class="language-plaintext highlighter-rouge">lk-&gt;locked</code>和1互换还是1，不会改变它的状态。</p><p><code class="language-plaintext highlighter-rouge">release</code>是<code class="language-plaintext highlighter-rouge">acquire</code>的反向操作，先将<code class="language-plaintext highlighter-rouge">lk-&gt;cpu</code>清零。然后调用</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">__sync_lock_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span><span class="p">);</span>
<span class="c1">// 相当于</span>
<span class="c1">// s1 = &amp;lk-&gt;locked</span>
<span class="c1">// amoswap.w zero, zero, (s1)</span>
</pre></table></code></div></div><p>将<code class="language-plaintext highlighter-rouge">lk-&gt;locked</code>置0，这也是一个原子操作。</p><p>由于编译器有时候为了性能优化会重新排列代码的执行顺序，对于顺序执行的代码来说，这种重新排列顺序并不会改变代码执行的结果，但是对于并发执行的代码，则可能改变结果，因此需要在<code class="language-plaintext highlighter-rouge">acquire</code>和<code class="language-plaintext highlighter-rouge">release</code>中用<code class="language-plaintext highlighter-rouge">__sync_synchronize()</code>来保证CPU和编译器不进行重新排列顺序。<code class="language-plaintext highlighter-rouge">__sync_synchronize()</code>是一个barrier，任何在这一行代码之前的代码都不能reorder到这一行代码的后面。</p><h2 id="83-deadlocks-and-lock-ordering">8.3 Deadlocks and lock ordering</h2><p>如果一块代码需要同时拥有多个锁，那么应该让其他需要相同锁的进程按照相同的顺序acquire这些锁，否则可能出现死锁。比如进程1和2都需要锁A和锁B，如果进程1先acquire了锁A，进程2acquire了锁B，那么接下来进程1需要acquire锁B，进程2需要acquire锁A，但是这两个都不能acquire到也无法release各自的锁，就会出现死锁。</p><p>由于<code class="language-plaintext highlighter-rouge">sleep</code>在xv6中的机制，xv6中有很多长度为2的lock-order。比如<code class="language-plaintext highlighter-rouge">consoleintr</code>中要求先获得<code class="language-plaintext highlighter-rouge">cons.lock</code>，当整行输入完毕之后再唤醒等待输入的进程，这需要获得睡眠进程的锁。xv6的文件系统中有一个很长的lock chain，如果要创建一个文件需要同时拥有文件夹的锁、新文件的inode的锁、磁盘块缓冲区的锁、磁盘驱动器的<code class="language-plaintext highlighter-rouge">vdisk_lock</code>的锁以及调用进程的<code class="language-plaintext highlighter-rouge">p-&gt;lock</code>的锁</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210202102133724.png" alt="image-20210202102133724" /></p><p>除了lock ordering之外，锁和中断的交互也可能造成死锁。比如当<code class="language-plaintext highlighter-rouge">sys_sleep</code>拥有<code class="language-plaintext highlighter-rouge">tickslock</code>时，发生定时器中断，定时器中断的handler也需要acquire<code class="language-plaintext highlighter-rouge">tickslock</code>，就会等待<code class="language-plaintext highlighter-rouge">sys_sleep</code>释放，但是因为在中断里面，只要不从中断返回<code class="language-plaintext highlighter-rouge">sys_sleep</code>就永远无法释放，因此造成了死锁。对这种死锁的解决方法是：如果一个中断中需要获取某个特定的spinlock，那么当CPU获得了这个spinlock之后，该中断必须被禁用。xv6的机制则更加保守：当CPU获取了任意一个lock之后，将disable掉这个CPU上的所有中断（其他CPU的中断保持原样）。当CPU不再拥有spinlock时，将通过<code class="language-plaintext highlighter-rouge">pop_off</code>重新使能中断</p><h2 id="84-sleep-locks">8.4 Sleep locks</h2><p>spinlock的两个缺点：1. 如果一个进程拥有一个锁很长时间，另外一个企图acquire的进程将一直等待。2. 当一个进程拥有锁的时候，不允许把当前使用的CPU资源切换给其他线程，否则可能导致第二个线程也acquire这个线程，然后一直无法切回到原来的线程，无法release锁，从而导致死锁。</p><p>xv6提供了一种<em>sleep-locks</em>，可以在试图<code class="language-plaintext highlighter-rouge">acquire</code>一个被拥有的锁时<code class="language-plaintext highlighter-rouge">yield</code> CPU。spin-lock适合短时间的关键步骤，sleep-lock适合长时间的锁。</p><h2 id="85-rcu">8.5 RCU</h2><p>RCU(Read-Copy Update)是一种能让多个读进程对链表进行同时读取，并让一个写进程同时对链表进行写入修改操作的机制，这种机制避免了进程进行读/写操作都需要获取锁而造成的锁竞争问题，适用于大量进程同时对链表结构进行读取的操作。</p><p>基本原理是：写进程在写入某一个链表中的节点时，比如</p><p>head-&gt;E1-&gt;E2-&gt;E3-&gt;nil</p><p>试图修改E2-&gt;content，则不直接修改E2-&gt;content，因为在修改E2-&gt;content的过程中可能会有别的进程在读，此时可能读入写了一半的内容，我们希望一个读进程读取的内容要么是修改之前的，要么是修改之后的，而不是修改一半的内容。读进程的操作是</p><ol><li>lock，防止其他写进程同时进行写入<li>e = alloc()，新分配一个element<li>e-&gt;next = E2-&gt;next，此时同时有2个element指向E3，但是其他读进程在读的时候还是读取的是旧的E2<li>e-&gt;content = new_content<li>E1-&gt;next = E，此时其他读进程在读的时候是新的E2，这是一个原子操作<li>unlock</ol><p>由于编译器有时候为了优化会将2 3 4 5等步骤打乱，因此需要在第5步之前设置memory barrier，即只有在2 3 4均完成的情况下才能执行第5步</p><p>同时需要释放原先的E2，但是由于可能很多读进程已经获取了对原先E2的指针，必须等待这些读进程读取完毕不再使用E2才能将原先的E2释放掉，这是通过以下规则实现的：</p><ol><li>所有的读进程不能够在进行context switch时拥有着对RCU-protected data的指针，也就是说在读进程读完E2之前，不能yield CPU<li>写进程需要等到所有的CPU都进行了一次context switch才能释放掉原先的数据，也就是E2(通过<code class="language-plaintext highlighter-rouge">synchronize_rcu()</code>实现)</ol><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// list reader using RCU interface</span>
<span class="n">rcu_read_lock</span><span class="p">();</span> <span class="c1">// 设置flag防止context switch</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="c1">// 获取对e的指针</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">content</span><span class="p">;</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">rcu_read_unlock</span><span class="p">();</span> <span class="c1">// 可以开始context switch</span>

<span class="c1">// list writer using RCU interface, replacing head</span>
<span class="n">acquire</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>  <span class="c1">// normal spin lock</span>
<span class="n">old</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>     
<span class="n">e</span> <span class="o">=</span> <span class="n">alloc</span><span class="p">();</span>
<span class="n">e</span><span class="o">-&gt;</span><span class="n">content</span> <span class="o">=</span> <span class="n">new_content</span><span class="p">;</span>
<span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span> <span class="c1">// commit the writes</span>
<span class="n">release</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

<span class="n">synchronize_rcu</span><span class="p">();</span> <span class="c1">// wait untill all cpus have context switched, meaning that no reader can hold the pointer to old head</span>
<span class="n">free</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="85-lab-6-copy-on-write-fork">8.5 Lab 6: Copy on write fork</h2><p>实验要求： 实现copy-on-write fork</p><ol><li><p>修改<code class="language-plaintext highlighter-rouge">uvmcopy()</code>，使得父进程在调用该函数时将父进程的物理页映射到子进程的页表，而不是直接给子进程的页表分配新的物理页。要设置<code class="language-plaintext highlighter-rouge">PTE_COW</code>(<code class="language-plaintext highlighter-rouge">1L &gt;&gt; 8</code>)来表明这是一个copy-on-write页，在陷入page fault时需要进行特殊处理。将<code class="language-plaintext highlighter-rouge">PTE_W</code>置零，将该物理页的<code class="language-plaintext highlighter-rouge">refc</code>设置为1.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="kt">int</span>
<span class="nf">uvmcopy</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">old</span><span class="p">,</span> <span class="n">pagetable_t</span> <span class="n">new</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">sz</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">pa</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">flags</span><span class="p">;</span>
<span class="c1">//  char *mem;</span>
   
  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">){</span>
    <span class="k">if</span><span class="p">((</span><span class="n">pte</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">panic</span><span class="p">(</span><span class="s">"uvmcopy: pte should exist"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">panic</span><span class="p">(</span><span class="s">"uvmcopy: page not present"</span><span class="p">);</span>
    <span class="n">pa</span> <span class="o">=</span> <span class="n">PTE2PA</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">PTE_FLAGS</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PTE_W</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">|</span> <span class="n">PTE_COW</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">PTE_W</span><span class="p">);</span>
      <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">PA2PTE</span><span class="p">(</span><span class="n">pa</span><span class="p">)</span> <span class="o">|</span> <span class="n">flags</span><span class="p">;</span>
    <span class="p">}</span> 
    <span class="n">refcinc</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span><span class="p">);</span> <span class="c1">// increase the reference count of the physical page to 1</span>
<span class="c1">//    if((mem = kalloc()) == 0)</span>
<span class="c1">//      goto err;</span>
<span class="c1">//    memmove(mem, (char*)pa, PGSIZE);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">mappages</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
<span class="c1">//      kfree(mem);</span>
      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</pre></table></code></div></div><li><p>在<code class="language-plaintext highlighter-rouge">usertrap()</code>中用<code class="language-plaintext highlighter-rouge">scause() == 13 || scause() == 15</code>来判断是否为page fault，当发现是page fault并且<code class="language-plaintext highlighter-rouge">r_stval()</code>的物理页是COW页时，说明需要分配物理页，并重新映射到这个页表相应的虚拟地址上，当无法分配时，需要kill这个进程。注意：需要判断虚拟地址是否是有效的，其中包括需要判断这个虚拟地址是不是处在stack的guard page上，通过<code class="language-plaintext highlighter-rouge">va &lt;= PGROUNDDOWN(p-&gt;trapframe-&gt;sp) &amp;&amp; va &gt;= PGROUNDDOWN(p-&gt;trapframe-&gt;sp) - PGSIZE</code>进行判断。按道理guard page的PTE应该是设置了PTE_V为0的，但是我尝试判断了这个条件，发现无法通过stacktest，这个问题需要后续确认。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">// in trap.c usertrap()</span>
<span class="err">}</span> <span class="k">else</span> <span class="nf">if</span><span class="p">((</span><span class="n">which_dev</span> <span class="o">=</span> <span class="n">devintr</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
    <span class="c1">// ok</span>
<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">r_scause</span><span class="p">()</span> <span class="o">==</span> <span class="mi">13</span> <span class="o">||</span> <span class="n">r_scause</span><span class="p">()</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uint64</span> <span class="n">va</span> <span class="o">=</span> <span class="n">r_stval</span><span class="p">();</span>
   
    <span class="k">if</span> <span class="p">(</span><span class="n">va</span> <span class="o">&gt;=</span> <span class="n">MAXVA</span> <span class="o">||</span> <span class="p">(</span><span class="n">va</span> <span class="o">&lt;=</span> <span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">va</span> <span class="o">&gt;=</span> <span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">)</span> <span class="o">-</span> <span class="n">PGSIZE</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cow_alloc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">va</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>将为COW物理页分配地址的步骤包装成了函数<code class="language-plaintext highlighter-rouge">cow_alloc()</code>，方便后面<code class="language-plaintext highlighter-rouge">copyout</code>的使用。在将新的物理地址映射给页表之前，需要注意设置PTE_W为1，PTE_COW为0，设置完成之后尝试<code class="language-plaintext highlighter-rouge">kfree</code>掉旧的物理页，从而保证当没有任何进程的页表引用这个物理页的情况下这个物理页被释放掉。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="c1">// allocate a physical address for virtual address va in pagetable</span>
<span class="c1">// for copy on write lab</span>
<span class="kt">int</span> <span class="nf">cow_alloc</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">va</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">uint64</span> <span class="n">pa</span><span class="p">;</span>
  <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">flags</span><span class="p">;</span>
   
  <span class="k">if</span> <span class="p">(</span><span class="n">va</span> <span class="o">&gt;=</span> <span class="n">MAXVA</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> 
  <span class="n">va</span> <span class="o">=</span> <span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
  <span class="n">pte</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pte</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">pa</span> <span class="o">=</span> <span class="n">PTE2PA</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pa</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">flags</span> <span class="o">=</span> <span class="n">PTE_FLAGS</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>
   
  <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PTE_COW</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="n">kalloc</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">memmove</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PTE_COW</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">;</span>
    <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">PA2PTE</span><span class="p">((</span><span class="n">uint64</span><span class="p">)</span><span class="n">mem</span><span class="p">)</span> <span class="o">|</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">kfree</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>为了记录每个物理页被多少进程的页表引用，需要在<code class="language-plaintext highlighter-rouge">kalloc.c</code>中定义一个结构体<code class="language-plaintext highlighter-rouge">refc</code>，其中有一个大小为<code class="language-plaintext highlighter-rouge">PGROUNDUP(PHYSTOP)/PGSIZE</code>的int array来存放每个物理页的引用数。由于这个结构体是被所有的进程共享的，因此需要用一个spinlock进行保护</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// struct to maintain the ref counts</span>
<span class="k">struct</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">lock</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">count</span><span class="p">[</span><span class="n">PGROUNDUP</span><span class="p">(</span><span class="n">PHYSTOP</span><span class="p">)</span> <span class="o">/</span> <span class="n">PGSIZE</span><span class="p">];</span>
<span class="p">}</span> <span class="n">refc</span><span class="p">;</span>
</pre></table></code></div></div><p>初始化这个结构体，初始化这个锁，以及将数组所有元素置0。定义一些增加/减少/获取<code class="language-plaintext highlighter-rouge">refc.count</code>的函数，最后将<code class="language-plaintext highlighter-rouge">refc</code>的初始化函数放在<code class="language-plaintext highlighter-rouge">kinit</code>里</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">refcinit</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">refc</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="s">"refc"</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PGROUNDUP</span><span class="p">(</span><span class="n">PHYSTOP</span><span class="p">)</span> <span class="o">/</span> <span class="n">PGSIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">refc</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
   
<span class="kt">void</span>
<span class="nf">refcinc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pa</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">refc</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">refc</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="n">PA2IDX</span><span class="p">(</span><span class="n">pa</span><span class="p">)]</span><span class="o">++</span><span class="p">;</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">refc</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
   
<span class="kt">void</span>
<span class="nf">refcdec</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pa</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">refc</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">refc</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="n">PA2IDX</span><span class="p">(</span><span class="n">pa</span><span class="p">)]</span><span class="o">--</span><span class="p">;</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">refc</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
   
<span class="kt">int</span>
<span class="nf">getrefc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pa</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">refc</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="n">PA2IDX</span><span class="p">(</span><span class="n">pa</span><span class="p">)];</span>
<span class="p">}</span>
   
<span class="kt">void</span>
<span class="nf">kinit</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">refcinit</span><span class="p">();</span>
  <span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="s">"kmem"</span><span class="p">);</span>
  <span class="n">freerange</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">PHYSTOP</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在进行<code class="language-plaintext highlighter-rouge">kalloc</code>时，将对该物理页的引用加一</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="o">*</span>
<span class="nf">kalloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
   
  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
   
  <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">memset</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">r</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span> <span class="c1">// fill with junk</span>
    <span class="n">refcinc</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">r</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>相应的，在进行<code class="language-plaintext highlighter-rouge">kfree</code>时，要对该物理页的引用减一，然后再判断对该物理页的引用是否已经为0，如果已经为0，则将该物理页push回<code class="language-plaintext highlighter-rouge">freelist</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="c1">// Free the page of physical memory pointed at by v,</span>
<span class="c1">// which normally should have been returned by a</span>
<span class="c1">// call to kalloc().  (The exception is when</span>
<span class="c1">// initializing the allocator; see kinit above.)</span>
<span class="kt">void</span>
<span class="nf">kfree</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pa</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
   
  <span class="k">if</span><span class="p">(((</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span> <span class="o">%</span> <span class="n">PGSIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">||</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span> <span class="o">&gt;=</span> <span class="n">PHYSTOP</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"kfree"</span><span class="p">);</span>
  <span class="n">refcdec</span><span class="p">(</span><span class="n">pa</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">getrefc</span><span class="p">(</span><span class="n">pa</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="c1">// Fill with junk to catch dangling refs.</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
   
  <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">run</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span><span class="p">;</span>
   
  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>
  <span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最后要注意，一开始进行<code class="language-plaintext highlighter-rouge">kinit</code>的时候调用了<code class="language-plaintext highlighter-rouge">freerange(end, (void*)PHYSTOP)</code>，里面对所有物理页都进行了一次<code class="language-plaintext highlighter-rouge">kfree</code>，由于之前没有进行过<code class="language-plaintext highlighter-rouge">kalloc</code>，所以会导致每一页的初始<code class="language-plaintext highlighter-rouge">refc.count</code>都变成-1，因此需要在<code class="language-plaintext highlighter-rouge">kinit</code>时再给每一个物理页的<code class="language-plaintext highlighter-rouge">refc.count</code>加1。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">kinit</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">refcinit</span><span class="p">();</span>
  <span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="s">"kmem"</span><span class="p">);</span>
  <span class="n">freerange</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">PHYSTOP</span><span class="p">);</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
  <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">PGROUNDUP</span><span class="p">((</span><span class="n">uint64</span><span class="p">)</span><span class="n">end</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(;</span> <span class="n">p</span> <span class="o">+</span> <span class="n">PGSIZE</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">PHYSTOP</span><span class="p">;</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">refcinc</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>最后, 由于<code class="language-plaintext highlighter-rouge">copyout</code>函数直接将kernel中的物理地址的内容复制给了用户进程中的物理地址, 没有经过mmu, 也无法进入page fault, 因此当将内容复制到用户进程的虚拟地址时，会将原来的内容覆盖掉而不是进行cow，因此需要修改<code class="language-plaintext highlighter-rouge">copyout</code>，调用<code class="language-plaintext highlighter-rouge">cow_alloc</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// in kernel/vm.c copyput()</span>
<span class="n">uint64</span> <span class="n">n</span><span class="p">,</span> <span class="n">va0</span><span class="p">,</span> <span class="n">pa0</span><span class="p">;</span>
   
<span class="k">while</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
    <span class="n">va0</span> <span class="o">=</span> <span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">dstva</span><span class="p">);</span>
   
    <span class="k">if</span> <span class="p">(</span><span class="n">cow_alloc</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">va0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
   
    <span class="n">pa0</span> <span class="o">=</span> <span class="n">walkaddr</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">va0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pa0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">PGSIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">dstva</span> <span class="o">-</span> <span class="n">va0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">memmove</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">pa0</span> <span class="o">+</span> <span class="p">(</span><span class="n">dstva</span> <span class="o">-</span> <span class="n">va0</span><span class="p">)),</span> <span class="n">src</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</pre></table></code></div></div></ol><h1 id="lecture-9-scheduling">Lecture 9 Scheduling</h1><p>由于操作系统需要同时运行的进程的数量可能大于电脑CPU的数量，因此需要一种让进程time share CPU的机制，理想情况下这种机制对于用户进程应该是<strong>透明</strong>的，即让每个进程都认为自己拥有一个单独的虚拟CPU</p><p>线程：一个串行的指令执行</p><p>xv6的kernel thread支持共享内存，user process不支持</p><h2 id="91-multiplexing">9.1 Multiplexing</h2><p>xv6在2种情况下在进程之间切换从而实现multiplexing。1. <code class="language-plaintext highlighter-rouge">sleep</code>/<code class="language-plaintext highlighter-rouge">wakeup</code>机制：进程等待设备或I/O、等待子进程退出、在<code class="language-plaintext highlighter-rouge">sleep</code>sys call中等待 2. 周期性强迫一个进程进行切换，防止一个进程占用过长时间。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210203212120616.png" alt="image-20210203212120616" /></p><h2 id="92-context-switching">9.2 Context Switching</h2><p>进程的上下文切换涉及到用户空间和内核空间之间的来回转换。当进程需要切换时，首先通过system call或中断陷入内核态，进入该进程的内核线程，然后将<strong>内核线程</strong>的上下文（注意不是用户进程的上下文，用户进程的上下文已经保存在了trapframe里面）切换到当前CPU的scheduler线程，再将上下文切换到需要运行的进程的内核线程，最后返回用户空间。</p><p>从一个内核线程切换到另一个线程需要保存旧线程的寄存器，恢复新线程之前保存的寄存器。<code class="language-plaintext highlighter-rouge">sp</code>和<code class="language-plaintext highlighter-rouge">pc</code>将在此过程中被保存和切换。<code class="language-plaintext highlighter-rouge">swtch</code>可以实现这种寄存器组状态(也叫上下文)的保存和切换。当进程需要<code class="language-plaintext highlighter-rouge">yield</code>CPU时，这个进程的内核线程将调用<code class="language-plaintext highlighter-rouge">swtch</code>来保存上下文并切换到scheduler的上下文，所有的上下文都保存在<code class="language-plaintext highlighter-rouge">struct context</code>中。<code class="language-plaintext highlighter-rouge">swtch</code>的传入参数为<code class="language-plaintext highlighter-rouge">struct context *old</code>和<code class="language-plaintext highlighter-rouge">struct context *new</code></p><p><code class="language-plaintext highlighter-rouge">yield()</code>函数切换了进程的状态为RUNNABLE，调用了<code class="language-plaintext highlighter-rouge">sched()</code>。<code class="language-plaintext highlighter-rouge">sched</code>调用了<code class="language-plaintext highlighter-rouge">swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context)</code>来将上下文切换到<code class="language-plaintext highlighter-rouge">cpu-&gt;scheduler</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="n">sched</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">intena</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>

  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">holding</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"sched p-&gt;lock"</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">mycpu</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">noff</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"sched locks"</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">RUNNING</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"sched running"</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">intr_get</span><span class="p">())</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"sched interruptible"</span><span class="p">);</span>

  <span class="n">intena</span> <span class="o">=</span> <span class="n">mycpu</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">intena</span><span class="p">;</span>
  <span class="n">swtch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mycpu</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
  <span class="n">mycpu</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">intena</span> <span class="o">=</span> <span class="n">intena</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">sched()</code>中，先要检查是否还获取着<code class="language-plaintext highlighter-rouge">p-&gt;lock</code>，防止其他CPU的scheduler看见<code class="language-plaintext highlighter-rouge">p-&gt;state==RUNNABLE</code>的情况下试图去运行这个进程。通过检查<code class="language-plaintext highlighter-rouge">mycpu()-&gt;noff</code>来检查是否还获取着除了<code class="language-plaintext highlighter-rouge">p-&gt;lock</code>之外的其他锁，否则当切换到其他进程之后其他进程可能会<code class="language-plaintext highlighter-rouge">acquire</code>这个锁，而原先的进程由于没有在运行，因此一直无法释放掉这个锁，造成死锁。</p><p><code class="language-plaintext highlighter-rouge">swtch</code>只保存callee saved寄存器，caller saved寄存器在栈中被调用的代码保存。<code class="language-plaintext highlighter-rouge">swtch</code>并没有保存<code class="language-plaintext highlighter-rouge">pc</code>寄存器，而是保存了<code class="language-plaintext highlighter-rouge">ra</code>，当恢复了新的进程之前保存的<code class="language-plaintext highlighter-rouge">ra</code>寄存器后，将返回到<code class="language-plaintext highlighter-rouge">ra</code>寄存器指向的上一个进程调用<code class="language-plaintext highlighter-rouge">swtch</code>的代码。如果保存<code class="language-plaintext highlighter-rouge">pc</code>寄存器，将只能回到<code class="language-plaintext highlighter-rouge">swtch</code>本身。由于切换到的<code class="language-plaintext highlighter-rouge">&amp;mycpu()-&gt;context</code>是被<code class="language-plaintext highlighter-rouge">scheduler</code>对<code class="language-plaintext highlighter-rouge">swtch</code>的调用所保存的，因此当进行<code class="language-plaintext highlighter-rouge">swtch</code>时，我们将返回到<code class="language-plaintext highlighter-rouge">scheduler</code>，栈指针也将指向当前CPU的scheduler stack。</p><h2 id="93-scheduling">9.3 Scheduling</h2><p>调度器(scheduler)是每个CPU中都会运行的一个特殊的线程，这个线程中不断运行<code class="language-plaintext highlighter-rouge">scheduler</code>函数，来选取下一个需要运行的进程。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="c1">// Per-CPU process scheduler.</span>
<span class="c1">// Each CPU calls scheduler() after setting itself up.</span>
<span class="c1">// Scheduler never returns.  It loops, doing:</span>
<span class="c1">//  - choose a process to run.</span>
<span class="c1">//  - swtch to start running that process.</span>
<span class="c1">//  - eventually that process transfers control</span>
<span class="c1">//    via swtch back to the scheduler.</span>
<span class="kt">void</span>
<span class="nf">scheduler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">cpu</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">mycpu</span><span class="p">();</span>
  
  <span class="n">c</span><span class="o">-&gt;</span><span class="n">proc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(;;){</span>
    <span class="c1">// Avoid deadlock by ensuring that devices can interrupt.</span>
    <span class="n">intr_on</span><span class="p">();</span>
    
    <span class="kt">int</span> <span class="n">nproc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">UNUSED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nproc</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">RUNNABLE</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Switch to chosen process.  It is the process's job</span>
        <span class="c1">// to release its lock and then reacquire it</span>
        <span class="c1">// before jumping back to us.</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RUNNING</span><span class="p">;</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">proc</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">swtch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>

        <span class="c1">// Process is done running for now.</span>
        <span class="c1">// It should have changed its p-&gt;state before coming back.</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">proc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">nproc</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// only init and sh exist</span>
      <span class="n">intr_on</span><span class="p">();</span>
      <span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">"wfi"</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>想要<code class="language-plaintext highlighter-rouge">yield</code>CPU的进程首先要获取自己进程的锁<code class="language-plaintext highlighter-rouge">p-&gt;lock</code>（防止其他CPU获取这个进程），修改当前的状态到<code class="language-plaintext highlighter-rouge">RUNNABLE</code>，<code class="language-plaintext highlighter-rouge">release</code>掉自己获取的其他锁，加载<code class="language-plaintext highlighter-rouge">cpu-&gt;scheduler</code>的上下文，返回到<code class="language-plaintext highlighter-rouge">scheduler()</code>之后，<code class="language-plaintext highlighter-rouge">release</code>掉自己的进程锁。</p><p>在<code class="language-plaintext highlighter-rouge">scheduler</code>调用<code class="language-plaintext highlighter-rouge">swtch</code>到新的进程之前，<code class="language-plaintext highlighter-rouge">scheduler</code>需要已经获取这个进程的锁，并且将对这个进程的锁传递给被切换到的这个新的进程中，让新进程来<code class="language-plaintext highlighter-rouge">release</code>这个锁。一般来说，一个锁应该由<code class="language-plaintext highlighter-rouge">acquire</code>它的进程来进行<code class="language-plaintext highlighter-rouge">release</code>，但是由于一个进程的<code class="language-plaintext highlighter-rouge">p-&gt;state</code>是在<code class="language-plaintext highlighter-rouge">scheduler</code>中被改变的，需要对其进行保护，因此需要在<code class="language-plaintext highlighter-rouge">scheduler</code>中就获取这个进程的锁</p><p>当一个新的进程是第一次被<code class="language-plaintext highlighter-rouge">scheduler</code>调度的时候，不返回到<code class="language-plaintext highlighter-rouge">sched</code>，而是返回到<code class="language-plaintext highlighter-rouge">forkret</code>（因为之前并没有从<code class="language-plaintext highlighter-rouge">sched</code>中调用过<code class="language-plaintext highlighter-rouge">swtch</code>）。<code class="language-plaintext highlighter-rouge">forkret</code>将<code class="language-plaintext highlighter-rouge">p-&gt;lock</code>释放掉，然后回到<code class="language-plaintext highlighter-rouge">usertrapret</code>。</p><p>## 9.4 mycpu and myproc</p><p>xv6为每一个CPU都有一个<code class="language-plaintext highlighter-rouge">struct cpu</code>，记录当前运行在这个CPU上的进程的指针<code class="language-plaintext highlighter-rouge">struct proc *proc</code>、保存的寄存器<code class="language-plaintext highlighter-rouge">struct context context</code>、<code class="language-plaintext highlighter-rouge">push_off</code>的nesting的数量<code class="language-plaintext highlighter-rouge">int noff</code>等变量。</p><p>RISC-V将所有CPU进行编号，该编号称为<em>hartid</em>，确保每个CPU的hartid都保存在这个CPU的<code class="language-plaintext highlighter-rouge">tp</code>寄存器内，可以让<code class="language-plaintext highlighter-rouge">mycpu</code>通过这个hartid来索引到一个<code class="language-plaintext highlighter-rouge">struct cpu</code>数组<code class="language-plaintext highlighter-rouge">cpus[]</code>中，从而获取对当前CPU的<code class="language-plaintext highlighter-rouge">struct cpu</code>的引用。当获取<code class="language-plaintext highlighter-rouge">struct cpu</code>之后如果发生了中断导致CPU被切换了，那么获取的<code class="language-plaintext highlighter-rouge">struct cpu</code>将是不正确的，因此需要用<code class="language-plaintext highlighter-rouge">push_off</code>来保证当前的中断使能被关闭。</p><p>使用<code class="language-plaintext highlighter-rouge">myproc()</code>函数来返回一个指向当前CPU运行的进程<code class="language-plaintext highlighter-rouge">c-&gt;proc</code>的指针。</p><h2 id="95-lab-7-thread">9.5 Lab 7: thread</h2><ol><li><p>Uthread</p><p>实验要求: 实现一个用户层面的线程系统,需要实现<code class="language-plaintext highlighter-rouge">thread_create()</code> <code class="language-plaintext highlighter-rouge">thread_schedule()</code>以及<code class="language-plaintext highlighter-rouge">uthread_switch.S</code></p><p>在<code class="language-plaintext highlighter-rouge">uthread_switch.S</code>中,仿照<code class="language-plaintext highlighter-rouge">swtch.S</code>进行上下文寄存器的保存和切换</p><pre><code class="language-assembly">thread_switch:
	/* YOUR CODE HERE */
        sd ra, 0(a0)
        sd sp, 8(a0)
        sd s0, 16(a0)
        sd s1, 24(a0)
        sd s2, 32(a0)
        sd s3, 40(a0)
        sd s4, 48(a0)
        sd s5, 56(a0)
        sd s6, 64(a0)
        sd s7, 72(a0)
        sd s8, 80(a0)
        sd s9, 88(a0)
        sd s10, 96(a0)
        sd s11, 104(a0)
   
        ld ra, 0(a1)
        ld sp, 8(a1)
        ld s0, 16(a1)
        ld s1, 24(a1)
        ld s2, 32(a1)
        ld s3, 40(a1)
        ld s4, 48(a1)
        ld s5, 56(a1)
        ld s6, 64(a1)
        ld s7, 72(a1)
        ld s8, 80(a1)
        ld s9, 88(a1)
        ld s10, 96(a1)
        ld s11, 104(a1)
		ret    /* return to ra */
</code></pre><p>在<code class="language-plaintext highlighter-rouge">uthread.c</code>的<code class="language-plaintext highlighter-rouge">thread_create()</code>中,第一次创建进程时需要初始化<code class="language-plaintext highlighter-rouge">ra</code>和<code class="language-plaintext highlighter-rouge">sp</code>寄存器. <code class="language-plaintext highlighter-rouge">ra</code>寄存器需要存放传入的函数地址, <code class="language-plaintext highlighter-rouge">sp</code>寄存器传入当前线程的栈底(最开始的位置)</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kt">void</span> 
<span class="nf">thread_create</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)())</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
   
  <span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">all_thread</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">all_thread</span> <span class="o">+</span> <span class="n">MAX_THREAD</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FREE</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
  <span class="n">t</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RUNNABLE</span><span class="p">;</span>
  <span class="c1">// YOUR CODE HERE</span>
  <span class="n">t</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">ra</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">func</span><span class="p">;</span>
  <span class="n">t</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">stack</span> <span class="o">+</span> <span class="n">STACK_SIZE</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">thread_schedule()</code>中,直接调用<code class="language-plaintext highlighter-rouge">thread_switch</code>,仿照<code class="language-plaintext highlighter-rouge">swtch</code>的格式进行上下文切换</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    <span class="cm">/* YOUR CODE HERE
     * Invoke thread_switch to switch from t to next_thread:
     * thread_switch(??, ??);
     */</span>
    <span class="n">thread_switch</span><span class="p">((</span><span class="n">uint64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">current_thread</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
</pre></table></code></div></div><li><p>Using threads</p><p>实验要求: 这个实验是基于实际的UNIX<code class="language-plaintext highlighter-rouge">pthread</code>库进行的,而非基于xv6. 需要对<code class="language-plaintext highlighter-rouge">notxv6/ph.c</code>进行补充,以实现多线程情况下能够正确地向一个哈希表插入键值对,其核心思想就是给每个线程对哈希表的操作都加锁.</p><p>定义一个全局变量<code class="language-plaintext highlighter-rouge">pthread_mutex_t lock[NBUCKET];</code> 其中<code class="language-plaintext highlighter-rouge">NBUCKET</code>是同时可以进行操作的线程最大数量</p><p>在<code class="language-plaintext highlighter-rouge">main</code>中对这个锁数列进行初始化</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">NBUCKET</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">put()</code>和<code class="language-plaintext highlighter-rouge">get()</code>函数中上锁和解锁以保护对哈希表键值对的读写操作.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">static</span> 
<span class="kt">void</span> <span class="nf">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">key</span> <span class="o">%</span> <span class="n">NBUCKET</span><span class="p">;</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="c1">// is the key already present?</span>
  <span class="k">struct</span> <span class="n">entry</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">e</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">e</span><span class="p">){</span>
    <span class="c1">// update the existing key.</span>
    <span class="n">e</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// the new is new.</span>
    <span class="n">insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="k">struct</span> <span class="n">entry</span><span class="o">*</span>
<span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">key</span> <span class="o">%</span> <span class="n">NBUCKET</span><span class="p">;</span>
   
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="k">struct</span> <span class="n">entry</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">e</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="k">return</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>Barrier</p><p>实验要求: 实现线程的同步,即每一个线程必须等待其他所有线程都到达barrier之后才能继续进行下面的操作,需要用到<code class="language-plaintext highlighter-rouge">pthread_cond_wait(&amp;cond, &amp;mutex)</code>和<code class="language-plaintext highlighter-rouge">pthread_cond_broadcast(&amp;cond)</code>来进行线程的sleep和唤醒其他所有<code class="language-plaintext highlighter-rouge">&amp;cond</code>中睡眠的线程. 需要对<code class="language-plaintext highlighter-rouge">barrier.c</code>中的<code class="language-plaintext highlighter-rouge">barrier()</code>进行实现.</p><p>当每个线程调用了<code class="language-plaintext highlighter-rouge">barrier()</code>之后,需要增加<code class="language-plaintext highlighter-rouge">bstate.nthread</code>以表明到达当前round的线程数量增加了1, 但是由于<code class="language-plaintext highlighter-rouge">bstate</code>这个数据结构是线程之间共享的, 因此需要用<code class="language-plaintext highlighter-rouge">pthread_mutex_lock</code>对这个数据结构进行保护. 当<code class="language-plaintext highlighter-rouge">bstate.nthread</code>的数量达到线程总数<code class="language-plaintext highlighter-rouge">nthread</code>之后, 将<code class="language-plaintext highlighter-rouge">bstate.round</code>加1. 注意, 一定要等到所有的线程都达到了这个round, 将<code class="language-plaintext highlighter-rouge">bstate.nthread</code>清零之后才能将所有正在睡眠的线程唤醒, 否则如果先唤醒线程的话其他线程如果跑得很快, 在之前的线程将<code class="language-plaintext highlighter-rouge">bstate.nthread</code>清零之前就调用了<code class="language-plaintext highlighter-rouge">bstate.nthread++</code>,会出现问题(round之间是共用<code class="language-plaintext highlighter-rouge">bstate.nthread</code>的)</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span> 
<span class="nf">barrier</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// YOUR CODE HERE</span>
  <span class="c1">//</span>
  <span class="c1">// Block until all threads have called barrier() and</span>
  <span class="c1">// then increment bstate.round.</span>
  <span class="c1">//</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bstate</span><span class="p">.</span><span class="n">barrier_mutex</span><span class="p">);</span>
  <span class="n">bstate</span><span class="p">.</span><span class="n">nthread</span><span class="o">++</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bstate</span><span class="p">.</span><span class="n">nthread</span> <span class="o">==</span> <span class="n">nthread</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bstate</span><span class="p">.</span><span class="n">round</span><span class="o">++</span><span class="p">;</span>
    <span class="n">bstate</span><span class="p">.</span><span class="n">nthread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bstate</span><span class="p">.</span><span class="n">barrier_cond</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bstate</span><span class="p">.</span><span class="n">barrier_mutex</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bstate</span><span class="p">.</span><span class="n">barrier_cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bstate</span><span class="p">.</span><span class="n">barrier_mutex</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bstate</span><span class="p">.</span><span class="n">barrier_mutex</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div></ol><h1 id="lecture-10-sleep--wakeup">Lecture 10 Sleep &amp; Wakeup</h1><h2 id="101-sleep-and-wakeup">10.1 Sleep and wakeup</h2><p>sleep是当一个进程在等待某一个事件时陷入休眠状态，当这个事件发生时另外一个进程唤醒它。陷入休眠状态可以让这个进程不在等待的时候占用CPU资源</p><p><code class="language-plaintext highlighter-rouge">sleep(chan)</code>让这个进程睡眠在<code class="language-plaintext highlighter-rouge">chan</code>这个<em>wait channel</em>上，<code class="language-plaintext highlighter-rouge">wakeup(chan)</code>将所有睡眠在<code class="language-plaintext highlighter-rouge">chan</code>上的进程全部唤醒。</p><p><em>lost wake-up problem</em>：当一个进程A即将睡眠时，另外一个进程B发现已经满足了唤醒它的条件进行了唤醒，但是这时还没有进程睡眠在<code class="language-plaintext highlighter-rouge">chan</code>上，当进程A开始进入睡眠后，进程B可能不会再对进程A进行唤醒，进程A永远进入睡眠状态</p><p>对<em>lost wake-up problem</em>的解决方法：用<em>condition lock</em>对<code class="language-plaintext highlighter-rouge">sleep</code>和<code class="language-plaintext highlighter-rouge">wakeup</code>前后进行保护， 比如</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">V</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wakeup</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">P</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sleep</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>但是由于<code class="language-plaintext highlighter-rouge">sleep</code>时这个进程还拿着<code class="language-plaintext highlighter-rouge">s-&gt;lock</code>，<code class="language-plaintext highlighter-rouge">V</code>永远也无法将<code class="language-plaintext highlighter-rouge">P</code>唤醒，因此会导致死锁。所以需要修改<code class="language-plaintext highlighter-rouge">sleep</code>，让<code class="language-plaintext highlighter-rouge">sleep</code>获取<code class="language-plaintext highlighter-rouge">&amp;s-&gt;lock</code>这个参数，在<code class="language-plaintext highlighter-rouge">sleep</code>中将<code class="language-plaintext highlighter-rouge">p-&gt;state</code>设置为asleep之后将这个锁<code class="language-plaintext highlighter-rouge">release</code>掉，在从<code class="language-plaintext highlighter-rouge">sleep</code>中唤醒时，重新获取<code class="language-plaintext highlighter-rouge">s-&gt;lock</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">sleep</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="102-code-sleep-and-wakeup">10.2 Code: Sleep and wakeup</h2><p><code class="language-plaintext highlighter-rouge">kernel/proc.c</code>中的<code class="language-plaintext highlighter-rouge">sleep()</code>函数</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">sleep</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spinlock</span> <span class="o">*</span><span class="n">lk</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>
  
  <span class="c1">// Must acquire p-&gt;lock in order to</span>
  <span class="c1">// change p-&gt;state and then call sched.</span>
  <span class="c1">// Once we hold p-&gt;lock, we can be</span>
  <span class="c1">// guaranteed that we won't miss any wakeup</span>
  <span class="c1">// (wakeup locks p-&gt;lock),</span>
  <span class="c1">// so it's okay to release lk.</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>  <span class="c1">//DOC: sleeplock1</span>
  <span class="n">release</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>

  <span class="c1">// Go to sleep.</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">chan</span> <span class="o">=</span> <span class="n">chan</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SLEEPING</span><span class="p">;</span>

  <span class="n">sched</span><span class="p">();</span>

  <span class="c1">// Tidy up.</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">chan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Reacquire original lock.</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">acquire</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">sleep</code>中，首先需要获取一个进程锁来修改这个进程的<code class="language-plaintext highlighter-rouge">p-&gt;chan</code>和<code class="language-plaintext highlighter-rouge">p-&gt;state</code>。当获取了这个进程锁之后可以立刻释放掉<code class="language-plaintext highlighter-rouge">lk</code>，因为在<code class="language-plaintext highlighter-rouge">wakeup</code>中只有先获取了<code class="language-plaintext highlighter-rouge">sleep</code>进程的进程锁才能进行尝试唤醒(判断<code class="language-plaintext highlighter-rouge">p-&gt;state==SLEEPING</code>)，因此可以保证在<code class="language-plaintext highlighter-rouge">sleep</code>中将<code class="language-plaintext highlighter-rouge">p-&gt;state</code>修改为<code class="language-plaintext highlighter-rouge">SLEEPING</code>之前是无法进行唤醒的.</p><p>注意：当<code class="language-plaintext highlighter-rouge">lk</code>本身就是<code class="language-plaintext highlighter-rouge">p-&gt;lock</code>时会出现死锁的问题。</p><p><code class="language-plaintext highlighter-rouge">kernel/proc.c</code>中的<code class="language-plaintext highlighter-rouge">wakeup()</code>函数</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// Wake up all processes sleeping on chan.</span>
<span class="c1">// Must be called without any p-&gt;lock.</span>
<span class="kt">void</span>
<span class="nf">wakeup</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">myproc</span><span class="p">()){</span>
      <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SLEEPING</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">chan</span> <span class="o">==</span> <span class="n">chan</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RUNNABLE</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>唤醒进程遍历所有的进程，先获取每个进程的进程锁，然后判断每个进程是否睡眠在<code class="language-plaintext highlighter-rouge">chan</code>上，如果是则将其状态改为<code class="language-plaintext highlighter-rouge">RUNNABLE</code>，最后释放进程锁。</p><h2 id="103-code-pipes">10.3 Code: Pipes</h2><p>每一个<code class="language-plaintext highlighter-rouge">pipe</code>都有一个<code class="language-plaintext highlighter-rouge">struct pipe</code>，包括了一个<code class="language-plaintext highlighter-rouge">lock</code>和一个<code class="language-plaintext highlighter-rouge">data</code>缓冲数组</p><p><code class="language-plaintext highlighter-rouge">kernel/pipe.c</code>中的<code class="language-plaintext highlighter-rouge">pipewrite()</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kt">int</span>
<span class="nf">pipewrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe</span> <span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">pr</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
  <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">readopen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pr</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">){</span>
      <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span> <span class="o">==</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span> <span class="o">+</span> <span class="n">PIPESIZE</span><span class="p">){</span> <span class="c1">//DOC: pipewrite-full</span>
      <span class="n">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="p">);</span>
      <span class="n">sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="n">copyin</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="n">pi</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span><span class="o">++</span> <span class="o">%</span> <span class="n">PIPESIZE</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
      <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="p">);</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>先获取<code class="language-plaintext highlighter-rouge">pipe</code>的锁，因为要对<code class="language-plaintext highlighter-rouge">pi</code>结构体里的变量进行修改。通过<code class="language-plaintext highlighter-rouge">pi-&gt;nwrite == pi-&gt;nread+PIPESIZE</code>判断缓冲区是否已经满了，如果已经满了就唤醒睡在<code class="language-plaintext highlighter-rouge">&amp;pi-&gt;nread</code>上的<code class="language-plaintext highlighter-rouge">piperead</code>进程对缓冲区进行读取，自己睡在<code class="language-plaintext highlighter-rouge">&amp;pi-&gt;nwrite</code>等待唤醒，否则就从user space的<code class="language-plaintext highlighter-rouge">addr</code>中<code class="language-plaintext highlighter-rouge">copyin</code>到内核态中的<code class="language-plaintext highlighter-rouge">pi</code>缓冲区内，完成n字节的读取之后将<code class="language-plaintext highlighter-rouge">piperead</code>进程唤醒，释放<code class="language-plaintext highlighter-rouge">&amp;pi-&gt;lock</code>。</p><p><code class="language-plaintext highlighter-rouge">piperead</code>的代码</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kt">int</span>
<span class="nf">piperead</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe</span> <span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">pr</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>
  <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
  <span class="k">while</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span> <span class="o">==</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span> <span class="o">&amp;&amp;</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">writeopen</span><span class="p">){</span>  <span class="c1">//DOC: pipe-empty</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">){</span>
      <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span> <span class="c1">//DOC: piperead-sleep</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>  <span class="c1">//DOC: piperead-copy</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span> <span class="o">==</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="o">++</span> <span class="o">%</span> <span class="n">PIPESIZE</span><span class="p">];</span>
    <span class="k">if</span><span class="p">(</span><span class="n">copyout</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span><span class="p">);</span>  <span class="c1">//DOC: piperead-wakeup</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>也要先获取<code class="language-plaintext highlighter-rouge">pi-&gt;lock</code>，判断当前缓冲区内是不是空的，如果是空的就进入睡眠，等待<code class="language-plaintext highlighter-rouge">pipewrite</code>进行写入并唤醒，否则循环读取n字节缓冲区数据，将缓冲区的数据<code class="language-plaintext highlighter-rouge">copyout</code>到用户空间的<code class="language-plaintext highlighter-rouge">addr</code>地址中，待n字节数据全部读取完成之后将<code class="language-plaintext highlighter-rouge">pipewrite</code>唤醒。</p><h2 id="104-code-wait-exit-and-kill">10.4 Code: Wait, exit, and kill</h2><p><code class="language-plaintext highlighter-rouge">kernel/proc.c</code>中的<code class="language-plaintext highlighter-rouge">wait()</code>代码</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="c1">// Wait for a child process to exit and return its pid.</span>
<span class="c1">// Return -1 if this process has no children.</span>
<span class="kt">int</span>
<span class="nf">wait</span><span class="p">(</span><span class="n">uint64</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">havekids</span><span class="p">,</span> <span class="n">pid</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait_lock</span><span class="p">);</span>

  <span class="k">for</span><span class="p">(;;){</span>
    <span class="c1">// Scan through table looking for exited children.</span>
    <span class="n">havekids</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">np</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span> <span class="n">np</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span> <span class="n">np</span><span class="o">++</span><span class="p">){</span>
      <span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="n">p</span><span class="p">){</span>
        <span class="c1">// make sure the child isn't still in exit() or swtch().</span>
        <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

        <span class="n">havekids</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ZOMBIE</span><span class="p">){</span>
          <span class="c1">// Found one.</span>
          <span class="n">pid</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
          <span class="k">if</span><span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">copyout</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">xstate</span><span class="p">,</span>
                                  <span class="k">sizeof</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">xstate</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
            <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait_lock</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">freeproc</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
          <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
          <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait_lock</span><span class="p">);</span>
          <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// No point waiting if we don't have any children.</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">havekids</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">){</span>
      <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait_lock</span><span class="p">);</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Wait for a child to exit.</span>
    <span class="n">sleep</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait_lock</span><span class="p">);</span>  <span class="c1">//DOC: wait-sleep</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">wait</code>中是一个无限循环，每个循环中先对所有的进程循环查找自己的子进程，当发现有子进程并且子进程的状态为<code class="language-plaintext highlighter-rouge">ZOMBIE</code>时，将子进程的退出状态<code class="language-plaintext highlighter-rouge">np-&gt;xstate</code> <code class="language-plaintext highlighter-rouge">copyout</code>到<code class="language-plaintext highlighter-rouge">wait</code>传入的用户空间的<code class="language-plaintext highlighter-rouge">addr</code>中，然后释放掉子进程占用的所有的内存空间，返回子进程的pid。如果没有发现任何<code class="language-plaintext highlighter-rouge">ZOMBIE</code>子进程，睡眠在<code class="language-plaintext highlighter-rouge">p</code>上以等待子进程<code class="language-plaintext highlighter-rouge">exit</code>时唤醒<code class="language-plaintext highlighter-rouge">p</code>。<code class="language-plaintext highlighter-rouge">wait_lock</code>是<code class="language-plaintext highlighter-rouge">wait</code>和<code class="language-plaintext highlighter-rouge">exit</code>的condition lock用来防止错过wakeup。<code class="language-plaintext highlighter-rouge">wait_lock</code>实际上就是<code class="language-plaintext highlighter-rouge">wait()</code>调用者的<code class="language-plaintext highlighter-rouge">p-&gt;lock</code></p><p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">wait()</code>先要获取调用进程的<code class="language-plaintext highlighter-rouge">p-&gt;lock</code>作为<code class="language-plaintext highlighter-rouge">sleep</code>的condition lock，然后在发现<code class="language-plaintext highlighter-rouge">ZOMBIE</code>子进程后获取子进程的<code class="language-plaintext highlighter-rouge">np-&gt;lock</code>，因此xv6中必须遵守先获取父进程的锁才能获取子进程的锁这一个规则。因此在循环查找<code class="language-plaintext highlighter-rouge">np-&gt;parent == p</code>时，不能先获取<code class="language-plaintext highlighter-rouge">np-&gt;lock</code>，因为<code class="language-plaintext highlighter-rouge">np</code>很有可能是自己的父进程，这样就违背了先获取父进程锁再获取子进程锁这个规则，可能造成死锁。</p><p><code class="language-plaintext highlighter-rouge">exit()</code>代码</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="c1">// Exit the current process.  Does not return.</span>
<span class="c1">// An exited process remains in the zombie state</span>
<span class="c1">// until its parent calls wait().</span>
<span class="kt">void</span>
<span class="nf">exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>

  <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">initproc</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"init exiting"</span><span class="p">);</span>

  <span class="c1">// Close all open files.</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fd</span> <span class="o">&lt;</span> <span class="n">NOFILE</span><span class="p">;</span> <span class="n">fd</span><span class="o">++</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">fd</span><span class="p">]){</span>
      <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">fd</span><span class="p">];</span>
      <span class="n">fileclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
      <span class="n">p</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">begin_op</span><span class="p">();</span>
  <span class="n">iput</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cwd</span><span class="p">);</span>
  <span class="n">end_op</span><span class="p">();</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">cwd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait_lock</span><span class="p">);</span>

  <span class="c1">// Give any children to init.</span>
  <span class="n">reparent</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

  <span class="c1">// Parent might be sleeping in wait().</span>
  <span class="n">wakeup</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
  
  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

  <span class="n">p</span><span class="o">-&gt;</span><span class="n">xstate</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ZOMBIE</span><span class="p">;</span>

  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait_lock</span><span class="p">);</span>

  <span class="c1">// Jump into the scheduler, never to return.</span>
  <span class="n">sched</span><span class="p">();</span>
  <span class="n">panic</span><span class="p">(</span><span class="s">"zombie exit"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">exit</code>关闭所有打开的文件，将自己的子进程reparent给<code class="language-plaintext highlighter-rouge">init</code>进程，因为<code class="language-plaintext highlighter-rouge">init</code>进程永远在调用<code class="language-plaintext highlighter-rouge">wait</code>，这样就可以让自己的子进程在<code class="language-plaintext highlighter-rouge">exit</code>后由<code class="language-plaintext highlighter-rouge">init</code>进行<code class="language-plaintext highlighter-rouge">freeproc</code>等后续的操作。然后获取进程锁，设置退出状态和当前状态为<code class="language-plaintext highlighter-rouge">ZOMBIE</code>，进入<code class="language-plaintext highlighter-rouge">scheduler</code>中并且不再返回。</p><p>注意：在将<code class="language-plaintext highlighter-rouge">p-&gt;state</code>设置为<code class="language-plaintext highlighter-rouge">ZOMBIE</code>之后才能释放掉<code class="language-plaintext highlighter-rouge">wait_lock</code>，否则<code class="language-plaintext highlighter-rouge">wait()</code>的进程被唤醒之后发现了<code class="language-plaintext highlighter-rouge">ZOMBIE</code>进程之后直接将其释放，此时<code class="language-plaintext highlighter-rouge">ZOMBIE</code>进程还没运行完毕。</p><p><code class="language-plaintext highlighter-rouge">exit</code>是让自己的程序进行退出，<code class="language-plaintext highlighter-rouge">kill</code>是让一个程序强制要求另一个程序退出。<code class="language-plaintext highlighter-rouge">kill</code>不能立刻终结另一个进程，因为另一个进程可能在执行敏感命令，因此<code class="language-plaintext highlighter-rouge">kill</code>仅仅设置了<code class="language-plaintext highlighter-rouge">p-&gt;killed</code>为1，且如果该进程在睡眠状态则将其唤醒。当被<code class="language-plaintext highlighter-rouge">kill</code>的进程进入<code class="language-plaintext highlighter-rouge">usertrap</code>之后，将会查看<code class="language-plaintext highlighter-rouge">p-&gt;killed</code>是否为1，如果为1则将调用<code class="language-plaintext highlighter-rouge">exit</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="c1">// Kill the process with the given pid.</span>
<span class="c1">// The victim won't exit until it tries to return</span>
<span class="c1">// to user space (see usertrap() in trap.c).</span>
<span class="kt">int</span>
<span class="nf">kill</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span> <span class="n">p</span><span class="o">++</span><span class="p">){</span>
    <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">==</span> <span class="n">pid</span><span class="p">){</span>
      <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SLEEPING</span><span class="p">){</span>
        <span class="c1">// Wake process from sleep().</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RUNNABLE</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="105-real-world">10.5 Real world</h2><p>xv6采用的scheduling的方式为<em>round robin</em>，即每个进程轮流运行，实际的操作系统的scheduling可以让进程有优先级。当高优先级和低优先级共享一个锁而低优先级拿到这个锁的情况下，将产生<em>priority inversion</em>，将导致大量高优先级进程等候低优先级进程，从而形成<em>convoy</em>。</p><p>对整个进程列表查找睡眠在<code class="language-plaintext highlighter-rouge">chan</code>上的进程是非常低效的，更好的解决方案是将<code class="language-plaintext highlighter-rouge">chan</code>替代为一个可以存储睡眠在此结构体上的进程列表的结构体，比如Linux的<em>wait queue</em></p><p>xv6中的<code class="language-plaintext highlighter-rouge">wakeup</code>唤醒所有睡在<code class="language-plaintext highlighter-rouge">chan</code>上的进程，然后这些进程将竞争检查sleep conditoin，这种情况通常需要被避免。许多是采用<code class="language-plaintext highlighter-rouge">signal</code>和<code class="language-plaintext highlighter-rouge">broadcast</code>两种唤醒模式，前面一种只唤醒一个进程，后面一种唤醒所有进程。</p><h2 id="106-lab-8-locks">10.6 Lab 8: Locks</h2><ol><li><p>Memory allocator</p><p>实验要求：实现一个per CPU freelist，以减小各个进程同时调用<code class="language-plaintext highlighter-rouge">kalloc</code>、<code class="language-plaintext highlighter-rouge">kfree</code>造成的对<code class="language-plaintext highlighter-rouge">kmem.lock</code>锁的竞争。可以调用<code class="language-plaintext highlighter-rouge">cpuid()</code>函数来获取当前进程运行的CPU ID，但是要在调用前加上<code class="language-plaintext highlighter-rouge">push_off</code>以关闭中断。</p><p>在<code class="language-plaintext highlighter-rouge">kernel/kalloc.c</code>中，修改<code class="language-plaintext highlighter-rouge">kmem</code>结构体为数组形式</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">lock</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">freelist</span><span class="p">;</span>
<span class="p">}</span> <span class="n">kmem</span><span class="p">[</span><span class="n">NCPU</span><span class="p">];</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">kinit()</code>要循环初始化每一个<code class="language-plaintext highlighter-rouge">kmem</code>的锁</p></ol><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">kinit</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NCPU</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">,</span> <span class="s">"kmem"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">freerange</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">PHYSTOP</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">kfree</code>将释放出来的freelist节点返回给调用<code class="language-plaintext highlighter-rouge">kfree</code>的CPU</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">kfree</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pa</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(((</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span> <span class="o">%</span> <span class="n">PGSIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">||</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span> <span class="o">&gt;=</span> <span class="n">PHYSTOP</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"kfree"</span><span class="p">);</span>

  <span class="c1">// Fill with junk to catch dangling refs.</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>

  <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">run</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span><span class="p">;</span>

  <span class="n">push_off</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">ncpu</span> <span class="o">=</span> <span class="n">cpuid</span><span class="p">();</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">[</span><span class="n">ncpu</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">[</span><span class="n">ncpu</span><span class="p">].</span><span class="n">freelist</span><span class="p">;</span>
  <span class="n">kmem</span><span class="p">[</span><span class="n">ncpu</span><span class="p">].</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">[</span><span class="n">ncpu</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">pop_off</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">kalloc</code>中，当发现freelist已经用完后，需要向其他CPU的freelist借用节点</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="o">*</span>
<span class="nf">kalloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

  <span class="n">push_off</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">ncpu</span> <span class="o">=</span> <span class="n">cpuid</span><span class="p">();</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">[</span><span class="n">ncpu</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">[</span><span class="n">ncpu</span><span class="p">].</span><span class="n">freelist</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">kmem</span><span class="p">[</span><span class="n">ncpu</span><span class="p">].</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="p">}</span> 
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">[</span><span class="n">ncpu</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// steal other cpu's freelist</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NCPU</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ncpu</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
      <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
      <span class="n">r</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">freelist</span><span class="p">;</span>     
      <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">kmem</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">pop_off</span><span class="p">();</span>
  
  <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">memset</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">r</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span> <span class="c1">// fill with junk</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li>Buffer cache</ol><p>实验要求：xv6文件系统的buffer cache采用了一个全局的锁<code class="language-plaintext highlighter-rouge">bcache.lock</code>来负责对buffer cache进行读写保护，当xv6执行读写文件强度较大的任务时会产生较大的锁竞争压力，因此需要一个哈希表，将buf entry以<code class="language-plaintext highlighter-rouge">buf.blockno</code>为键哈希映射到这个哈希表的不同的BUCKET中，给每个BUCKET一个锁，<code class="language-plaintext highlighter-rouge">NBUCKET</code>最好选择素数，这里选择13。注意：这个实验不能像上一个一样给每个CPU一个<code class="language-plaintext highlighter-rouge">bcache</code>，因为文件系统在多个CPU之间是真正实现共享的，否则将会造成一个CPU只能访问某些文件的问题。</p><p>这里实验让我们可以使用<code class="language-plaintext highlighter-rouge">ticks</code>作为时间戳，来代替原来的双向链表实现LRU的功能。</p><p>在<code class="language-plaintext highlighter-rouge">kernel/bio.c</code>中，首先设置<code class="language-plaintext highlighter-rouge">NBUCKET</code>宏定义为13，声明外部变量<code class="language-plaintext highlighter-rouge">ticks</code>，修改<code class="language-plaintext highlighter-rouge">bcache</code>以为每个<code class="language-plaintext highlighter-rouge">BUCKET</code>设置一个链表头，并设置一个锁</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#define NBUCKET 13
</span>
<span class="n">uint</span> <span class="k">extern</span> <span class="n">ticks</span><span class="p">;</span>

<span class="k">struct</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">lock</span><span class="p">[</span><span class="n">NBUCKET</span><span class="p">];</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="n">buf</span><span class="p">[</span><span class="n">NBUF</span><span class="p">];</span>

  <span class="c1">// Linked list of all buffers, through prev/next.</span>
  <span class="c1">// Sorted by how recently the buffer was used.</span>
  <span class="c1">// head.next is most recent, head.prev is least.</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="n">head</span><span class="p">[</span><span class="n">NBUCKET</span><span class="p">];</span>
<span class="p">}</span> <span class="n">bcache</span><span class="p">;</span>
</pre></table></code></div></div><p>修改<code class="language-plaintext highlighter-rouge">kernel/buf.h</code>中的<code class="language-plaintext highlighter-rouge">buf</code>结构体，删除<code class="language-plaintext highlighter-rouge">struct buf *prev</code>，即将双向链表变为单向链表，添加<code class="language-plaintext highlighter-rouge">uint time</code>这个成员变量作为时间戳。</p><p>实现一个简单的哈希函数</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">hash</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">NBUCKET</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>修改<code class="language-plaintext highlighter-rouge">binit</code>函数，为每个<code class="language-plaintext highlighter-rouge">bcache.lock</code>以及<code class="language-plaintext highlighter-rouge">b-&gt;lock</code>进行初始化，并将所有<code class="language-plaintext highlighter-rouge">buf</code>先添加到bucket 0哈希表中</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">binit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NBUCKET</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">"bcache"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="c1">// for initialization, append all bufs to bucket 0</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">bcache</span><span class="p">.</span><span class="n">buf</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">bcache</span><span class="p">.</span><span class="n">buf</span><span class="o">+</span><span class="n">NBUF</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">initsleeplock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="s">"buffer"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>修改<code class="language-plaintext highlighter-rouge">bget</code>，先查找当前哈希表中有没有和传入参数<code class="language-plaintext highlighter-rouge">dev</code>、<code class="language-plaintext highlighter-rouge">blockno</code>相同的<code class="language-plaintext highlighter-rouge">buf</code>。先要将<code class="language-plaintext highlighter-rouge">blockno</code>哈希到一个id值，然后获得对应id值的<code class="language-plaintext highlighter-rouge">bcache.lock[id]</code>锁，然后在这个bucket id哈希链表中查找符合对应条件的<code class="language-plaintext highlighter-rouge">buf</code>，如果找到则返回，返回前释放掉<code class="language-plaintext highlighter-rouge">bcache.lock[id]</code>，并对<code class="language-plaintext highlighter-rouge">buf</code>加sleeplock。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span><span class="n">blockno</span><span class="p">);</span>
<span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span> <span class="o">==</span> <span class="n">blockno</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">holding</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">[</span><span class="n">id</span><span class="p">]))</span>
            <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
        <span class="n">acquiresleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>如果没有找到对应的<code class="language-plaintext highlighter-rouge">buf</code>，需要在整个哈希表中查找LRU(least recently used)<code class="language-plaintext highlighter-rouge">buf</code>，将其替换掉。这里由于总共有<code class="language-plaintext highlighter-rouge">NBUCKET</code>个哈希表，而此时一定是持有<code class="language-plaintext highlighter-rouge">bcache.lock[id]</code>这个哈希表的锁的，因此当查找其他哈希表时，需要获取其他哈希表的锁，这时就会有产生死锁的风险。风险1：查找的哈希表正是自己本身这个哈希表，在已经持有自己哈希表锁的情况下，不能再尝试<code class="language-plaintext highlighter-rouge">acquire</code>一遍自己的锁。风险2：假设有2个进程同时要进行此步骤，进程1已经持有了哈希表A的锁，尝试获取哈希表B的锁，进程2已经持有了哈希表B的锁，尝试获取哈希表A的锁，同样会造成死锁，因此要规定一个规则，是的当持有哈希表A的情况下如果能够获取哈希表B的锁，则当持有哈希表B锁的情况下不能够持有哈希表A的锁。该规则在<code class="language-plaintext highlighter-rouge">can_lock</code>函数中实现。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">can_lock</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">NBUCKET</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">id</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">id</span><span class="o">+</span><span class="n">num</span><span class="p">))</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">NBUCKET</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">id</span><span class="o">+</span><span class="n">num</span><span class="p">)</span><span class="o">%</span><span class="n">NBUCKET</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>其中<code class="language-plaintext highlighter-rouge">id</code>是已经持有的锁，<code class="language-plaintext highlighter-rouge">j</code>是判断是否能获取该索引哈希表的锁。这个规则实际上规定了在持有某一个锁的情况下，只能再尝试获取<code class="language-plaintext highlighter-rouge">NBCUKET/2</code>个哈希表锁，另一半哈希表锁是不能获取的。</p><p>确定了这个规则之后，尝试遍历所有的哈希表，通过<code class="language-plaintext highlighter-rouge">b-&gt;time</code>查找LRU<code class="language-plaintext highlighter-rouge">buf</code>。先判断当前的哈希表索引是否为<code class="language-plaintext highlighter-rouge">id</code>，如果是，则不获取这个锁（已经获取过它了），但是还是要遍历这个哈希表的；同时也要判断当前哈希表索引是否满足<code class="language-plaintext highlighter-rouge">can_lock</code>规则，如果不满足，则不遍历这个哈希表，直接<code class="language-plaintext highlighter-rouge">continue</code>。如果哈希表索引<code class="language-plaintext highlighter-rouge">j</code>既不是<code class="language-plaintext highlighter-rouge">id</code>，也满足<code class="language-plaintext highlighter-rouge">can_lock</code>，则获取这个锁，并进行遍历。当找到了一个当前情况下的<code class="language-plaintext highlighter-rouge">b-&gt;time</code>最小值时，如果这个最小值和上一个最小值不在同一个哈希表中，则释放上一个哈希表锁，一直持有拥有当前情况下LRU<code class="language-plaintext highlighter-rouge">buf</code>这个哈希表的锁，直到找到新的LRU<code class="language-plaintext highlighter-rouge">buf</code>且不是同一个哈希表为止。找到LRU<code class="language-plaintext highlighter-rouge">buf</code>后，由于此时还拥有这个哈希表的锁，因此可以直接将这个<code class="language-plaintext highlighter-rouge">buf</code>从该哈希链表中剔除，并将其append到bucket<code class="language-plaintext highlighter-rouge">id</code>哈希表中，修改这个锁的<code class="language-plaintext highlighter-rouge">dev</code>、<code class="language-plaintext highlighter-rouge">blockno</code>、<code class="language-plaintext highlighter-rouge">valid</code>、<code class="language-plaintext highlighter-rouge">refcnt</code>等属性。最后释放所有的锁。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">uint</span> <span class="n">smallest_tick</span> <span class="o">=</span> <span class="n">__UINT32_MAX__</span><span class="p">;</span>
<span class="c1">// find the LRU unused buffer</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">NBUCKET</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="o">!=</span><span class="n">id</span> <span class="o">&amp;&amp;</span> <span class="n">can_lock</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// if j == id, then lock is already acquired</span>
        <span class="c1">// can_lock is to maintain an invariant of lock acquisition order</span>
        <span class="c1">// to avoid dead lock</span>
        <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_lock</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">smallest_tick</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">smallest_tick</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">holding</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span> <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span>   
        <span class="p">}</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="o">!=</span><span class="n">id</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">!=</span><span class="n">index</span> <span class="o">&amp;&amp;</span> <span class="n">holding</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">panic</span><span class="p">(</span><span class="s">"bget: no buffers"</span><span class="p">);</span>
<span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

<span class="k">while</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">==</span> <span class="n">smallest_tick</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="n">id</span> <span class="o">&amp;&amp;</span> <span class="n">holding</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span> <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
<span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
<span class="k">while</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">selected</span><span class="p">;</span>
<span class="n">selected</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">selected</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
<span class="n">selected</span><span class="o">-&gt;</span><span class="n">blockno</span> <span class="o">=</span> <span class="n">blockno</span><span class="p">;</span>
<span class="n">selected</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">selected</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">holding</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">[</span><span class="n">id</span><span class="p">]))</span>
    <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
<span class="n">acquiresleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">selected</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="k">return</span> <span class="n">selected</span><span class="p">;</span>
<span class="err">}</span>
</pre></table></code></div></div><p>修改<code class="language-plaintext highlighter-rouge">brelse</code>。当<code class="language-plaintext highlighter-rouge">b-&gt;refcnt==0</code>时，说明这个<code class="language-plaintext highlighter-rouge">buf</code>已经被使用完了，可以进行释放，为其加上时间戳</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">brelse</span><span class="p">(</span><span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">holdingsleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"brelse"</span><span class="p">);</span>

  <span class="n">releasesleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span><span class="p">);</span>
  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
  <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">--</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="n">ticks</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>修改<code class="language-plaintext highlighter-rouge">bpin</code>和<code class="language-plaintext highlighter-rouge">bunpin</code>，将<code class="language-plaintext highlighter-rouge">bcache.lock</code>修改为<code class="language-plaintext highlighter-rouge">bcache.lock[id]</code></p><p>最后在<code class="language-plaintext highlighter-rouge">param.h</code>中修改<code class="language-plaintext highlighter-rouge">NBUF</code>的值，由于<code class="language-plaintext highlighter-rouge">can_lock</code>规则，<code class="language-plaintext highlighter-rouge">NBUF</code>实际上变成了原来的一半，可能会出现<code class="language-plaintext highlighter-rouge">buffer run out</code>的panic，无法通过<code class="language-plaintext highlighter-rouge">writebig</code>测试，因此适当增大<code class="language-plaintext highlighter-rouge">NBUF</code>，我这里将其修改为了<code class="language-plaintext highlighter-rouge">(MAXOPBLOCKS*12)</code></p><h1 id="lecture-11-file-system">Lecture 11 File system</h1><h2 id="110-overview">11.0 Overview</h2><p>文件系统：组织并存储数据。</p><p>文件系统的特性：</p><ul><li>需要一个存储文件夹和文件的数据结构来记录存储文件内容的硬盘块的ID，并且记录磁盘的哪些部分是空闲的<li>在不同的用户和应用程序之间共享数据<li>数据在重启/意外崩溃之后依然保持原样<li>由于访问硬盘速度远慢于访问内存，因此文件系统必须在内存里设置一个对经常访问的文件内容的缓存区。</ul><p>xv6文件系统的组织架构</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210207194130429.png" alt="image-20210207194130429" /></p><ul><li>disk层：对virtio硬盘上的文件块进行读写操作<li>buffer cache层：对磁盘文件块进行缓存，并确保只有1个内核进程能在一段时间内修改文件块上存储的数据。<li>logging层：让更高的层级能够将对文件块的所有update打包到一个<em>transaction</em>中，从而能保证所有文件块能够在将要崩溃时原子地进行update<li>inode层：为每个文件提供一个独一无二的<em>inode number</em><li>directory层：将每个文件夹作为一个特殊的inode，这个inode的内容是文件夹entry<li>pathname层：将文件夹组织为层级，并通过递归查找来解析路径<li>file descriptor层：将管道、设备等UNIX资源用文件系统进行抽象</ul><h2 id="111-disk-layer">11.1 Disk layer</h2><p>文件系统将磁盘分为了几个部分，每个部分的最小单元是block，一个block的大小为1024字节，如下图所示</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210207200046544.png" alt="image-20210207200046544" /></p><ul><li>block 0: 启动区域，文件系统不会使用，包含了操作系统启动所需要的代码<li>blcok 1: <em>superblock</em>，存储了文件系统的元数据（block的大小、block的数目、inode的数目等），里面有一个<code class="language-plaintext highlighter-rouge">mkfs</code>的程序，用来构建初始的文件系统<li>block 2-31：log block<li>block 32-44: inode，一个inode的大小为64字节，一个block的大小为1024字节，因此block32为inode 1-16，block33为inode 17-32<li>block 45 bitmap block，用来跟踪哪些block是在使用<li>最后从block 46开始是data block，要么是在bitmap中被标记为空闲状态，要么存储了文件/文件夹的内容</ul><h2 id="112-buffer-cache-layer">11.2 Buffer cache layer</h2><p>buffer cache层有两个作用：</p><ol><li>将对磁盘块的访问权限进行同步，保证内存中只保存一个该磁盘块的拷贝，且一次只有一个内核线程访问这个拷贝，但同时可以有多个对这个block的引用<li>将被频繁访问的块缓存到内存中</ol><p>buffer cache(<code class="language-plaintext highlighter-rouge">bcache</code>结构体)中的<code class="language-plaintext highlighter-rouge">buf</code>数量是一定的(<code class="language-plaintext highlighter-rouge">NBUF</code>)，因此当新的文件块需要加入缓冲区时，需要将最早使用的缓冲区中的文件块替换为新的文件块。缓冲区的使用早晚通过<code class="language-plaintext highlighter-rouge">head</code>来判断。</p><p>buffer cache本身是一个双向链接的链表，链表元素为<code class="language-plaintext highlighter-rouge">buf</code>结构体。<code class="language-plaintext highlighter-rouge">binit()</code>如下</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">binit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>

  <span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="s">"bcache"</span><span class="p">);</span>

  <span class="c1">// Create linked list of buffers</span>
  <span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
  <span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">bcache</span><span class="p">.</span><span class="n">buf</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">bcache</span><span class="p">.</span><span class="n">buf</span><span class="o">+</span><span class="n">NBUF</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">){</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
    <span class="n">initsleeplock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="s">"buffer"</span><span class="p">);</span>
    <span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>buffer cache层的接口函数有2个，分别是<code class="language-plaintext highlighter-rouge">bread()</code>和<code class="language-plaintext highlighter-rouge">bwrite()</code>。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// Return a locked buf with the contents of the indicated block.</span>
<span class="k">struct</span> <span class="n">buf</span><span class="o">*</span>
<span class="nf">bread</span><span class="p">(</span><span class="n">uint</span> <span class="n">dev</span><span class="p">,</span> <span class="n">uint</span> <span class="n">blockno</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>

  <span class="n">b</span> <span class="o">=</span> <span class="n">bget</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">blockno</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">virtio_disk_rw</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">bread</code>通过<code class="language-plaintext highlighter-rouge">bget</code>获取一个指定了设备<code class="language-plaintext highlighter-rouge">dev</code>和<code class="language-plaintext highlighter-rouge">blockno</code>的<code class="language-plaintext highlighter-rouge">buf *</code>，这是从硬盘指定的块中获取的一个缓冲数据结构体，保存在内存中，可以进行修改</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="c1">// Look through buffer cache for block on device dev.</span>
<span class="c1">// If not found, allocate a buffer.</span>
<span class="c1">// In either case, return locked buffer.</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">buf</span><span class="o">*</span>
<span class="nf">bget</span><span class="p">(</span><span class="n">uint</span> <span class="n">dev</span><span class="p">,</span> <span class="n">uint</span> <span class="n">blockno</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

  <span class="c1">// Is the block already cached?</span>
  <span class="k">for</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">;</span> <span class="n">b</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span> <span class="o">==</span> <span class="n">blockno</span><span class="p">){</span>
      <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span><span class="p">;</span>
      <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
      <span class="n">acquiresleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Not cached.</span>
  <span class="c1">// Recycle the least recently used (LRU) unused buffer.</span>
  <span class="k">for</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span> <span class="n">b</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">b</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
      <span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span> <span class="o">=</span> <span class="n">blockno</span><span class="p">;</span>
      <span class="n">b</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
      <span class="n">acquiresleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">panic</span><span class="p">(</span><span class="s">"bget: no buffers"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">bget()</code>先查看需要buffer的文件块是否已经在<code class="language-plaintext highlighter-rouge">bcache</code>中，如果没有，就将LRU(least recently used) <code class="language-plaintext highlighter-rouge">buf</code>替换为这个新的文件块。<code class="language-plaintext highlighter-rouge">b-&gt;valid=0</code>说明这个<code class="language-plaintext highlighter-rouge">buf</code>是刚刚被替换掉的而不是本来就有的，因此要让<code class="language-plaintext highlighter-rouge">bread()</code>从硬盘中再加载一下相应block中的数据到这个<code class="language-plaintext highlighter-rouge">buf</code>中。<code class="language-plaintext highlighter-rouge">bcache.lock</code>负责保护哪些block被缓存的信息，而<code class="language-plaintext highlighter-rouge">b-&gt;lock</code>负责对这个缓存块的读写行为进行保护。<code class="language-plaintext highlighter-rouge">acquiresleep</code>是获取这个锁之后立即让这个进程进入睡眠，这是因为当获取着锁的时候会disable掉中断，这样就永远也无法听到来自硬盘的中断。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">// Write b's contents to disk.  Must be locked.</span>
<span class="kt">void</span>
<span class="nf">bwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">holdingsleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"bwrite"</span><span class="p">);</span>
  <span class="n">virtio_disk_rw</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>向硬盘指定块中写入数据。<code class="language-plaintext highlighter-rouge">struct buf</code>中已经保存了<code class="language-plaintext highlighter-rouge">dev</code>和<code class="language-plaintext highlighter-rouge">blockno</code>等数据，因此可以直接调用<code class="language-plaintext highlighter-rouge">virtio_disk_rw(b,1)</code>进行写入。<code class="language-plaintext highlighter-rouge">brelse</code>负责释放<code class="language-plaintext highlighter-rouge">bread</code>中返回的<code class="language-plaintext highlighter-rouge">buf</code>的锁。当发现指向这个<code class="language-plaintext highlighter-rouge">buf</code>的reference变为0时，将其移动到双向链表的最开头。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c1">// Release a locked buffer.</span>
<span class="c1">// Move to the head of the most-recently-used list.</span>
<span class="kt">void</span>
<span class="nf">brelse</span><span class="p">(</span><span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">holdingsleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"brelse"</span><span class="p">);</span>

  <span class="n">releasesleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">--</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// no one is waiting for it.</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
    <span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="113-block-allocator">11.3 Block allocator</h2><p>文件和文件夹都存储在磁盘块中，磁盘块必须从一个空闲池中进行分配。block allocator为磁盘的是否空闲的状态准备了一个bitmap，每一位对应一个磁盘块，0表示空闲1表示正在使用，<code class="language-plaintext highlighter-rouge">mkfs</code>负责设置这些位。</p><p><code class="language-plaintext highlighter-rouge">balloc</code>负责分配新的磁盘块，<code class="language-plaintext highlighter-rouge">bfree</code>负责释放磁盘块</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c1">// Allocate a zeroed disk block.</span>
<span class="k">static</span> <span class="n">uint</span>
<span class="nf">balloc</span><span class="p">(</span><span class="n">uint</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>

  <span class="n">bp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">sb</span><span class="p">.</span><span class="n">size</span><span class="p">;</span> <span class="n">b</span> <span class="o">+=</span> <span class="n">BPB</span><span class="p">){</span>
    <span class="n">bp</span> <span class="o">=</span> <span class="n">bread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">BBLOCK</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">sb</span><span class="p">));</span>
    <span class="k">for</span><span class="p">(</span><span class="n">bi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bi</span> <span class="o">&lt;</span> <span class="n">BPB</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">+</span> <span class="n">bi</span> <span class="o">&lt;</span> <span class="n">sb</span><span class="p">.</span><span class="n">size</span><span class="p">;</span> <span class="n">bi</span><span class="o">++</span><span class="p">){</span>
      <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bi</span> <span class="o">%</span> <span class="mi">8</span><span class="p">);</span>
      <span class="k">if</span><span class="p">((</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bi</span><span class="o">/</span><span class="mi">8</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>  <span class="c1">// Is block free?</span>
        <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bi</span><span class="o">/</span><span class="mi">8</span><span class="p">]</span> <span class="o">|=</span> <span class="n">m</span><span class="p">;</span>  <span class="c1">// Mark block in use.</span>
        <span class="n">log_write</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
        <span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
        <span class="n">bzero</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">bi</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">b</span> <span class="o">+</span> <span class="n">bi</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">panic</span><span class="p">(</span><span class="s">"balloc: out of blocks"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">balloc</code>最外层循环读取每个bitmap bit所代表的block（<code class="language-plaintext highlighter-rouge">BPB</code>是一个Block的bit数目，<code class="language-plaintext highlighter-rouge">BBLOCK</code>负责把bit转化为blockno）,内循环负责检查所有<code class="language-plaintext highlighter-rouge">BPB</code>位，查看这个block是否空闲</p><h2 id="114-inode-layer">11.4 Inode layer</h2><p><em>inode</em>可能指代2种数据结构：1. 储存在硬盘上的数据结构，包含了inode类型、inode指向的文件/文件夹大小、一个数据blockno的列表 2. 存储在内存中的数据结构，拥有on-disk inode的拷贝以及其他kernel需要的metadata</p><p>on-disk inode放在一个连续的区域内，这个区域有很多block，叫做inode block，每个inode大小相同，为64字节</p><p>on-disk inode以<code class="language-plaintext highlighter-rouge">struct dinode</code>的形式定义</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">dinode</span> <span class="p">{</span>
  <span class="kt">short</span> <span class="n">type</span><span class="p">;</span>           <span class="c1">// File type</span>
  <span class="kt">short</span> <span class="n">major</span><span class="p">;</span>          <span class="c1">// Major device number (T_DEVICE only)</span>
  <span class="kt">short</span> <span class="n">minor</span><span class="p">;</span>          <span class="c1">// Minor device number (T_DEVICE only)</span>
  <span class="kt">short</span> <span class="n">nlink</span><span class="p">;</span>          <span class="c1">// Number of links to inode in file system</span>
  <span class="n">uint</span> <span class="n">size</span><span class="p">;</span>            <span class="c1">// Size of file (bytes)</span>
  <span class="n">uint</span> <span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>   <span class="c1">// Data block addresses</span>
<span class="p">};</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">type</code>指定了是文件、文件夹还是设备，<code class="language-plaintext highlighter-rouge">type==0</code>表示这个inode处于空闲状态。<code class="language-plaintext highlighter-rouge">nlink</code>表示连接到这个inode的directory entry的个数，用来判断这个inode应该何时被释放。<code class="language-plaintext highlighter-rouge">size</code>记录了这个文件/文件夹的大小，<code class="language-plaintext highlighter-rouge">addrs</code>记录了这个inode拥有的文件内容分布在的disk block的所有<code class="language-plaintext highlighter-rouge">blockno</code></p><p>内存中的inode是active inodes，用<code class="language-plaintext highlighter-rouge">struct inode</code>定义</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// in-memory copy of an inode</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="p">{</span>
  <span class="n">uint</span> <span class="n">dev</span><span class="p">;</span>           <span class="c1">// Device number</span>
  <span class="n">uint</span> <span class="n">inum</span><span class="p">;</span>          <span class="c1">// Inode number</span>
  <span class="kt">int</span> <span class="n">ref</span><span class="p">;</span>            <span class="c1">// Reference count</span>
  <span class="k">struct</span> <span class="n">sleeplock</span> <span class="n">lock</span><span class="p">;</span> <span class="c1">// protects everything below here</span>
  <span class="kt">int</span> <span class="n">valid</span><span class="p">;</span>          <span class="c1">// inode has been read from disk?</span>

  <span class="kt">short</span> <span class="n">type</span><span class="p">;</span>         <span class="c1">// copy of disk inode</span>
  <span class="kt">short</span> <span class="n">major</span><span class="p">;</span>
  <span class="kt">short</span> <span class="n">minor</span><span class="p">;</span>
  <span class="kt">short</span> <span class="n">nlink</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">size</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
</pre></table></code></div></div><p>所谓active inodes，是指内存中有C指针指向了这个inode，<code class="language-plaintext highlighter-rouge">ref</code>是指向这个inode的指针数量，当<code class="language-plaintext highlighter-rouge">ref==0</code>时kernel将把这个inode从内存中剔除。<code class="language-plaintext highlighter-rouge">iget</code>函数和<code class="language-plaintext highlighter-rouge">iput</code>函数实现对inode pointer的获取和释放。</p><p>在inode层中总共有4种lock。1. <code class="language-plaintext highlighter-rouge">icache.lock</code>负责确保1个inode只在cache中出现最多1次 ，并且保证<code class="language-plaintext highlighter-rouge">ref</code>正确记录引用到这个inode的数量，因此对<code class="language-plaintext highlighter-rouge">ref</code>的修改都需要用<code class="language-plaintext highlighter-rouge">icache.lock</code>进行保护 2. 每个inode自己也有1个<code class="language-plaintext highlighter-rouge">lock</code>来保护对inode成员变量以及inode指向的文件或文件夹的内容的保护 3. <code class="language-plaintext highlighter-rouge">ref</code>是内存中指向这个inode的个数，当<code class="language-plaintext highlighter-rouge">ref</code>大于0时，不会将这个inode从icache中剔除 4. <code class="language-plaintext highlighter-rouge">nlink</code>这个成员变量在on-disk inode中也存在，统计指向这个文件的directory entry的个数，当为0时将释放掉这个inode</p><p>典型的调用顺序：</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">ip</span> <span class="o">=</span> <span class="n">iget</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
<span class="n">ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="p">...</span><span class="n">examine</span> <span class="n">and</span> <span class="n">modify</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">xxx</span>
<span class="nf">iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="n">iput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">iget</code>返回了一个直到调用<code class="language-plaintext highlighter-rouge">iput</code>都有效的inode，任何代码均可同时访问，因此可以有很多指针指向同一个inode。<code class="language-plaintext highlighter-rouge">iget</code>返回的inode可能没有任何有用的内容(<code class="language-plaintext highlighter-rouge">valid==0</code>)，因此需要调用<code class="language-plaintext highlighter-rouge">ilock</code>来从硬盘中读取内容，并将获取inode的锁。<code class="language-plaintext highlighter-rouge">iunlock</code>释放inode的锁。将对inode的引用获取和对inode上锁分离开来，从而在查找路径等情况中避免死锁。</p><p>inode cache主要目的是实现不同进程对inode访问的同步，cache只是次要的，因为当inode被经常访问时，这个inode很可能会被保存在buffer cahce中。inode cache是<em>write-through</em>的，当cache中的inode被修改，将会立即通过<code class="language-plaintext highlighter-rouge">iupdate</code>将修改写入到磁盘中。</p><h2 id="115-code-inodes">11.5 Code: inodes</h2><p><code class="language-plaintext highlighter-rouge">ialloc</code>负责从硬盘上的inode blocks中寻找空闲的inode，当找到之后将新的type写入到disk中然后通过调用<code class="language-plaintext highlighter-rouge">iget</code>返回一个内存中的inode（将这个inode写入到inode cache）中。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c1">// Allocate an inode on device dev.</span>
<span class="c1">// Mark it as allocated by  giving it type type.</span>
<span class="c1">// Returns an unlocked but allocated and referenced inode.</span>
<span class="k">struct</span> <span class="n">inode</span><span class="o">*</span>
<span class="nf">ialloc</span><span class="p">(</span><span class="n">uint</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">short</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">inum</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">dinode</span> <span class="o">*</span><span class="n">dip</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="n">inum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">inum</span> <span class="o">&lt;</span> <span class="n">sb</span><span class="p">.</span><span class="n">ninodes</span><span class="p">;</span> <span class="n">inum</span><span class="o">++</span><span class="p">){</span>
    <span class="n">bp</span> <span class="o">=</span> <span class="n">bread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">IBLOCK</span><span class="p">(</span><span class="n">inum</span><span class="p">,</span> <span class="n">sb</span><span class="p">));</span>
    <span class="n">dip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dinode</span><span class="o">*</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">inum</span><span class="o">%</span><span class="n">IPB</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>  <span class="c1">// a free inode</span>
      <span class="n">memset</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dip</span><span class="p">));</span>
      <span class="n">dip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
      <span class="n">log_write</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>   <span class="c1">// mark it allocated on the disk</span>
      <span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">iget</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">panic</span><span class="p">(</span><span class="s">"ialloc: no inodes"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">ialloc</code>必须保证其他进程不会同时对这个inode进行读写，这是通过<code class="language-plaintext highlighter-rouge">bp</code>已经通过<code class="language-plaintext highlighter-rouge">bget</code>上了sleeplock来保证的。</p><p><code class="language-plaintext highlighter-rouge">iget</code>在inode cache中查找和传入的device、inode no相同的active entry，如果找到了这个entry就返回对这个inode的一个新的指针，否则找到一个空的entry将其dev、inum等设置为对应的数值，并设置valid为0待后续从block中读取数据。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="c1">// Find the inode with number inum on device dev</span>
<span class="c1">// and return the in-memory copy. Does not lock</span>
<span class="c1">// the inode and does not read it from disk.</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span><span class="o">*</span>
<span class="nf">iget</span><span class="p">(</span><span class="n">uint</span> <span class="n">dev</span><span class="p">,</span> <span class="n">uint</span> <span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="o">*</span><span class="n">empty</span><span class="p">;</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

  <span class="c1">// Is the inode already cached?</span>
  <span class="n">empty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">ip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">inode</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">ip</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">inode</span><span class="p">[</span><span class="n">NINODE</span><span class="p">];</span> <span class="n">ip</span><span class="o">++</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">inum</span> <span class="o">==</span> <span class="n">inum</span><span class="p">){</span>
      <span class="n">ip</span><span class="o">-&gt;</span><span class="n">ref</span><span class="o">++</span><span class="p">;</span>
      <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">ip</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">empty</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>    <span class="c1">// Remember empty slot.</span>
      <span class="n">empty</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Recycle an inode cache entry.</span>
  <span class="k">if</span><span class="p">(</span><span class="n">empty</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"iget: no inodes"</span><span class="p">);</span>

  <span class="n">ip</span> <span class="o">=</span> <span class="n">empty</span><span class="p">;</span>
  <span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
  <span class="n">ip</span><span class="o">-&gt;</span><span class="n">inum</span> <span class="o">=</span> <span class="n">inum</span><span class="p">;</span>
  <span class="n">ip</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">ip</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">ip</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">iput</code>将释放1个对inode的C指针，<code class="language-plaintext highlighter-rouge">ref--</code>，如果<code class="language-plaintext highlighter-rouge">ref==0</code>且<code class="language-plaintext highlighter-rouge">nlink==0</code>（不在任何文件夹中出现），则释放掉这个inode（<code class="language-plaintext highlighter-rouge">ip-&gt;type=0</code>）和它对应的所有data block（通过<code class="language-plaintext highlighter-rouge">itrunc</code>）。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="c1">// Drop a reference to an in-memory inode.</span>
<span class="c1">// If that was the last reference, the inode cache entry can</span>
<span class="c1">// be recycled.</span>
<span class="c1">// If that was the last reference and the inode has no links</span>
<span class="c1">// to it, free the inode (and its content) on disk.</span>
<span class="c1">// All calls to iput() must be inside a transaction in</span>
<span class="c1">// case it has to free the inode.</span>
<span class="kt">void</span>
<span class="nf">iput</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;&amp;</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
    <span class="c1">// inode has no links and no other references: truncate and free.</span>

    <span class="c1">// ip-&gt;ref == 1 means no other process can have ip locked,</span>
    <span class="c1">// so this acquiresleep() won't block (or deadlock).</span>
    <span class="n">acquiresleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

    <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

    <span class="n">itrunc</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
    <span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">iupdate</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
    <span class="n">ip</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">releasesleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

    <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">ip</span><span class="o">-&gt;</span><span class="n">ref</span><span class="o">--</span><span class="p">;</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210213103838057.png" alt="image-20210213103838057" /></p><p>on-disk inode结构<code class="language-plaintext highlighter-rouge">dinode</code>包括了一个size和<code class="language-plaintext highlighter-rouge">NDIRECT+1</code>个addr，前<code class="language-plaintext highlighter-rouge">NDIRECT</code>个addr叫做<em>direct blocks</em>，最后一个addr给出了<em>indirect block</em>的地址，因此一个文件的前12kB（<code class="language-plaintext highlighter-rouge">NDIRECT x BSIZE</code>）可以从inode中的direct block addr直接读取，后256kB（<code class="language-plaintext highlighter-rouge">NINDIRECT x BSIZE</code>）可以通过indirect block addr翻译得到。因此xv6支持的最大的文件大小为268kB</p><p><code class="language-plaintext highlighter-rouge">bmap()</code>负责获取inode中的第n块data block的地址。当<code class="language-plaintext highlighter-rouge">bn&lt;NDIRECT</code>时直接返回<code class="language-plaintext highlighter-rouge">ip-&gt;addrs[bn]</code>，如果没有这个地址就调用<code class="language-plaintext highlighter-rouge">balloc</code>分配一个data block。当<code class="language-plaintext highlighter-rouge">NDIRECT&lt;bn&lt;NINDIRECT</code>时先<code class="language-plaintext highlighter-rouge">bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT])</code>，然后获取<code class="language-plaintext highlighter-rouge">bp-&gt;data[bn-NDIRECT]</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="c1">// Return the disk block address of the nth block in inode ip.</span>
<span class="c1">// If there is no such block, bmap allocates one.</span>
<span class="k">static</span> <span class="n">uint</span>
<span class="nf">bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">uint</span> <span class="n">bn</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">uint</span> <span class="n">addr</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">bn</span> <span class="o">&lt;</span> <span class="n">NDIRECT</span><span class="p">){</span>
    <span class="k">if</span><span class="p">((</span><span class="n">addr</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">bn</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">ip</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">balloc</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">bn</span> <span class="o">-=</span> <span class="n">NDIRECT</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">bn</span> <span class="o">&lt;</span> <span class="n">NINDIRECT</span><span class="p">){</span>
    <span class="c1">// Load indirect block, allocating if necessary.</span>
    <span class="k">if</span><span class="p">((</span><span class="n">addr</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">ip</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">balloc</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
    <span class="n">bp</span> <span class="o">=</span> <span class="n">bread</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint</span><span class="o">*</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="k">if</span><span class="p">((</span><span class="n">addr</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">bn</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
      <span class="n">a</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">balloc</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
      <span class="n">log_write</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">panic</span><span class="p">(</span><span class="s">"bmap: out of range"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="116-directory-layer">11.6 Directory layer</h2><p>文件夹和文件的实现非常类似，它的inode类型为<code class="language-plaintext highlighter-rouge">T_DIR</code>，数据是许多directory entry，每个entry的数据类型为<code class="language-plaintext highlighter-rouge">struct dirent</code>，包含一个名称和inode number</p><p><code class="language-plaintext highlighter-rouge">dirlookup</code>是在directoy中查找名称为<code class="language-plaintext highlighter-rouge">name</code>的directoy entry</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="c1">// Look for a directory entry in a directory.</span>
<span class="c1">// If found, set *poff to byte offset of entry.</span>
<span class="k">struct</span> <span class="n">inode</span><span class="o">*</span>
<span class="nf">dirlookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">uint</span> <span class="o">*</span><span class="n">poff</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">uint</span> <span class="n">off</span><span class="p">,</span> <span class="n">inum</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">dirent</span> <span class="n">de</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">T_DIR</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"dirlookup not DIR"</span><span class="p">);</span>

  <span class="k">for</span><span class="p">(</span><span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">off</span> <span class="o">&lt;</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">off</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">)){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">readi</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">de</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">))</span>
      <span class="n">panic</span><span class="p">(</span><span class="s">"dirlookup read"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">de</span><span class="p">.</span><span class="n">inum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">namecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">de</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
      <span class="c1">// entry matches path element</span>
      <span class="k">if</span><span class="p">(</span><span class="n">poff</span><span class="p">)</span>
        <span class="o">*</span><span class="n">poff</span> <span class="o">=</span> <span class="n">off</span><span class="p">;</span>
      <span class="n">inum</span> <span class="o">=</span> <span class="n">de</span><span class="p">.</span><span class="n">inum</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">iget</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>注意，<code class="language-plaintext highlighter-rouge">dirlookup</code>正是<code class="language-plaintext highlighter-rouge">iget</code>没有直接对inode上锁的原因，因为在调用<code class="language-plaintext highlighter-rouge">dirlookup</code>的时候，实际上已经对<code class="language-plaintext highlighter-rouge">dp</code>上锁了，如果查找的directory entry是<code class="language-plaintext highlighter-rouge">.</code>（当前文件夹/inode本身），那么会试图对<code class="language-plaintext highlighter-rouge">dp</code>再acquire一次锁，造成死锁。</p><p><code class="language-plaintext highlighter-rouge">dirlink</code>将一个新的directory entry写入文件夹dp中，查找dp中尚未分配的entry(inum==0)，如果找到了就将off设置为这个entry的offset，然后用<code class="language-plaintext highlighter-rouge">writei</code>写入，如果没有找到就将off设置为<code class="language-plaintext highlighter-rouge">dp-&gt;size</code>，将这个entry加在最后。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="c1">// Write a new directory entry (name, inum) into the directory dp.</span>
<span class="kt">int</span>
<span class="nf">dirlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">uint</span> <span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">off</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">dirent</span> <span class="n">de</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>

  <span class="c1">// Check that name is not present.</span>
  <span class="k">if</span><span class="p">((</span><span class="n">ip</span> <span class="o">=</span> <span class="n">dirlookup</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
    <span class="n">iput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Look for an empty dirent.</span>
  <span class="k">for</span><span class="p">(</span><span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">off</span> <span class="o">&lt;</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">off</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">)){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">readi</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">de</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">))</span>
      <span class="n">panic</span><span class="p">(</span><span class="s">"dirlink read"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">de</span><span class="p">.</span><span class="n">inum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">strncpy</span><span class="p">(</span><span class="n">de</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">DIRSIZ</span><span class="p">);</span>
  <span class="n">de</span><span class="p">.</span><span class="n">inum</span> <span class="o">=</span> <span class="n">inum</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">writei</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">de</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">))</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"dirlink"</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="117-pathname-layer">11.7 Pathname layer</h2><p><code class="language-plaintext highlighter-rouge">namei</code>函数负责对pathname进行解析，并返回inode。<code class="language-plaintext highlighter-rouge">namei</code>调用了<code class="language-plaintext highlighter-rouge">namex</code>函数，<code class="language-plaintext highlighter-rouge">namex</code>中传入了参数<code class="language-plaintext highlighter-rouge">nameiparent</code>，当为1时返回的inode是传入path的父文件夹，并将最后的element名称复制到name中。<code class="language-plaintext highlighter-rouge">namex</code>不断调用了<code class="language-plaintext highlighter-rouge">skipelem</code>，一步步将当前的inode变为下一级inode，直到得到最终需要的inode为止。注意：在每个循环中都要先进行<code class="language-plaintext highlighter-rouge">ilock(ip)</code>，因为直到<code class="language-plaintext highlighter-rouge">ilock</code>才能保证<code class="language-plaintext highlighter-rouge">ip-&gt;type</code>从硬盘中读取</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="c1">// Look up and return the inode for a path name.</span>
<span class="c1">// If parent != 0, return the inode for the parent and copy the final</span>
<span class="c1">// path element into name, which must have room for DIRSIZ bytes.</span>
<span class="c1">// Must be called inside a transaction since it calls iput().</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span><span class="o">*</span>
<span class="nf">namex</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nameiparent</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">path</span> <span class="o">==</span> <span class="sc">'/'</span><span class="p">)</span>
    <span class="n">ip</span> <span class="o">=</span> <span class="n">iget</span><span class="p">(</span><span class="n">ROOTDEV</span><span class="p">,</span> <span class="n">ROOTINO</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">ip</span> <span class="o">=</span> <span class="n">idup</span><span class="p">(</span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">cwd</span><span class="p">);</span>

  <span class="k">while</span><span class="p">((</span><span class="n">path</span> <span class="o">=</span> <span class="n">skipelem</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
    <span class="n">ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">T_DIR</span><span class="p">){</span>
      <span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">nameiparent</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">path</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">){</span>
      <span class="c1">// Stop one level early.</span>
      <span class="n">iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">ip</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">((</span><span class="n">next</span> <span class="o">=</span> <span class="n">dirlookup</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
      <span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
    <span class="n">ip</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">nameiparent</span><span class="p">){</span>
    <span class="n">iput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">ip</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>由于<code class="language-plaintext highlighter-rouge">namex</code>中可能涉及到多个data block的I/O，因此可能是比较耗时的，当一个kernel thread执行<code class="language-plaintext highlighter-rouge">namex</code>被disk I/O阻塞时，其他thread再执行<code class="language-plaintext highlighter-rouge">namex</code>查找不同的文件夹path时不会被阻塞。</p><h2 id="118-file-descriptor-layer">11.8 File descriptor layer</h2><p>file descriptor layer可以让UNIX中的所有资源，包括设备（比如console）来统一表示为文件。每个打开的文件（file descriptor）都用<code class="language-plaintext highlighter-rouge">struct file</code>来表示，这是一个pipe/inode/device的包装结构体。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">file</span> <span class="p">{</span>
  <span class="k">enum</span> <span class="p">{</span> <span class="n">FD_NONE</span><span class="p">,</span> <span class="n">FD_PIPE</span><span class="p">,</span> <span class="n">FD_INODE</span><span class="p">,</span> <span class="n">FD_DEVICE</span> <span class="p">}</span> <span class="n">type</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ref</span><span class="p">;</span> <span class="c1">// reference count</span>
  <span class="kt">char</span> <span class="n">readable</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">writable</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">;</span> <span class="c1">// FD_PIPE</span>
  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>  <span class="c1">// FD_INODE and FD_DEVICE</span>
  <span class="n">uint</span> <span class="n">off</span><span class="p">;</span>          <span class="c1">// FD_INODE</span>
  <span class="kt">short</span> <span class="n">major</span><span class="p">;</span>       <span class="c1">// FD_DEVICE</span>
<span class="p">};</span>
</pre></table></code></div></div><p>system call调用一次<code class="language-plaintext highlighter-rouge">open()</code>将增加一个open file，同一个file可以被多个不同的进程<code class="language-plaintext highlighter-rouge">open</code>，出现在这些进程的file table中。<code class="language-plaintext highlighter-rouge">struct file</code>中的reference count记录了同一个file被引用的次数。</p><p>所有打开的文件都保存在global file table，即<code class="language-plaintext highlighter-rouge">ftable</code>中。</p><p><code class="language-plaintext highlighter-rouge">filealloc</code>负责在file table中分配一个文件，在<code class="language-plaintext highlighter-rouge">ftable</code>中扫描ref==0的file，增加ref后返回这个file *。</p><p><code class="language-plaintext highlighter-rouge">filedup</code>负责对这个file descriptor的ref++并返回这个文件的file *。</p><p><code class="language-plaintext highlighter-rouge">fileclose</code>负责对file descriptor的ref–，当ref==0时根据这个file的类型释放掉pipe或者inode</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">// Close file f.  (Decrement ref count, close when reaches 0.)</span>
<span class="kt">void</span>
<span class="nf">fileclose</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">file</span> <span class="n">ff</span><span class="p">;</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftable</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"fileclose"</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="o">--</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
    <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftable</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">ff</span> <span class="o">=</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
  <span class="n">f</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">FD_NONE</span><span class="p">;</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftable</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="n">ff</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">FD_PIPE</span><span class="p">){</span>
    <span class="n">pipeclose</span><span class="p">(</span><span class="n">ff</span><span class="p">.</span><span class="n">pipe</span><span class="p">,</span> <span class="n">ff</span><span class="p">.</span><span class="n">writable</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">ff</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">FD_INODE</span> <span class="o">||</span> <span class="n">ff</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">FD_DEVICE</span><span class="p">){</span>
    <span class="n">begin_op</span><span class="p">();</span>
    <span class="n">iput</span><span class="p">(</span><span class="n">ff</span><span class="p">.</span><span class="n">ip</span><span class="p">);</span>
    <span class="n">end_op</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">fileread</code>和<code class="language-plaintext highlighter-rouge">filewrite</code>分别确认<code class="language-plaintext highlighter-rouge">f-&gt;readable</code>和<code class="language-plaintext highlighter-rouge">f-&gt;writable</code>是否允许当前的读写操作，然后再根据<code class="language-plaintext highlighter-rouge">f-&gt;type</code>是<code class="language-plaintext highlighter-rouge">FD_PIPE</code>/<code class="language-plaintext highlighter-rouge">FD_DEVICE</code>/<code class="language-plaintext highlighter-rouge">FD_INODE</code>进行对应的<code class="language-plaintext highlighter-rouge">piperead</code>/<code class="language-plaintext highlighter-rouge">readi</code>等操作。<code class="language-plaintext highlighter-rouge">fileread</code>和<code class="language-plaintext highlighter-rouge">filewrite</code>都使用了<code class="language-plaintext highlighter-rouge">f-&gt;off</code>来指示当前的读写到了哪一个位置。</p><h2 id="119-code-system-calls">11.9 Code: System calls</h2><p><code class="language-plaintext highlighter-rouge">sys_link</code>和<code class="language-plaintext highlighter-rouge">sys_unlink</code>这两个syscall实现对inode增加或者删除引用</p><p><code class="language-plaintext highlighter-rouge">sys_link</code>传入一个参数<code class="language-plaintext highlighter-rouge">old</code>和一个参数<code class="language-plaintext highlighter-rouge">new</code>，<code class="language-plaintext highlighter-rouge">new</code>是需要链接到<code class="language-plaintext highlighter-rouge">old</code>的路径。<code class="language-plaintext highlighter-rouge">sys_link</code>增加<code class="language-plaintext highlighter-rouge">ip-&gt;nlink</code>，然后调用<code class="language-plaintext highlighter-rouge">nameiparent</code>查找到<code class="language-plaintext highlighter-rouge">new</code>的父文件夹，调用<code class="language-plaintext highlighter-rouge">dirlink</code>在父文件夹下创建一个名称为<code class="language-plaintext highlighter-rouge">new</code>的directory entry，链接到<code class="language-plaintext highlighter-rouge">old</code>所代表的inode。如果中间出现了错误，需要跳转到bad来减去<code class="language-plaintext highlighter-rouge">ip-&gt;nlink</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre><span class="c1">// Create the path new as a link to the same inode as old.</span>
<span class="n">uint64</span>
<span class="nf">sys_link</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">DIRSIZ</span><span class="p">],</span> <span class="n">new</span><span class="p">[</span><span class="n">MAXPATH</span><span class="p">],</span> <span class="n">old</span><span class="p">[</span><span class="n">MAXPATH</span><span class="p">];</span>
  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">argstr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">MAXPATH</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">argstr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">MAXPATH</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="n">begin_op</span><span class="p">();</span>
  <span class="k">if</span><span class="p">((</span><span class="n">ip</span> <span class="o">=</span> <span class="n">namei</span><span class="p">(</span><span class="n">old</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
    <span class="n">end_op</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">T_DIR</span><span class="p">){</span>
    <span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
    <span class="n">end_op</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">ip</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="o">++</span><span class="p">;</span>
  <span class="n">iupdate</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
  <span class="n">iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

  <span class="k">if</span><span class="p">((</span><span class="n">dp</span> <span class="o">=</span> <span class="n">nameiparent</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
  <span class="n">ilock</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">!=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">||</span> <span class="n">dirlink</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
    <span class="n">iunlockput</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
    <span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">iunlockput</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
  <span class="n">iput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

  <span class="n">end_op</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bad:</span>
  <span class="n">ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
  <span class="n">ip</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="o">--</span><span class="p">;</span>
  <span class="n">iupdate</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
  <span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
  <span class="n">end_op</span><span class="p">();</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">sys_link</code>为已经存在的inode创建一个新的directoy entry，而<code class="language-plaintext highlighter-rouge">create</code>则是为一个新的inode创建一个新的directory entry。<code class="language-plaintext highlighter-rouge">create</code>首先调用<code class="language-plaintext highlighter-rouge">nameiparent</code>获取父文件夹，然后调用<code class="language-plaintext highlighter-rouge">dirlookup</code>来查看这个文件夹下是否已经存在同名的inode，如果存在且调用这个<code class="language-plaintext highlighter-rouge">create</code>的是<code class="language-plaintext highlighter-rouge">open</code>来创建一个文件的话，那么直接返回这个inode。如果这个名称不存在，则调用<code class="language-plaintext highlighter-rouge">ialloc</code>。如果是<code class="language-plaintext highlighter-rouge">mkdir</code>调用的<code class="language-plaintext highlighter-rouge">create</code>（即<code class="language-plaintext highlighter-rouge">type==T_DIR</code>)，则要创建<code class="language-plaintext highlighter-rouge">..</code>和<code class="language-plaintext highlighter-rouge">.</code>作为对父级inode和当前inode的引用，最终将当前的<code class="language-plaintext highlighter-rouge">name</code> <code class="language-plaintext highlighter-rouge">dirlink</code>到当前inode。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span><span class="o">*</span>
<span class="nf">create</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">short</span> <span class="n">type</span><span class="p">,</span> <span class="kt">short</span> <span class="n">major</span><span class="p">,</span> <span class="kt">short</span> <span class="n">minor</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">DIRSIZ</span><span class="p">];</span>

  <span class="k">if</span><span class="p">((</span><span class="n">dp</span> <span class="o">=</span> <span class="n">nameiparent</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">ilock</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>

  <span class="k">if</span><span class="p">((</span><span class="n">ip</span> <span class="o">=</span> <span class="n">dirlookup</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
    <span class="n">iunlockput</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
    <span class="n">ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">T_FILE</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">T_FILE</span> <span class="o">||</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">T_DEVICE</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">ip</span><span class="p">;</span>
    <span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">((</span><span class="n">ip</span> <span class="o">=</span> <span class="n">ialloc</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">type</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"create: ialloc"</span><span class="p">);</span>

  <span class="n">ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
  <span class="n">ip</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">=</span> <span class="n">major</span><span class="p">;</span>
  <span class="n">ip</span><span class="o">-&gt;</span><span class="n">minor</span> <span class="o">=</span> <span class="n">minor</span><span class="p">;</span>
  <span class="n">ip</span><span class="o">-&gt;</span><span class="n">nlink</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">iupdate</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">T_DIR</span><span class="p">){</span>  <span class="c1">// Create . and .. entries.</span>
    <span class="n">dp</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// for ".."</span>
    <span class="n">iupdate</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
    <span class="c1">// No ip-&gt;nlink++ for ".": avoid cyclic ref count.</span>
    <span class="k">if</span><span class="p">(</span><span class="n">dirlink</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="s">"."</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">dirlink</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="s">".."</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">panic</span><span class="p">(</span><span class="s">"create dots"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">dirlink</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"create: dirlink"</span><span class="p">);</span>

  <span class="n">iunlockput</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">ip</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">sys_open</code>有两种模式，当<code class="language-plaintext highlighter-rouge">O_CREATE</code>flag置1时调用了<code class="language-plaintext highlighter-rouge">create</code>，当置0时调用了<code class="language-plaintext highlighter-rouge">namei</code>来找到这个inode，然后调用<code class="language-plaintext highlighter-rouge">filealloc</code>和<code class="language-plaintext highlighter-rouge">fdalloc</code>来分配<code class="language-plaintext highlighter-rouge">struct file</code>和file descriptor。</p><h2 id="1110-real-world">11.10 Real world</h2><p>xv6中的buffer cache采用了一个非常简单的链表来对LRU进行剔除，但是实际的操作系统中采用了hash表和heap来进行LRU剔除，且加入了虚拟内存系统来支持memory-mapped文件。</p><p>在目录树中采用了线性扫描disk block的方式进行查找，在disk block较多的情况下会消耗很多时间，因此Windows的NTFS等文件系统将文件夹用balanced tree进行表示，以确保对数事件的查找。</p><p>xv6要求文件系统只能有一个硬盘设备，但是现代操作系统可以采用RAID或者软件的方式来将很多硬盘组成一个逻辑盘</p><p>现代操作系统还应该具备的其他特性：snapshots、增量式备份。</p><h1 id="lecture-12-crash-recovery">Lecture 12 Crash recovery</h1><h2 id="121-logging-layer">12.1 Logging layer</h2><p>由于很多对文件系统的操作都涉及了对硬盘的多次写入，当某次写入后发生崩溃将导致文件系统出现问题。xv6通过logging来解决这个问题，xv6的syscall不会直接对硬盘上的block进行写入，而是将所有想要进行的对硬盘的写入操作的描述放到log中，当syscall将所有的写入操作都放到log后向硬盘写入一个<em>commit</em>记录来表示这个log已经记录了所有的操作，然后syscall进行全部的写入操作，并将硬盘上的log全部清除。</p><p>当操作系统崩溃后进行重启，将在进行任何进程之前从崩溃中恢复。如果在对硬盘的所有写入操作commit之前发生了崩溃，那么这个log将被视为不完整的log，xv6将直接忽略这个log，如果崩溃发生在commit之后，说明这个log是完整的，则恢复系统将重复这些步骤，最后删除log。</p><h2 id="122-log-design">12.2 Log design</h2><p>log位于硬盘上的log block中，由一个header block和后面的一系列被log的block的copy组成。header block中记录了所有被log的block的blockno和log block的总数<code class="language-plaintext highlighter-rouge">count</code>。xv6只有在一个transaction commits时才向header block写入，并在将logged block copy写入到文件系统中的logged block后将<code class="language-plaintext highlighter-rouge">count</code>归零。</p><p>为了支持不同的进程对文件系统同时的操作，可以将多个syscall对硬盘的写入打包到一个transaction当中，因此commit必须保证当前没有syscall</p><p><em>group commit</em>可以将多个不同进程的syscall的transaction放在一起进行commit。</p><p>由于log block有数量限制，因此一个syscall能够写入的block数量也同样有限制，比如<code class="language-plaintext highlighter-rouge">sys_write</code>将一个write分成了好几个transaction以fit log。</p><ul><li><em>write ahead</em>规则：只有所有被修改的buffer都被写入到了log block才能开始向文件系统中的home location写入block<li><em>freeing</em>规则：直到所有的log block都被写入了home location，并且消除了header block，才能开始修改或者释放log block</ul><h2 id="123-code-logging">12.3 Code: logging</h2><p>在syscall中对log使用的典型流程：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>begin_op();
...
bp = bread();
bp-&gt;data = ...;
log_write(bp);
...
end_op();
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">begin_op</code>将等待直到当前logging系统不再committing且有足够的空余log block能够容纳这次syscall中所有的写入，<code class="language-plaintext highlighter-rouge">log.outstanding</code>是需要进行block写入但是还没有调用<code class="language-plaintext highlighter-rouge">log_write</code>的syscall的个数，因此也记录了目前预定了log space的syscall的个数，<code class="language-plaintext highlighter-rouge">MAXOPBLOCKS</code>是一个syscall最高可以使用的log block</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1">// called at the start of each FS system call.</span>
<span class="kt">void</span>
<span class="nf">begin_op</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
  <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">committing</span><span class="p">){</span>
      <span class="n">sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span> <span class="o">+</span> <span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">outstanding</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">MAXOPBLOCKS</span> <span class="o">&gt;</span> <span class="n">LOGSIZE</span><span class="p">){</span>
      <span class="c1">// this op might exhaust log space; wait for commit.</span>
      <span class="n">sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">log</span><span class="p">.</span><span class="n">outstanding</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">log_write</code>在完成对<code class="language-plaintext highlighter-rouge">buf</code>的修改之后，需要实现<code class="language-plaintext highlighter-rouge">bwrite</code>的功能，但是先要在log block中给传入的这个<code class="language-plaintext highlighter-rouge">buf</code>预留一个位子，并且将这个<code class="language-plaintext highlighter-rouge">buf</code>pin在buffer cache中（此时这个传入的<code class="language-plaintext highlighter-rouge">buf</code>还没有被写入log block中，因此它还是修改后的block的唯一拷贝，因此不能让其在buffer cache中被evict掉）。当一个transaction中对同一个block进行了多次读写操作时，不会另外预留log block，这叫做<em>log absorption</em>。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="c1">// Caller has modified b-&gt;data and is done with the buffer.</span>
<span class="c1">// Record the block number and pin in the cache by increasing refcnt.</span>
<span class="c1">// commit()/write_log() will do the disk write.</span>
<span class="c1">//</span>
<span class="c1">// log_write() replaces bwrite(); a typical use is:</span>
<span class="c1">//   bp = bread(...)</span>
<span class="c1">//   modify bp-&gt;data[]</span>
<span class="c1">//   log_write(bp)</span>
<span class="c1">//   brelse(bp)</span>
<span class="kt">void</span>
<span class="nf">log_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">LOGSIZE</span> <span class="o">||</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">log</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"too big a transaction"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">outstanding</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"log_write outside of trans"</span><span class="p">);</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span><span class="p">)</span>   <span class="c1">// log absorbtion</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Add new block to log?</span>
    <span class="n">bpin</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">end_op</code>先要减少outstanding syscall的数量，如果该数量被减为了0（即所有的syscall都已经完成了<code class="language-plaintext highlighter-rouge">log_write</code>），则调用<code class="language-plaintext highlighter-rouge">commit()</code>来将当前的transaction commit掉。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="c1">// called at the end of each FS system call.</span>
<span class="c1">// commits if this was the last outstanding operation.</span>
<span class="kt">void</span>
<span class="nf">end_op</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">do_commit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">log</span><span class="p">.</span><span class="n">outstanding</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">committing</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"log.committing"</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">outstanding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
    <span class="n">do_commit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">log</span><span class="p">.</span><span class="n">committing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// begin_op() may be waiting for log space,</span>
    <span class="c1">// and decrementing log.outstanding has decreased</span>
    <span class="c1">// the amount of reserved space.</span>
    <span class="n">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="n">do_commit</span><span class="p">){</span>
    <span class="c1">// call commit w/o holding locks, since not allowed</span>
    <span class="c1">// to sleep with locks.</span>
    <span class="n">commit</span><span class="p">();</span>
    <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
    <span class="n">log</span><span class="p">.</span><span class="n">committing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">);</span>
    <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">commit</code>分成四个阶段</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="nf">commit</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">write_log</span><span class="p">();</span>     <span class="c1">// Write modified blocks from cache to log</span>
    <span class="n">write_head</span><span class="p">();</span>    <span class="c1">// Write header to disk -- the real commit</span>
    <span class="n">install_trans</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// Now install writes to home locations</span>
    <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">write_head</span><span class="p">();</span>    <span class="c1">// Erase the transaction from the log</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li><code class="language-plaintext highlighter-rouge">write_log</code>将所有被修改了的block(<code class="language-plaintext highlighter-rouge">buf</code>)写入到log block中</ol><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// Copy modified blocks from cache to log.</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">write_log</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">tail</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tail</span> <span class="o">&lt;</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">;</span> <span class="n">tail</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="n">bread</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">log</span><span class="p">.</span><span class="n">start</span><span class="o">+</span><span class="n">tail</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// log block</span>
    <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">from</span> <span class="o">=</span> <span class="n">bread</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="n">tail</span><span class="p">]);</span> <span class="c1">// cache block</span>
    <span class="n">memmove</span><span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">BSIZE</span><span class="p">);</span>
    <span class="n">bwrite</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>  <span class="c1">// write the log</span>
    <span class="n">brelse</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
    <span class="n">brelse</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li><code class="language-plaintext highlighter-rouge">write_head</code>将header block写入到硬盘中，其中包括log block的总数<code class="language-plaintext highlighter-rouge">log.lh.n</code>和每个log block接下来需要写入到的data block的blockno，这是一个commit真正开始的节点。</ol><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// Write in-memory log header to disk.</span>
<span class="c1">// This is the true point at which the</span>
<span class="c1">// current transaction commits.</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">write_head</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">bread</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">log</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
  <span class="k">struct</span> <span class="n">logheader</span> <span class="o">*</span><span class="n">hb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">logheader</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">hb</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">=</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">hb</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="n">bwrite</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">brelse</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li><code class="language-plaintext highlighter-rouge">install_trans</code>将log block写入到需要写入的home data block中</ol><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// Copy committed blocks from log to their home location</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">install_trans</span><span class="p">(</span><span class="kt">int</span> <span class="n">recovering</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">tail</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tail</span> <span class="o">&lt;</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">;</span> <span class="n">tail</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">lbuf</span> <span class="o">=</span> <span class="n">bread</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">log</span><span class="p">.</span><span class="n">start</span><span class="o">+</span><span class="n">tail</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// read log block</span>
    <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">dbuf</span> <span class="o">=</span> <span class="n">bread</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="n">tail</span><span class="p">]);</span> <span class="c1">// read dst</span>
    <span class="n">memmove</span><span class="p">(</span><span class="n">dbuf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">lbuf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">BSIZE</span><span class="p">);</span>  <span class="c1">// copy block to dst</span>
    <span class="n">bwrite</span><span class="p">(</span><span class="n">dbuf</span><span class="p">);</span>  <span class="c1">// write dst to disk</span>
    <span class="k">if</span><span class="p">(</span><span class="n">recovering</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">bunpin</span><span class="p">(</span><span class="n">dbuf</span><span class="p">);</span>
    <span class="n">brelse</span><span class="p">(</span><span class="n">lbuf</span><span class="p">);</span>
    <span class="n">brelse</span><span class="p">(</span><span class="n">dbuf</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li>最后将log header中的count变为0</ol><p><code class="language-plaintext highlighter-rouge">recover_from_log</code>在<code class="language-plaintext highlighter-rouge">initlog</code>中被调用，每次操作系统重启之前都将调用一次。它调用<code class="language-plaintext highlighter-rouge">install_trans(1)</code>，当<code class="language-plaintext highlighter-rouge">log.ln.n</code>不为0时将重新进行一次将log block写入到data block中。</p><h2 id="124-lab-9-file-system">12.4 Lab 9: file system</h2><ol><li>Large files</ol><p>实验要求：增大xv6文件的最大大小，由于原来的大小是12个DIRECT BLOCK+256个INDIRECT BLOCK，现在要将一个DIRECT BLOCK变为一个DOUBLE INDIRECT BLOCK，即像page table一样的双层结构，从而使得一个文件的大小最高位256*256+256+11=65803 bytes。</p><p>修改<code class="language-plaintext highlighter-rouge">kernel/fs.h</code>中的宏定义</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="cp">#define NDIRECT 11
#define NINDIRECT (BSIZE / sizeof(uint))
#define NDBINDIRECT ((BSIZE / sizeof(uint)) * (BSIZE / sizeof(uint)))
#define MAXFILE (NDIRECT + NINDIRECT + NDBINDIRECT)
</span></pre></table></code></div></div><p>并修改<code class="language-plaintext highlighter-rouge">fs.h</code>和<code class="language-plaintext highlighter-rouge">file.h</code>中的<code class="language-plaintext highlighter-rouge">struct inode</code>中的<code class="language-plaintext highlighter-rouge">addrs</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">uint</span> <span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</pre></table></code></div></div><p>修改<code class="language-plaintext highlighter-rouge">kernel/fs.c</code>中的<code class="language-plaintext highlighter-rouge">bmap</code>，增加<code class="language-plaintext highlighter-rouge">bn&lt;NDBINDIRECT</code>情况下的两级映射。先要让bn减掉上一级的<code class="language-plaintext highlighter-rouge">NINDIRECT</code>，DOUBLE INDIRECT BLOCK映射的第一级index应为<code class="language-plaintext highlighter-rouge">bn/NINDIRECT</code>，第二级index为<code class="language-plaintext highlighter-rouge">bn%NINDIRECT</code>。依次读取每一级block中的addr (blockno)，当不存在时进行<code class="language-plaintext highlighter-rouge">balloc</code>。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="n">bn</span> <span class="o">-=</span> <span class="n">NINDIRECT</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">bn</span> <span class="o">&lt;</span> <span class="n">NDBINDIRECT</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uint</span> <span class="n">index_1</span> <span class="o">=</span> <span class="n">bn</span><span class="o">/</span><span class="n">NINDIRECT</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">index_2</span> <span class="o">=</span> <span class="n">bn</span><span class="o">%</span><span class="n">NINDIRECT</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">addr</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ip</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">balloc</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
    <span class="n">bp</span> <span class="o">=</span> <span class="n">bread</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint</span><span class="o">*</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">addr</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">index_1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">[</span><span class="n">index_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">balloc</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
        <span class="n">log_write</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
    <span class="n">bp</span> <span class="o">=</span> <span class="n">bread</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint</span><span class="o">*</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">addr</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">index_2</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">[</span><span class="n">index_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">balloc</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
        <span class="n">log_write</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">itrunc</code>中，也要释放掉DOUBLE INDIRECT BLOCK中每一级的block</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">bp</span> <span class="o">=</span> <span class="n">bread</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint</span><span class="o">*</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">NINDIRECT</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">bp2</span> <span class="o">=</span> <span class="n">bread</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
            <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint</span><span class="o">*</span><span class="p">)</span><span class="n">bp2</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NINDIRECT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">bfree</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">brelse</span><span class="p">(</span><span class="n">bp2</span><span class="p">);</span>
            <span class="n">bfree</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
    <span class="n">bfree</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">ip</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li>Symbolic links</ol><p>实验要求：实现xv6的软链接，即新增加一种<code class="language-plaintext highlighter-rouge">T_SYMLINK</code>类型的文件，这个文件中存有需要链接到的文件的pathname，当使用<code class="language-plaintext highlighter-rouge">open</code>并指定<code class="language-plaintext highlighter-rouge">O_NOFOLLOW</code>为0时，可以打开这个软链接文件指向的文件，而非软链接文件本身。要求实现一个<code class="language-plaintext highlighter-rouge">symlink(char *target, char *path)</code>这个syscall，实现<code class="language-plaintext highlighter-rouge">path</code>所代表的文件软链接到<code class="language-plaintext highlighter-rouge">target</code>代表的文件，<code class="language-plaintext highlighter-rouge">target</code>不存在也可以。修改<code class="language-plaintext highlighter-rouge">open</code>，从而可以打开软链接文件。注意：软链接文件指向的文件可能也是一个软链接文件，<code class="language-plaintext highlighter-rouge">open</code>需要递归地找到最终的非软链接文件，但是可能出现软链接文件互相链接的情况，会产生死循环，因此规定递归查找软链接的深度不能超过10.</p><p>首先在<code class="language-plaintext highlighter-rouge">Makefile</code>中添加编译项<code class="language-plaintext highlighter-rouge">$U/_symlinktest\</code>，在<code class="language-plaintext highlighter-rouge">kernel/fcntl.h</code>中添加<code class="language-plaintext highlighter-rouge">open</code>的flag<code class="language-plaintext highlighter-rouge">O_NOFOLLOW</code>，该flag不能和其他flag的位重叠</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#define O_NOFOLLOW 0x010
</span></pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">kernel/stat.h</code>中添加inode类型<code class="language-plaintext highlighter-rouge">T_SYMLINK</code></p><pre><code class="language-C">#define T_SYMLINK 4   // Symlink
</code></pre><p>注册<code class="language-plaintext highlighter-rouge">sys_symlink</code></p><p>在<code class="language-plaintext highlighter-rouge">kernel/syscall.c</code>中</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_symlink</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">[</span><span class="n">SYS_symlink</span><span class="p">]</span> <span class="n">sys_symlink</span><span class="p">,</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">kernel/syscall.h</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#define SYS_symlink 22
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">user/user.h</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">symlink</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">user/usys.pl</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">entry</span><span class="p">(</span><span class="s">"symlink"</span><span class="p">);</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">kernel/sysfile.c</code>中，添加<code class="language-plaintext highlighter-rouge">symlink</code>的实现</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="n">uint64</span>
<span class="nf">sys_symlink</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">target</span><span class="p">[</span><span class="n">MAXPATH</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="n">MAXPATH</span><span class="p">];</span>
  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
  <span class="c1">// char test[MAXPATH];</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argstr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">MAXPATH</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">argstr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">MAXPATH</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">begin_op</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">ip</span> <span class="o">=</span> <span class="n">namei</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// the path inode does not exist</span>
    <span class="n">ip</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">T_SYMLINK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
  <span class="p">}</span> 
  <span class="n">ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
  <span class="c1">// write the target path name into the end of inode</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">writei</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">target</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">MAXPATH</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MAXPATH</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"symlink"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
  <span class="n">end_op</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 
</pre></table></code></div></div><p>首先要判断是否存在<code class="language-plaintext highlighter-rouge">path</code>所代表的inode，如果不存在就用<code class="language-plaintext highlighter-rouge">create</code>添加一个<code class="language-plaintext highlighter-rouge">T_SYMLINK</code>类型的inode。在inode的最后添加需要软链接到的<code class="language-plaintext highlighter-rouge">target</code>的路径名称</p><p>修改<code class="language-plaintext highlighter-rouge">open</code>，添加对<code class="language-plaintext highlighter-rouge">T_SYMLINK</code>类型文件的处理方法</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">T_SYMLINK</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">omode</span> <span class="o">&amp;</span> <span class="n">O_NOFOLLOW</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// recursively follow symlink</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">sympath</span><span class="p">[</span><span class="n">MAXPATH</span><span class="p">];</span>
        <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
                <span class="n">end_op</span><span class="p">();</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// read the path name from inode</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">readi</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">sympath</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">-</span><span class="n">MAXPATH</span><span class="p">,</span> <span class="n">MAXPATH</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MAXPATH</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">panic</span><span class="p">(</span><span class="s">"open symlink"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">ip</span> <span class="o">=</span> <span class="n">namei</span><span class="p">(</span><span class="n">sympath</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// could not find this file</span>
                <span class="n">end_op</span><span class="p">();</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">T_SYMLINK</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>要判断打开<code class="language-plaintext highlighter-rouge">open</code>的flag是否为<code class="language-plaintext highlighter-rouge">NOFOLLOW</code>，如果是的话，就不打开软链接所指向的文件，否则需要将inode递归地替换为软链接指向的文件，直到最终的inode类型不是<code class="language-plaintext highlighter-rouge">T_SYMLINK</code>为止。整个递归的深度不能超过10，否则报错。</p><h1 id="lecture-13-linux-ext3fs-crash-recovery">Lecture 13 Linux ext3fs crash recovery</h1><p>xv6 logging系统的问题：速度太慢，每个block需要被写入磁盘2次（一次到log中一次到fs中），每个syscall需要等待commit完成，磁盘的I/O是同步阻塞的。</p><h2 id="131-ext3-journal-design">13.1 ext3 journal design</h2><p>和xv6不同的是ext3可以跟踪多个transaction的状态。</p><p>在ext3的内存中和xv6一样有write-back block cache，也为每个transaction维护了一个transaction info，这些transaction info包括：</p><ol><li>每个transaction有一个sequence number<li>被这个transaction修改的block no<li>handles：这个transaction中的syscall</ol><p>在硬盘上有circular log，log包括：</p><ol><li>log super block（注意和整个硬盘的super block是不一样的）：记录了seq#最低的有效的transaction的offset和seq #<li>descriptor block：每一个transaction开头的block，记录了这个transaction的seq #和home block #，有MAGIC #（为了和data block进行区分）<li>data block<li>commit block：每个transaction结尾的block，有MAGIC #</ol><p>当log空间全部满了或者等待时间足够长时，将从最小的seq# transaction开始将log block写入到home disk中，并释放掉这一个transaction所占据的log block，因此这实际上是一个circular log。</p><p><strong>commit transaction的步骤</strong></p><ol><li>暂时禁用新的syscall<li>等待outstanding syscall结束，因为一个transaction是每隔一段时间就close的，这个时间节点上已经调用了<code class="language-plaintext highlighter-rouge">start()</code>的syscall很可能还没有调用<code class="language-plaintext highlighter-rouge">end()</code>，需要等待所有的这些syscall结束<li>开始一个新的transaction, unblock新的syscall<li>向这个transaction的descriptor block写入需要写入的block#<li>向log写入这些需要写入的data block<li>写入commit block，当commit block写入完成，这就是commit point，这之后如果崩溃，Log中的内容将得到恢复<li>向home location写入block<li>释放/重新使用这个transaction中的log block</ol><p><strong>恢复的步骤</strong></p><p>SB T8 (freed)T5 T6 T7</p><p>SB指向T6，T5已经被释放了，而T8已经覆盖了T5的descriptor</p><ol><li>重启后，先查看Super Block，寻找指向的最小的valid seq#的transaction，这里是T6<li>找到log的尾部，将循环查找到一个缺失的commit（通过magic #)或者错误的seq#（太小），若找到这个partial transaction就将其忽略</ol><h2 id="132-ext3-journal-performance">13.2 ext3 journal performance</h2><p>ext3的journaling速度提高的原因：</p><ol><li><p>asynchronous disk update：syscall不用等待disk I/O，而是等待修改了buffer cache就可以进行返回，不同的syscall的log可以放在一起进行统一的commit。缺点是当syscall返回时这个syscall需要完成的对硬盘的写入可能实际上并没有完成。<code class="language-plaintext highlighter-rouge">fsync(fd)</code>可以强迫这个<code class="language-plaintext highlighter-rouge">fd</code>对磁盘的修改已经被写入到log block才会返回</p><li><p>batching：将许多syscall的log放在一个transaction中。ext3每隔数秒钟进行一次commit，所以每个transaction会包含了很多syscall。</p><p>batching的优点：1）将查找block等本来每个syscall都会有的固定开销平摊到多个syscall中。2）允许write absorption，可以让许多对同一个block的写入放在一起。3）disk scheduling：可以将一个batch中所有对block的写入以blockno排序依次写入，比一个一个查找随机位置的block效率更高。</p><li><p>concurrency：1）同时进行多个fs syscall 2) log中可以有多个transaction，每个transaction可以在不同的阶段中，总共有4种阶段，包括：</p><ul><li>open transaction：可以接受新的syscall的写入请求<li>committing transaction：将buf写入到log中<li>committed transaction：将log写入到home block中<li>old transaction：被释放</ul></ol><h2 id="133-ext3-syscall-code">13.3 ext3 syscall code</h2><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">sys_unlink</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">start</span><span class="p">();</span> <span class="c1">// 告知logging system有新的system call, h是handle，即这个syscall的一个identifier</span>
    <span class="n">get</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">blockno</span><span class="p">);</span> <span class="c1">// 告知logging system需要修改cache block，将handle和blockno添加到当前的transaction中</span>
    <span class="c1">// modify the block in the cache</span>
    <span class="n">stop</span><span class="p">(</span><span class="n">h</span><span class="p">);</span> <span class="c1">// 当当前所有的syscall的start()都被stop()之后才能将这个transaction commit</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="134-collision-between-transactions">13.4 Collision between transactions</h2><p>为了提高文件系统的性能，在committing 一个transaction的时候不会完全禁止文件系统的更新，而是会创建一个新的transaction。如果新的transaction需要写入旧的正在committing的transaction的某一个block，可能会造成冲突。当我们在提交旧的transaction时，我们必须保证此时的buffer cache不能被修改，因此我们需要一个这个buffer cache的拷贝来进行新transaction的修改</p><p>ext3 ordered data mode：在普通模式下，需要将metadata和file content都写入到log block中，然后再写入到file system中，需要写入2次，速度很慢，在ordered data mode模式下，只将metadata写入到log中，file content直接写入file system的Home location，需要注意一定要在file content写入完成之后才能将metadata commit，这样当file content写入完成后metadata commit之前发生崩溃的话，恢复系统不会恢复metadata，但是这个file content也会因为metadata中的inode没有被写入而不会暴露给用户。</p><h1 id="lecture-14-virtual-memory-for-user-applications">Lecture 14 Virtual memory for user applications</h1><p>kernel可以通过虚拟内存来获得很多特性，比如copy-on-write、lazy allocation等，user program也可以通过虚拟内存获得一些特性。</p><p>比如：</p><ol><li>Concurrent garbage collector<li>Generation garbage collector<li>Concurrent check-pointing<li>Data-compression paging<li>Persistent stores</ol><p><strong>user-level VM primitive</strong></p><p>trap: 以user mode进入page fault trap并进行处理</p><p>prot: 降低页的访问权限</p><p>e.g. <code class="language-plaintext highlighter-rouge">mprotect(addr, len, PROT_READ)</code>：让被映射的地址addr只能有读权限</p><p>unprot: 提高页的访问权限</p><p>dirty: 返回一个自上一个调用以来已经被使用了的page</p><p>map2: 将同一个physical page map到2个不同的virtual address，设置不同的访问权限</p><h2 id="141-mmap">14.1 mmap</h2><p>将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210218100151333.png" alt="image-20210218100151333" /></p><p>为什么要建立文件磁盘地址和进程虚拟地址空间的映射？因为常规的文件系统操作是用户态发起<code class="language-plaintext highlighter-rouge">read</code>syscall，然后在buffer cache中查找是否有相应的数据，如果没有就从磁盘中拷贝数据到buffer cache中，因为buffer cache处在内核态，因此需要将buffer cache<code class="language-plaintext highlighter-rouge">copyout</code>到用户进程的虚拟内存中，这就需要2次拷贝操作，而在mmap中只需要直接将文件数据拷贝到对应的用户空间虚拟内存即可。</p><p><strong>文件映射</strong></p><p>使用文件内容初始化物理内存</p><p><code class="language-plaintext highlighter-rouge">addr = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, offset)</code> NULL表示让kernel自己查找需要映射到的文件磁盘地址</p><p><strong>匿名映射</strong></p><p>不需要打开文件，初始化一个全为0的内存空间</p><p>私有匿名映射用于<code class="language-plaintext highlighter-rouge">malloc</code>给进程分配虚拟的地址空间，当各个进程读的时候共享物理内存，写的时候copy on write</p><p><code class="language-plaintext highlighter-rouge">mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)</code></p><p>共享匿名映射在进行fork时不会采用写时copy on write，父子进程完全共享同样的物理内存页，实现父子进程的IPC</p><h2 id="142-virtual-memory-implementation">14.2 Virtual memory implementation</h2><p><strong>VMA</strong></p><p>VMA (Virtual Memory Area)由一连串的虚拟地址组成，每个VMA都有相同的权限，指向相同的对象（文件、匿名内存等）</p><p><strong>User-level traps</strong></p><p>比如，当PTE被标记为invalid时发生缺页异常，CPU从用户态陷入内核态</p><p>内核态保存trapframe</p><p>内核将查看产生错误的VMA，判断接下来的动作。比如一个用户进程设置了一个sig_action(handler for signal)，则内核将产生一个signal，将这个signal传播给用户态，回到用户态调用sig_action，然后sig_action将调用mprotect来修改PTE</p><p>最后sig_action将返回kernel，kernel继续返回到被中断的进程。</p><h2 id="143-use-case-garbage-collector">14.3 Use case: Garbage collector</h2><p>为了将程序分配的内存在程序退出之后能够自动清理掉，需要垃圾收集器，其作用是从一个根集合root出发，递归地寻找所有被引用的对象，剩下的所有没有被引用到的对象就是垃圾内存，需要被清除。</p><p>复制算法是将Heap内存空间分为2块区域，一块是from区域一块是to区域，将from区域中的所有能够被root查找到的对象全部复制到to区域中，然后将from区域的所有内存清除掉。这个算法的缺点在于gc线程运行的过程中需要暂停所有的用户线程。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210218163937385.png" alt="image-20210218163937385" /></p><p>Baker实时垃圾收集算法：to区域包括new区域、scanned区域和unscanned区域。在最开始先将root复制到to区域，当用户线程调用<code class="language-plaintext highlighter-rouge">new</code>来分配新的对象时，from区域中被root及其它对象指向的对象会被增量地复制到to区域中。几个规则：</p><ul><li>用户线程只能看到to-space的指针，也就是说每个用户线程取得的对象指向的对象只能在to-space中，如果检查发现在from-space中，就要将这个被指向的对象拷贝到to-space，并且更新指针，然后才能返回给用户线程。<li>每次调用new，被分配的对象放在new区域中，并且new区域中所有的对象的指针都只能指向to区域<li>scanned区域中的对象只能拥有指向to区域的指针，unscanned区域中的对象可以拥有指向to或from区域的指针。</ul><div class="table-wrapper"><table><tbody><tr><td>为了避免检查每个从内存中取回的对象的指针使其满足第一个规则，gc给每个unscanned区域中的对象都加了no access，使得每次试图访问这个unscanned对象时都会陷入缺页保护异常，然后gc扫描这个对象，将其指向的对象拷贝到to区域中，然后再恢复访问权限。这个机制也提供了concurrency，因为可以防止gc thread和用户线程同时修改unscanned page，因为unscanned page已经被加上了none access保护，用户线程是无法访问的。但是由于<strong>map2</strong>的存在，可以将相同的物理地址再映射一个给gc thread，其访问权限是R<td>W，因此用户线程不能访问的unscanned page gc线程是可以访问的。</table></div><h2 id="144-lab-10-mmap">14.4 Lab 10: mmap</h2><p>实验要求：实现<code class="language-plaintext highlighter-rouge">mmap</code>和<code class="language-plaintext highlighter-rouge">munmap</code>来实现将文件直接映射到用户虚拟内存中。<code class="language-plaintext highlighter-rouge">mmap</code>和<code class="language-plaintext highlighter-rouge">munmap</code>的原型函数分别是</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="o">*</span><span class="nf">mmap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">munmap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>
</pre></table></code></div></div><p>将上述声明添加到<code class="language-plaintext highlighter-rouge">user/user.h</code>中。本实验中<code class="language-plaintext highlighter-rouge">addr</code>和<code class="language-plaintext highlighter-rouge">off</code>一直都是0，因此可以不在<code class="language-plaintext highlighter-rouge">sys_mmap</code>传入这两个参数。<code class="language-plaintext highlighter-rouge">length</code>是需要映射的字节数，可能和文件大小不相等，<code class="language-plaintext highlighter-rouge">prot</code>表示映射到的内存的权限为<code class="language-plaintext highlighter-rouge">PROT_READ</code>还是<code class="language-plaintext highlighter-rouge">PROT_WRITE</code>。<code class="language-plaintext highlighter-rouge">flag</code>可以是<code class="language-plaintext highlighter-rouge">MAP_SHARED</code>或<code class="language-plaintext highlighter-rouge">MAP_PRIVATE</code>，如果是前者就需要将内存中修改的相应部分写回文件中。<code class="language-plaintext highlighter-rouge">fd</code>是需要映射的已打开的文件描述符。</p><p>本实验中，两个映射了同一个<code class="language-plaintext highlighter-rouge">MAP_SHARED</code>文件的进程可以不共享物理页（由于进程的内存隔离，要实现这个比较麻烦）</p><p><code class="language-plaintext highlighter-rouge">munmap(addr, length)</code>需要将从<code class="language-plaintext highlighter-rouge">addr</code>开始的<code class="language-plaintext highlighter-rouge">length</code>长度的<code class="language-plaintext highlighter-rouge">mmap</code>全部取消映射，这里的假设是只能从VMA的头部或尾部取消映射，不能对中间部分取消映射。</p><p>实验步骤：</p><p>向<code class="language-plaintext highlighter-rouge">Makefile</code>中添加<code class="language-plaintext highlighter-rouge">$U_mmaptest\</code>，向<code class="language-plaintext highlighter-rouge">kernel/syscall.c</code>中添加</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_mmap</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_munmap</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">[</span><span class="n">SYS_mmap</span><span class="p">]</span>    <span class="n">sys_mmap</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_munmap</span><span class="p">]</span>  <span class="n">sys_munmap</span><span class="p">,</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">kernel/syscall.h</code>中添加</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#define SYS_mmap   22
#define SYS_munmap 23
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">user/usys.pl</code>添加</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">entry</span><span class="p">(</span><span class="s">"mmap"</span><span class="p">);</span>
<span class="n">entry</span><span class="p">(</span><span class="s">"munmap"</span><span class="p">);</span>
</pre></table></code></div></div><p>完成对<code class="language-plaintext highlighter-rouge">mmap</code>和<code class="language-plaintext highlighter-rouge">mumap</code>的注册</p><p>在<code class="language-plaintext highlighter-rouge">kernel/proc.h</code>中添加对<code class="language-plaintext highlighter-rouge">vma</code>结构体的定义，每个进程中最多可以有16个VMA。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#define MAXVMA 16
</span><span class="k">struct</span> <span class="n">vma</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">valid</span><span class="p">;</span>                <span class="c1">// whether the vma is valid</span>
  <span class="n">uint64</span> <span class="n">addr</span><span class="p">;</span>              <span class="c1">// starting virtual address of vma</span>
  <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>                  <span class="c1">// length of vma, unit: bytes</span>
  <span class="kt">int</span> <span class="n">prot</span><span class="p">;</span>                 <span class="c1">// permission</span>
  <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>                <span class="c1">// flag</span>
  <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>           <span class="c1">// pointer to mapped file</span>
  <span class="kt">int</span> <span class="n">off</span><span class="p">;</span>                  <span class="c1">// offset of the valid mapped address</span>
  <span class="kt">int</span> <span class="n">valid_len</span><span class="p">;</span>            <span class="c1">// length of the valid mapped address</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">vma</span> <span class="n">procvma</span><span class="p">[</span><span class="n">MAXVMA</span><span class="p">];</span> <span class="c1">// process vma</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">kernel/sysfile.c</code>中添加注册<code class="language-plaintext highlighter-rouge">sys_mmap</code>，在<code class="language-plaintext highlighter-rouge">mmap</code>中先不要分配物理内存，只是完成对<code class="language-plaintext highlighter-rouge">vma</code>结构体的写入。找到新的空闲内存地址<code class="language-plaintext highlighter-rouge">p-&gt;sz</code>作为<code class="language-plaintext highlighter-rouge">vma</code>返回的地址并<code class="language-plaintext highlighter-rouge">p-&gt;sz+=len</code>，让后面需要使用这个返回的内存地址时陷入缺页异常，在trap中再分配物理内存完成lazy allocation</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="n">uint64</span>
<span class="nf">sys_mmap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">fd</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">argint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prot</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">argint</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">argfd</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">writable</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_SHARED</span><span class="p">))</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// to assert that readonly file could not be opened with PROT_WRITE &amp;&amp; MAP_SHARED flags</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>
  <span class="k">struct</span> <span class="n">vma</span> <span class="o">*</span><span class="n">pvma</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">procvma</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAXVMA</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">valid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">;</span>
      <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">f</span> <span class="o">=</span> <span class="n">filedup</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>  <span class="c1">// increment the refcount for f</span>
      <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
      <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">PGROUNDUP</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
      <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prot</span> <span class="o">=</span> <span class="n">prot</span><span class="p">;</span>
      <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">valid_len</span> <span class="o">=</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
      <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span> <span class="o">+=</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">kernel/trap.c</code>中添加lazy allocation</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre>  <span class="err">}</span> <span class="k">else</span> <span class="nf">if</span><span class="p">((</span><span class="n">which_dev</span> <span class="o">=</span> <span class="n">devintr</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
    <span class="c1">// ok</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">r_scause</span><span class="p">()</span> <span class="o">==</span> <span class="mi">13</span> <span class="o">||</span> <span class="n">r_scause</span><span class="p">()</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uint64</span> <span class="n">va</span> <span class="o">=</span> <span class="n">r_stval</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">va</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">||</span> <span class="n">va</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">goto</span> <span class="n">exception</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">struct</span> <span class="n">vma</span> <span class="o">*</span><span class="n">pvma</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">procvma</span><span class="p">;</span>
    <span class="n">va</span> <span class="o">=</span> <span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAXVMA</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">valid</span> <span class="o">&amp;&amp;</span> <span class="n">va</span> <span class="o">&gt;=</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">+</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">off</span> <span class="o">&amp;&amp;</span> <span class="n">va</span> <span class="o">&lt;</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">+</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">off</span> <span class="o">+</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">valid_len</span><span class="p">)</span> <span class="p">{</span>  
        <span class="c1">// allocate one page in the physical memory</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="n">kalloc</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">goto</span> <span class="n">exception</span><span class="p">;</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prot</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_U</span><span class="p">;</span> <span class="c1">// PTE_R == 2 and PROT_READ == 1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mappages</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">mem</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">kfree</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
          <span class="k">goto</span> <span class="n">exception</span><span class="p">;</span>
        <span class="p">}</span>   
        <span class="kt">int</span> <span class="n">off</span> <span class="o">=</span> <span class="n">va</span> <span class="o">-</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">;</span>
        <span class="n">ilock</span><span class="p">(</span><span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
        <span class="n">readi</span><span class="p">(</span><span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
        <span class="n">iunlock</span><span class="p">(</span><span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nl">exception:</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"usertrap(): unexpected scause %p pid=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">r_scause</span><span class="p">(),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"            sepc=%p stval=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">r_sepc</span><span class="p">(),</span> <span class="n">r_stval</span><span class="p">());</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></table></code></div></div><p>需要判断page fault的地址是合理的，如果fault的地址低于了当前进程的栈底(<code class="language-plaintext highlighter-rouge">p-&gt;trapframe-&gt;sp</code>)或者高于等于当前进程的堆顶(<code class="language-plaintext highlighter-rouge">p-&gt;sz</code>)就说明是不合理的，需要进入exception。然后判断当前fault的地址是在哪一个VMA的合法范围中，找到这个VMA后分配一页物理页，并用<code class="language-plaintext highlighter-rouge">mappages</code>将这一页物理页映射到fault的用户内存中，然后用<code class="language-plaintext highlighter-rouge">readi</code>打开需要映射的文件，将对应的文件内容用<code class="language-plaintext highlighter-rouge">readi</code>放入这一页内存中去。</p><p>实现<code class="language-plaintext highlighter-rouge">munmap</code></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="n">sys_munmap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">uint64</span> <span class="n">addr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argaddr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">argint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>
  <span class="k">struct</span> <span class="n">vma</span> <span class="o">*</span><span class="n">pvma</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">procvma</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">close</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// find the corresponding vma</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAXVA</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">valid</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">+</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">addr</span> <span class="o">=</span> <span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">+</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">off</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// starting at begin of the valid address of vma</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">valid_len</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// whole vma is unmmaped</span>
          <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">length</span> <span class="o">=</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">valid_len</span><span class="p">;</span>
          <span class="n">close</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span> <span class="o">-=</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">off</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
          <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">valid_len</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// starting at middle, should unmap until the end</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">+</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">off</span> <span class="o">+</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">valid_len</span> <span class="o">-</span> <span class="n">addr</span><span class="p">;</span>
        <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">valid_len</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_SHARED</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// write the page back to the file</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_filewrite</span><span class="p">(</span><span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">f</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">addr</span> <span class="o">-</span> <span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> 
      <span class="p">}</span>
      <span class="n">uvmunmap</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">PGROUNDUP</span><span class="p">(</span><span class="n">length</span><span class="p">)</span><span class="o">/</span><span class="n">PGSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">close</span><span class="p">)</span> <span class="n">fileclose</span><span class="p">(</span><span class="n">pvma</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">f</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> 
</pre></table></code></div></div><p>首先需要找到对应的vma，然后根据unmap的大小和起点的不同进行讨论。如果是从vma有效部分的起点开始，当整个vma都被unmap掉时，需要标记这个打开的文件被关闭（但是现在还不能关闭，因为后面可能需要写回硬盘中的文件），将当前的vma设置为invalid，减小<code class="language-plaintext highlighter-rouge">p-&gt;sz</code>（这一部分可能有点问题，因为如果是unmap中间的vma的话不需要减小<code class="language-plaintext highlighter-rouge">p-&gt;sz</code>，但是本实验中是可以通过测试的）。如果只是部分vma被unmap，则修改vma的<code class="language-plaintext highlighter-rouge">off</code>和<code class="language-plaintext highlighter-rouge">valid_len</code>，如果是从中间部分开始被unmap一直到结尾，则不需要修改<code class="language-plaintext highlighter-rouge">off</code>，只需要修改<code class="language-plaintext highlighter-rouge">valid_len</code>和需要被<code class="language-plaintext highlighter-rouge">uvmunmap</code>的<code class="language-plaintext highlighter-rouge">length</code>。然后判断是否是<code class="language-plaintext highlighter-rouge">MAP_SHARED</code>，如果是就用<code class="language-plaintext highlighter-rouge">_filewrite</code>写回原文件，这里是对<code class="language-plaintext highlighter-rouge">filewrite</code>函数进行了修改，使其能够从某个offset开始写</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="kt">int</span>
<span class="nf">_filewrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">uint</span> <span class="n">off</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">writable</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">FD_PIPE</span><span class="p">){</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">pipewrite</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">FD_DEVICE</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">&gt;=</span> <span class="n">NDEV</span> <span class="o">||</span> <span class="o">!</span><span class="n">devsw</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">].</span><span class="n">write</span><span class="p">)</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">devsw</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">].</span><span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">FD_INODE</span><span class="p">){</span>
    <span class="c1">// write a few blocks at a time to avoid exceeding</span>
    <span class="c1">// the maximum log transaction size, including</span>
    <span class="c1">// i-node, indirect block, allocation blocks,</span>
    <span class="c1">// and 2 blocks of slop for non-aligned writes.</span>
    <span class="c1">// this really belongs lower down, since writei()</span>
    <span class="c1">// might be writing a device like the console.</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="p">((</span><span class="n">MAXOPBLOCKS</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">BSIZE</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">){</span>
      <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="n">n1</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>

      <span class="n">begin_op</span><span class="p">();</span>
      <span class="n">ilock</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">writei</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">n1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">off</span> <span class="o">+=</span> <span class="n">r</span><span class="p">;</span>
      <span class="n">iunlock</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
      <span class="n">end_op</span><span class="p">();</span>

      <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">n1</span><span class="p">){</span>
        <span class="c1">// error from writei</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">i</span> <span class="o">+=</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ret = (i == n ? n : -1);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"filewrite"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最后<code class="language-plaintext highlighter-rouge">uvmunmap</code>掉这个vma中对应的虚拟内存（这里释不释放物理内存都可以通过测试），如果需要关闭文件就调用<code class="language-plaintext highlighter-rouge">fileclose</code>。</p><p>最后，由于<code class="language-plaintext highlighter-rouge">p-&gt;sz</code>以内的内存不是都有对应的映射，因此可能会造成<code class="language-plaintext highlighter-rouge">uvmunmap</code>和<code class="language-plaintext highlighter-rouge">uvmcopy</code>出现panic。直接将对应的panic注释掉并continue就可以</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// uvmunmap</span>
<span class="c1">// if((*pte &amp; PTE_V) == 0)</span>
      <span class="c1">// panic("uvmunmap: not mapped");</span>

<span class="c1">// uvmcopy</span>
    <span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">panic</span><span class="p">(</span><span class="s">"uvmcopy: page not present"</span><span class="p">);</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="c1">//  panic("uvmcopy: page not present");</span>
</pre></table></code></div></div><p>测试过程中发现<code class="language-plaintext highlighter-rouge">kfree</code>中似乎会试图杀掉0这个物理内存，没有搞明白是在哪里杀的，因此直接修改<code class="language-plaintext highlighter-rouge">kfree</code>，当<code class="language-plaintext highlighter-rouge">pa==0</code>时直接return避免panic</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">kfree</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pa</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pa</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(((</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span> <span class="o">%</span> <span class="n">PGSIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">||</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span> <span class="o">&gt;=</span> <span class="n">PHYSTOP</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"kfree"</span><span class="p">);</span> 
</pre></table></code></div></div><h1 id="lecture-15-os-organization-microkernel">Lecture 15 OS Organization, microkernel</h1><p>kernel应该做的工作到底是什么？</p><h2 id="151-monolithic-kernel">15.1 Monolithic kernel</h2><p>传统的方法是monolithic kernel：比如Linux、xv6，mono kernel是一个很大的single program。这些kernel为user program提供了很高程度的抽象，比如将硬盘中的数据抽象为了文件描述符，因此提高了很高的移植性。monolithic kernel也提供了资源管理从而实现进程安全，并更有效率地分配资源。这些功能导致mono kernel体积会比较大。kernel是一个很大的程序，可以让kernel下面的子系统（比如内存管理、文件系统等）很容易互相访问，所有的kernel code有很高的权限，因此没有内部的安全限制。</p><p>mono kernel的缺点：太过大，太复杂。很多设计都是写死的，没有很强的扩展性，比如可能想要<code class="language-plaintext highlighter-rouge">wait</code>除了子进程之外的其他进程</p><h2 id="152-micro-kernel">15.2 Micro kernel</h2><p>很小的kernel，只提供IPC（进程间通信）和thread/task，而文件系统、网络驱动、paging等功能都作为user process建立在这个kernel之上</p><p>micro kernel可能由于体积小而更好维护，更安全，有更高的扩展性</p><h2 id="153-l4">15.3 L4</h2><p>一种非常有代表性的micro kernel，强调精简性，只有7个syscall。L4 kernel提供的支持包括：task (相当于process，每个task可以分为多个thread，也有自己的address space)、IPC</p><p><strong>L4 syscalls</strong></p><ul><li>新建一个task<li>新建/销毁task中的thread<li>通过IPC收发消息<li>将内存物理页映射到另一个task中的address space，另一个task必须同意，这是通过IPC实现的<li>priviledged task可以将device register直接映射到自己的地址空间中从而实现对设备的直接访问<li>设备通过IPC向设备驱动进程发送中断</ul><p>L4切换task的方式和xv6基本相同，即选择一个<code class="language-plaintext highlighter-rouge">RUNNABLE</code>的thread，将原来thread的寄存器保存并恢复新的thread的寄存器，切换page table并跳到新的task</p><p><strong>Pager</strong></p><p>L4中有一个专门的pager task。当一个user task发生了page fault陷入了kernel中，kernel会将这个page fault以及产生page fault的thread #转化为IPC信号传给pager task，pager task会根据信号来进行相应的动作，比如lazy allocation等</p><h2 id="154-l4-performance">15.4 L4 performance</h2><p>micro kernel需要进行大量的IPC，在早期的设计中IPC需要消耗大量资源。早期IPC设计：</p><p>P1如果要向P2发送IPC，调用<code class="language-plaintext highlighter-rouge">send(ID, MSG)</code>来指定dst thread和message，然后将消息放到kernel的TX buffer中等待发送，然后yield CPU给P2。kernel读取TX buffer的msg，将消息复制给P2的RX buffer，P2调用<code class="language-plaintext highlighter-rouge">recv(MSG)</code>来将kernel中的消息复制到自己的内存中。在kernel和user space中之间来回穿越需要切换Page table，并且yield CPU切换task也需要切换寄存器上下文，速度比较慢。</p><p>改进的IPC设计：同步、无缓存。P1调用<code class="language-plaintext highlighter-rouge">send()</code>，并等待P2调用<code class="language-plaintext highlighter-rouge">recv()</code>。待同步完成之后直接跳转到P2，就像从<code class="language-plaintext highlighter-rouge">recv()</code>返回一样。如果MSG非常小，可以直接将其放在某一个指定的寄存器中，kernel将保证在跳转过程中这个寄存器的值不会被改变，因此跳转到P2后可以直接读取这个寄存器中的值，而不需要复制内存。如果MSG比较大，就将相应MSG的page mapping发送给P2，同样不需要复制内存。</p><h2 id="155-l4linux">15.5 L4/Linux</h2><p>为了让L4可以和Linux兼容，采用了一种Linux kernel作为一个L4 user process运行于L4 kernel之上的架构，每个Linux process对应一个L4 task，每个process试图调用Linux syscall时，先通过L4 IPC链接到linux kernel，然后让Linux kernel调用syscall并进行返回。Linux kernel只是在最底层（比如对硬件的访问）被修改，它实际上变成了一个很大的server task。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210221122852975.png" alt="image-20210221122852975" /></p><p><strong>L4/Linux fork()流程</strong></p><ol><li>P1进程（其实是一个L4 task）调用<code class="language-plaintext highlighter-rouge">fork()</code><li>P1进程的libc库将<code class="language-plaintext highlighter-rouge">fork()</code>翻译为一个对Linux server的IPC syscall<li>Linux server调用L4创建task和thread的syscall，新建了一个新的task P2<li>Linux server为P2分配内存页<li>Linux server用IPC告诉L4让其将分配好的内存页映射到P2的page table<li>Linux server将P1的内存页数据复制到P2中<li>Linux server发送特殊的IPC，其中包含SP和PC，从而让P2开始运行<li>Linux server通过IPC回复P1（成功或失败代码）</ol><p>因此Linux server实际上是所有L4 task的pager task</p><p>L4/Linux的性能大约是native Linux的50%（因为所有的syscall都要先通过L4再到Linux server，实际上相当于一个syscall变成2个）</p><p>L4微内核被广泛应用于嵌入式处理器，同时这个O/S server架构也被应用到了虚拟机中。</p><h1 id="lecture-16-virtual-machine">Lecture 16 Virtual Machine</h1><h2 id="161-virtual-machine">16.1 Virtual Machine</h2><p>对计算机的仿真，在VM上可以运行多个OS，就像qemu一样</p><p>VMM: virtual machine monitor</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210222101056498.png" alt="image-20210222101056498" /></p><p>VMM可以是stand-alone，也可以运行在host-OS中，比如Linux系统。VM通常会提供比进程更强的隔离性。VM的目标：让guest OS无法区分现在是运行在VM上还是真正的机器上；guest OS无法从其运行的VM上逃离。但是实际上现在很多虚拟机并不能做到让guest OS无法区分</p><p>一种较慢的VM实现方式：VMM将每个guest OS的指令进行翻译再进行执行</p><p>可以将guest OS的指令直接运行在真正的CPU上，但是如果guest kernel运行了一些privileged指令，为了安全性考虑不能直接把supervisor寄存器的访问权限给guest kernel，因此需要在user mode下运行guest kernel，当guest kernel试图运行privileged指令时将陷入VMM的trap，VMM的trap handler将检查并模拟privileged instruction，比如将指令应用于virtual state或者真正的hardware上（比如修改satp）。VMM将给每个guestOS维护一个virtual state，里面包括了寄存器、satp、mode、RAM等信息，实际上都在VMM内存中。RISC-V还需要知道当前的guest OS是在guest user mode还是在guest kernel mode中。</p><p><strong>Guest OS page table</strong></p><p>当guest kernel希望写入satp来改变page table时，VMM不能让其直接写入因为VMM必须确认guest OS只能访问自己的内存</p><p>每个guest OS page table都维护了一个从guest va到guest pa的映射，但是guest pa并不是真正的物理内存，VMM还需要维护一个guest pa到host pa，也就是真正的物理内存的映射，再根据这两个映射的结合，形成一个从guest va到host pa的<em>shadow page table</em>，将这个shadow page table写入到satp中</p><p><strong>Simulate devices</strong></p><ol><li>拦截对映射到内存的设备控制寄存器的读写行为，这是通过将相应的内存地址设置为invalid实现的。当guest OS访问这些寄存器时，将陷入page fault，VMM的trap handler再根据指令对真实的设备进行操作<li>也可以采用虚拟设备，guest OS需要知道它运行在VM中。e.g. xv6的virtio_disk.c提供了一系列的函数，qemu将其转化为对fs.img的读写。<li>也可以直接将物理设备的访问提供给guest OS，这需要设备硬件支持</ol><h2 id="162-hw-support-for-virtual-machine">16.2 HW support for Virtual Machine</h2><p>x86提供了VT-x：硬件支持的虚拟化，能够让guest OS直接执行privileged指令而不用进入trap，因此速度更快</p><p>VT-x硬件拥有2套寄存器组，一套给VMM在root-mode下使用，另外一套给guest OS在non root mode下使用，可以让guest kernel对这一套寄存器组进行读写操作，但是VT-x限制了一些non root mode的操作从而防止其从VM中逃离。</p><p><strong>VT-x page table</strong></p><p>VMM为每个guest OS都维护了一个EPT(extended page table)，当guest kernel向non-root下的satp写入PTE时（而不会陷入trap），VMM将再通过这个EPT再进行1次映射，从而保证guest OS不能修改真正的physical address</p><h2 id="163-dune">16.3 Dune</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210222202127043.png" alt="image-20210222202127043" /></p><p>Dune是一个<em>loadable kernel module for Linux</em>，可以作为Linux kernel的一个模块，Dune必须在VT-x硬件设备上运行，一个普通的进程可以切换为Dune进程，这样Dune就像一个VMM，而这个普通的进程将拥有自己的寄存器组，也可以分为user mode和supervisor mode。Dune进程可以通过VMCALL来调用Linux syscall，每个进程拥有自己的page table，并通过EPT实现内存保护。</p><p>可以通过DUNE实现一个sandbox，因为DUNE进程中的supervisor部分是被保护的，因此可以让一个进程中的不受信任的部分（比如浏览器中的第三方插件）运行在USER MODE中，这就是一个sandbox，可以限制它对内存的访问</p><p>也可以通过DUNE来实现快速的garbage collector，因为在gc查找object的过程中可能object会被修改，这时需要通过PTE_D(dirty)来查找内存中的哪些地址被修改了，如果每次都陷入内核态就会造成速度很慢，但是在DUNE进程下不需要陷入内核态，因为每个进程的SUPERVISOR模式可以直接查看PTE</p><h1 id="lecture-17-networking">Lecture 17 Networking</h1><h2 id="171-network-architecture-and-protocols">17.1 Network Architecture and Protocols</h2><p><strong>Ethernet</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210225105240239.png" alt="image-20210225105240239" /></p><p>局域网(Local Area Network)下各个主机都是通过Ethernet进行连接</p><p>Ethernet frame结构：start flag + 48位目标eth地址 + 48位源eth地址 + 16位ether type（payload中的数据协议类型）+ payload + end flag</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// an Ethernet packet header (start of the packet).</span>
<span class="k">struct</span> <span class="n">eth</span> <span class="p">{</span>
  <span class="n">uint8</span>  <span class="n">dhost</span><span class="p">[</span><span class="n">ETHADDR_LEN</span><span class="p">];</span>
  <span class="n">uint8</span>  <span class="n">shost</span><span class="p">[</span><span class="n">ETHADDR_LEN</span><span class="p">];</span>
  <span class="n">uint16</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>
</pre></table></code></div></div><p>eth地址由NIC的制造商决定</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210225104608593.png" alt="image-20210225104608593" /></p><p>Internet下各个LAN通过router之间的TCP/IP协议进行连接</p><p><strong>ARP</strong></p><p>Ethernet协议足以将packet在LAN中传送，但是如果需要将packet传送给远程Host，需要IP地址。ARP协议是将IP地址翻译为eth地址的协议，嵌套在ethernet packet中(即ether header后面就是ARP header，ARP header是ether header的payload)，ARP header请求一个IP地址对应的eth地址，这个ARP header会被所有LAN内的host接收，对应的Host将返回IP地址</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// an ARP packet (comes after an Ethernet header).</span>
<span class="k">struct</span> <span class="n">arp</span> <span class="p">{</span>
  <span class="n">uint16</span> <span class="n">hrd</span><span class="p">;</span> <span class="c1">// format of hardware address</span>
  <span class="n">uint16</span> <span class="n">pro</span><span class="p">;</span> <span class="c1">// format of protocol address</span>
  <span class="n">uint8</span>  <span class="n">hln</span><span class="p">;</span> <span class="c1">// length of hardware address</span>
  <span class="n">uint8</span>  <span class="n">pln</span><span class="p">;</span> <span class="c1">// length of protocol address</span>
  <span class="n">uint16</span> <span class="n">op</span><span class="p">;</span>  <span class="c1">// operation</span>

  <span class="kt">char</span>   <span class="n">sha</span><span class="p">[</span><span class="n">ETHADDR_LEN</span><span class="p">];</span> <span class="c1">// sender hardware address</span>
  <span class="n">uint32</span> <span class="n">sip</span><span class="p">;</span>              <span class="c1">// sender IP address</span>
  <span class="kt">char</span>   <span class="n">tha</span><span class="p">[</span><span class="n">ETHADDR_LEN</span><span class="p">];</span> <span class="c1">// target hardware address</span>
  <span class="n">uint32</span> <span class="n">tip</span><span class="p">;</span>              <span class="c1">// target IP address</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cp">#define ARP_HRD_ETHER 1 // Ethernet
</span>
<span class="k">enum</span> <span class="p">{</span>
  <span class="n">ARP_OP_REQUEST</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// requests hw addr given protocol addr</span>
  <span class="n">ARP_OP_REPLY</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>   <span class="c1">// replies a hw addr given protocol addr</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>IP</strong></p><p>IP packet的ethernet type=0x0800，IP header中包括了32位的IP地址，高位的IP地址是network number来帮助router将packet进行转发，protocol number让接收者知道这个IP packet的更高级协议是什么。在packet从一个router转发到另一个router的过程中，ether header会被除去，但是IP header一直是保留着的</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// an IP packet header (comes after an Ethernet header).</span>
<span class="k">struct</span> <span class="n">ip</span> <span class="p">{</span>
  <span class="n">uint8</span>  <span class="n">ip_vhl</span><span class="p">;</span> <span class="c1">// version &lt;&lt; 4 | header length &gt;&gt; 2</span>
  <span class="n">uint8</span>  <span class="n">ip_tos</span><span class="p">;</span> <span class="c1">// type of service</span>
  <span class="n">uint16</span> <span class="n">ip_len</span><span class="p">;</span> <span class="c1">// total length</span>
  <span class="n">uint16</span> <span class="n">ip_id</span><span class="p">;</span>  <span class="c1">// identification</span>
  <span class="n">uint16</span> <span class="n">ip_off</span><span class="p">;</span> <span class="c1">// fragment offset field</span>
  <span class="n">uint8</span>  <span class="n">ip_ttl</span><span class="p">;</span> <span class="c1">// time to live</span>
  <span class="n">uint8</span>  <span class="n">ip_p</span><span class="p">;</span>   <span class="c1">// protocol</span>
  <span class="n">uint16</span> <span class="n">ip_sum</span><span class="p">;</span> <span class="c1">// checksum</span>
  <span class="n">uint32</span> <span class="n">ip_src</span><span class="p">,</span> <span class="n">ip_dst</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>UDP</strong></p><p>UDP是传输层协议，根据sockets API规定了当一个packet到达正确host时需要被发送到的端口号，操作系统将把这个端口号上获取的packets作为一个file descriptor以供进程读取。端口号53是DNS server指定的端口号</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// a UDP packet header (comes after an IP header).</span>
<span class="k">struct</span> <span class="n">udp</span> <span class="p">{</span>
  <span class="n">uint16</span> <span class="n">sport</span><span class="p">;</span> <span class="c1">// source port</span>
  <span class="n">uint16</span> <span class="n">dport</span><span class="p">;</span> <span class="c1">// destination port</span>
  <span class="n">uint16</span> <span class="n">ulen</span><span class="p">;</span>  <span class="c1">// length, including udp header, not including IP header</span>
  <span class="n">uint16</span> <span class="n">sum</span><span class="p">;</span>   <span class="c1">// checksum</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="172-kernel-network-stack">17.2 Kernel network stack</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210225144905075.png" alt="image-20210225144905075" /></p><p>在network stack中的packet存放在缓存中，比如<code class="language-plaintext highlighter-rouge">mbuf</code>，每一层将解析、校验header或添加header实现nesting</p><h2 id="173-lab-11-net">17.3 Lab 11: net</h2><p><strong>E1000网卡基本结构：</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210224094108970.png" alt="image-20210224094108970" /></p><p>以太网网卡包括OSI模型的2个层：物理层和数据链路层。物理层由PHY芯片控制，定义了数据传送与接收所需要的光电信号、时钟基准等。数据链路层由MAC芯片控制，提供寻址机构、数据帧的构建、向网络层提供标准数据接口等功能。</p><p><strong>从PCI总线到MAC芯片的分解图：</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210224101444413.png" alt="image-20210224101444413" /></p><p>DMA(Direct Memory Access)是可以不通过CPU直接访问内存的机制，在进行DMA传输时DMA Engine控制PCI总线，将内存中的数据和FIFO data buffer (64KB)中的数据互传。</p><p><strong>发送数据的流程：</strong></p><p>CPU将IP数据包打包放入内存中，通知DMA Engine进行DMA传输，数据放入FIFO data buffer中。MAC将IP数据包拆分为最小64KB，最大1518KB的数据帧，每一帧包含了目标MAC地址、自己的MAC地址和数据包中的协议类型以及CRC校验码。目标MAC地址通过ARP协议获取。PHY接受MAC传送的数据，将并行数据转化为串行数据后进行编码，在转变为模拟信号将数据进行传输。</p><p><strong>Ring结构</strong>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210227125455380.png" alt="image-20210227125455380" /></p><p>RAM中的tx/rx buffer是一个环形结构，有head和tail2个指针，其中head的位置由网卡控制，在进行发送时，每发送完成一个packet网卡就会自动将head向前移动一个mbuf，而需要将某个packet发送时，软件将tail向前移动一个mbuf；在进行接收时，每接收到一个packet网卡自动将head向前移动一个mbuf，软件读取tail所指向的mbuf，并向前移动。移动到最后一个mbuf后从头开始，形成一个wrap-up的结构。</p><p>descriptor结构是在网卡的寄存器中的，用于描述每一个RAM中的mbuf</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210227130330451.png" alt="image-20210227130330451" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/MIT_6S081/image-20210227130436589.png" alt="image-20210227130436589" /></p><p>实验按照hint一步步进行即可</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="c1">// e1000.c</span>
<span class="kt">int</span>
<span class="nf">e1000_transmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mbuf</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//</span>
  <span class="c1">// Your code here.</span>
  <span class="c1">//</span>
  <span class="c1">// the mbuf contains an ethernet frame; program it into</span>
  <span class="c1">// the TX descriptor ring so that the e1000 sends it. Stash</span>
  <span class="c1">// a pointer so that it can be freed after sending.</span>
  <span class="c1">//</span>
  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e1000_lock</span><span class="p">);</span>
  <span class="n">uint32</span> <span class="n">tx_index</span> <span class="o">=</span> <span class="n">regs</span><span class="p">[</span><span class="n">E1000_TDT</span><span class="p">];</span>  <span class="c1">// tail pointer</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">tx_index</span><span class="p">].</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_TXD_STAT_DD</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e1000_lock</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tx_mbufs</span><span class="p">[</span><span class="n">tx_index</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">mbuffree</span><span class="p">(</span><span class="n">tx_mbufs</span><span class="p">[</span><span class="n">tx_index</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="c1">// fill in the mbuf ring</span>
  <span class="n">tx_mbufs</span><span class="p">[</span><span class="n">tx_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
  <span class="c1">// fill in the descriptor</span>
  <span class="n">tx_ring</span><span class="p">[</span><span class="n">tx_index</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
  <span class="n">tx_ring</span><span class="p">[</span><span class="n">tx_index</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
  <span class="n">tx_ring</span><span class="p">[</span><span class="n">tx_index</span><span class="p">].</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">E1000_TXD_CMD_EOP</span> <span class="o">|</span> <span class="n">E1000_TXD_CMD_RS</span><span class="p">;</span>
  <span class="n">regs</span><span class="p">[</span><span class="n">E1000_TDT</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tx_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span> <span class="c1">// foward the tail by 1</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">tx_index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tx_mbufs</span><span class="p">[</span><span class="n">tx_index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e1000_lock</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e1000_lock</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">e1000_recv</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//</span>
  <span class="c1">// Your code here.</span>
  <span class="c1">//</span>
  <span class="c1">// Check for packets that have arrived from the e1000</span>
  <span class="c1">// Create and deliver an mbuf for each packet (using net_rx()).</span>
  <span class="c1">//</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uint32</span> <span class="n">rx_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">regs</span><span class="p">[</span><span class="n">E1000_RDT</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">RX_RING_SIZE</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">rx_index</span><span class="p">].</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_DD</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">rx_mbufs</span><span class="p">[</span><span class="n">rx_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="p">[</span><span class="n">rx_index</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
    <span class="n">net_rx</span><span class="p">(</span><span class="n">rx_mbufs</span><span class="p">[</span><span class="n">rx_index</span><span class="p">]);</span>
    <span class="n">rx_mbufs</span><span class="p">[</span><span class="n">rx_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">mbufalloc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="c1">// fill in the descriptor</span>
    <span class="n">rx_ring</span><span class="p">[</span><span class="n">rx_index</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">rx_mbufs</span><span class="p">[</span><span class="n">rx_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
    <span class="n">rx_ring</span><span class="p">[</span><span class="n">rx_index</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">regs</span><span class="p">[</span><span class="n">E1000_RDT</span><span class="p">]</span> <span class="o">=</span> <span class="n">rx_index</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>注意<code class="language-plaintext highlighter-rouge">recv()</code>中不需要lock，因为<code class="language-plaintext highlighter-rouge">recv()</code>是在bottom half的interrupt handler中，只有一个进程在跑这个handler，因此不存在共享的数据结构。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/lecture-notes/'>lecture notes</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/others/" class="post-tag no-text-decoration" >Others</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=MIT 6.S081 Lecture Notes - Xiao Fan (樊潇)&url=https://tommyfan34.github.io/posts/MIT-6S081-notes/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=MIT 6.S081 Lecture Notes - Xiao Fan (樊潇)&u=https://tommyfan34.github.io/posts/MIT-6S081-notes/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=MIT 6.S081 Lecture Notes - Xiao Fan (樊潇)&url=https://tommyfan34.github.io/posts/MIT-6S081-notes/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/GAMES101/">GAMES101 Lecture Notes</a><li><a href="/posts/leetcode-notes/">Leetcode Notes</a><li><a href="/posts/LIS-Problem/">LIS Problem</a><li><a href="/posts/Monotone-Stack-Problem/">Monotone Stack Problem</a><li><a href="/posts/CS61B-notes/">UCB CS61B Lecture Notes</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/others/">Others</a> <a class="post-tag" href="/tags/computer-graphics/">Computer Graphics</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/CS61A-notes/"><div class="card-body"> <span class="timeago small" > Mar 17, 2021 <i class="unloaded">2021-03-17T18:11:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>UCB CS61A Lecture Notes</h3><div class="text-muted small"><p> 1 Introduction 本课程基于Structure and Interpretation of Computer Programs (SICP)。课程网址: https://inst.eecs.berkeley.edu/~cs61a/fa20/ 1.1 Python features doctests 在python的def关键词下的一行用"""包裹的文字是叫做docstri...</p></div></div></a></div><div class="card"> <a href="/posts/CS61B-notes/"><div class="card-body"> <span class="timeago small" > Apr 16, 2021 <i class="unloaded">2021-04-16T17:09:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>UCB CS61B Lecture Notes</h3><div class="text-muted small"><p> 1 Introduction CS61B Spring 2018课程网址: https://sp18.datastructur.es/ 推荐的Java参考书：Head First Java 1.1 Java Intro Java是一门静态类型编译型的语言，源文件类型为.java，经过javac编译器将其编译为.class文件，此时.class文件是已经经过类型检查的，再用java解释...</p></div></div></a></div><div class="card"> <a href="/posts/MIT-6-null-notes/"><div class="card-body"> <span class="timeago small" > Jan 14, 2021 <i class="unloaded">2021-01-14T18:32:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MIT 6.null Lecture Notes</h3><div class="text-muted small"><p> Lecture 1 Shell bash中如果想提供一个包含空格的参数，可以用‘或”“把它们引起来，或者用转义字符\，比如My\ Photos来将空格转义 $PATH是环境变量，即在本地文件夹下没有找到对应可以执行的程序时会自动在环境变量的路径中寻找相应的程序。which提示了能够运行本指令的程序路径，比如 ~$ which echo /bin...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/MIT-6-null-notes/" class="btn btn-outline-primary"><p>MIT 6.null Lecture Notes</p></a> <a href="/posts/CS61A-notes/" class="btn btn-outline-primary"><p>UCB CS61A Lecture Notes</p></a></div><div id="comments"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script> <script src='//lib.baomitu.com/valine/latest/Valine.min.js'></script> <script> new Valine({ av: AV, el: '#comments', app_id: 'wp6tzj2sW35FoU9QTAMVl64h-gzGzoHsz', app_key: 'rEv50Y8WsRaFC3Um1ccmOBHD', placeholder: '对FX说些什么吧...', notify: 'true', verify: 'true', avatar: 'mp', recordIP: 'true', enableQQ: 'true', }) </script> </br></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/tommyfan34">Xiao Fan</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/others/">Others</a> <a class="post-tag" href="/tags/computer-graphics/">Computer Graphics</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://tommyfan34.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
