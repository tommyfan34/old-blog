<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://tommyfan34.github.io</id><title>Xiao Fan (樊潇)</title><subtitle>Welcome to my personal webpage! I'm an incoming Caltech EE student and a newbie programmer as well. Hopefully this page logs my advances towards excellence.</subtitle> <updated>2023-03-10T10:39:06+08:00</updated> <author> <name>Xiao Fan</name> <uri>https://tommyfan34.github.io</uri> </author><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="https://tommyfan34.github.io" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2023 Xiao Fan </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>GAMES101 Lecture Notes</title><link href="https://tommyfan34.github.io/posts/GAMES101/" rel="alternate" type="text/html" title="GAMES101 Lecture Notes" /><published>2023-03-07T00:00:00+08:00</published> <updated>2023-03-10T10:38:44+08:00</updated> <id>https://tommyfan34.github.io/posts/GAMES101/</id> <content src="https://tommyfan34.github.io/posts/GAMES101/" /> <author> <name>Xiao Fan</name> </author> <category term="lecture notes" /> <summary> GAMES101现代计算机图形学入门课程笔记 第二章 线性代数 叉乘 叉乘对于右手系来说使用右手螺旋定则。 笛卡尔坐标系下： \[\vec{a} \times \vec{b} = \begin{pmatrix} y_az_b-y_bz_a \\z_ax_b - z_bx_a \\ x_ay_b - y_ax_b \end{pmatrix}\] 矩阵写法： \[\vec{a} \times \vec{b} = A * b = \begin{pmatrix}0 &amp;amp; -z_a &amp;amp; y_a \\ z_a &amp;amp; 0 &amp;amp; -x_a \\ -y_a &amp;amp; x_a &amp;amp; 0\end{pmatrix}\] \(A\)叫做\(\vec{a}\)的伴随矩阵 第三章 变换 齐次坐标 齐次坐标引入是为了线性表示仿射变换（线性变换+平移变换） 2... </summary> </entry> <entry><title>Fenwick Tree</title><link href="https://tommyfan34.github.io/posts/Fenwick-Tree/" rel="alternate" type="text/html" title="Fenwick Tree" /><published>2022-07-23T23:59:00+08:00</published> <updated>2022-07-23T23:59:00+08:00</updated> <id>https://tommyfan34.github.io/posts/Fenwick-Tree/</id> <content src="https://tommyfan34.github.io/posts/Fenwick-Tree/" /> <author> <name>Xiao Fan</name> </author> <category term="leetcode notes" /> <summary> 树状数组, 英文Fenwick Tree或Binary Index Tree, 是一种用来在$O(\log N)$时间复杂度内进行前缀和更新和查找的数据结构 Leetcode 307. Range Sum Query - Mutable 问题 Given an integer array nums, handle multiple queries of the following types: Update the value of an element in nums. Calculate the sum of the elements of nums between indices left and right inclusive where left &amp;lt;= right. Implement the NumArray class: NumAr... </summary> </entry> <entry><title>Monotone Stack Problem</title><link href="https://tommyfan34.github.io/posts/Monotone-Stack-Problem/" rel="alternate" type="text/html" title="Monotone Stack Problem" /><published>2021-08-13T22:09:00+08:00</published> <updated>2021-09-13T09:13:03+08:00</updated> <id>https://tommyfan34.github.io/posts/Monotone-Stack-Problem/</id> <content src="https://tommyfan34.github.io/posts/Monotone-Stack-Problem/" /> <author> <name>Xiao Fan</name> </author> <category term="leetcode notes" /> <summary> 单调栈，顾名思义就是栈中的元素满足单调递增或者单调递减的性质，单调栈的典型应用场景是在一维数组中以\(O(N)\)​的时间寻找第一个满足某种条件的数。 比如要在一列人中寻找排在自己前面第一个比自己矮的人，对于站在自己前面比自己高的人higher_peoples，这些人不是自己的目标，而对于下一个要寻找排在他们面前第一个比他们矮的人来说，higher_peoples同样不是他们的目标，因为前面那个人一定比higher_peoples要矮，我宁愿选择前面那个人也不可能选择higher_peoples，因此这些higher_peoples将对结果无法产生任何影响，可以被排除考虑。因此我们可以维护一个栈，每次将那些比当前的人高的前面的人排除出去，这样这个栈中后面来的人一定会比栈中的人高，这就形成了一个单调递增栈。 LeetCode 84. 柱状图中最大的矩形 问题 给定n个非负整数，... </summary> </entry> <entry><title>Graph Problem</title><link href="https://tommyfan34.github.io/posts/Graph-Problem/" rel="alternate" type="text/html" title="Graph Problem" /><published>2021-08-05T09:52:00+08:00</published> <updated>2021-08-24T16:09:52+08:00</updated> <id>https://tommyfan34.github.io/posts/Graph-Problem/</id> <content src="https://tommyfan34.github.io/posts/Graph-Problem/" /> <author> <name>Xiao Fan</name> </author> <category term="leetcode notes" /> <summary> 图问题是一种经典的问题 Leetcode. 802 找到最终的安全状态 问题 在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。 对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是安全的。 返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按升序排列。 该有向图有n个节点，按0到n - 1编号，其中n是graph的节点数。图以下述形式给出: graph[i]是编号j节点的一个列表，满足(i, j)是图的一条有向边。 示例 示例 1： 输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]] 输出：[2,4,5,6] 解释：示意图如上。 示例 2： 输入：grap... </summary> </entry> <entry><title>Trie Problem</title><link href="https://tommyfan34.github.io/posts/Trie-Problem/" rel="alternate" type="text/html" title="Trie Problem" /><published>2021-07-30T21:26:00+08:00</published> <updated>2021-08-13T23:26:10+08:00</updated> <id>https://tommyfan34.github.io/posts/Trie-Problem/</id> <content src="https://tommyfan34.github.io/posts/Trie-Problem/" /> <author> <name>Xiao Fan</name> </author> <category term="leetcode notes" /> <summary> 本文讨论可以使用前缀树Trie来解决的一些问题。 Leetcode 1948. 删除系统中的重复文件夹 问题 由于一个漏洞，文件系统中存在许多重复文件夹。给你一个二维数组paths，其中paths[i]是一个表示文件系统中第i个文件夹的绝对路径的数组。 例如，[“one”, “two”, “three”] 表示路径 “/one/two/three” 。 如果两个文件夹（不需要在同一层级）包含 非空且相同的 子文件夹 集合 并具有相同的子文件夹结构，则认为这两个文件夹是相同文件夹。相同文件夹的根层级 不 需要相同。如果存在两个（或两个以上）相同 文件夹，则需要将这些文件夹和所有它们的子文件夹 标记 为待删除。 例如，下面文件结构中的文件夹 “/a” 和 “/b” 相同。它们（以及它们的子文件夹）应该被 全部 标记为待删除： /a /a/x /a/x/y /a/... </summary> </entry> </feed>
